// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtlm_ipc_axis.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_xtlm_5fipc_5faxis_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_xtlm_5fipc_5faxis_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_xtlm_5fipc_5faxis_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_xtlm_5fipc_5faxis_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_xtlm_5fipc_5faxis_2eproto;
namespace xtlm_ipc {
class axi_stream_frame;
struct axi_stream_frameDefaultTypeInternal;
extern axi_stream_frameDefaultTypeInternal _axi_stream_frame_default_instance_;
class axi_stream_frames;
struct axi_stream_framesDefaultTypeInternal;
extern axi_stream_framesDefaultTypeInternal _axi_stream_frames_default_instance_;
class axi_stream_packet;
struct axi_stream_packetDefaultTypeInternal;
extern axi_stream_packetDefaultTypeInternal _axi_stream_packet_default_instance_;
class axi_stream_resp;
struct axi_stream_respDefaultTypeInternal;
extern axi_stream_respDefaultTypeInternal _axi_stream_resp_default_instance_;
class axi_stream_responses;
struct axi_stream_responsesDefaultTypeInternal;
extern axi_stream_responsesDefaultTypeInternal _axi_stream_responses_default_instance_;
class axi_stream_sample_req;
struct axi_stream_sample_reqDefaultTypeInternal;
extern axi_stream_sample_reqDefaultTypeInternal _axi_stream_sample_req_default_instance_;
}  // namespace xtlm_ipc
PROTOBUF_NAMESPACE_OPEN
template<> ::xtlm_ipc::axi_stream_frame* Arena::CreateMaybeMessage<::xtlm_ipc::axi_stream_frame>(Arena*);
template<> ::xtlm_ipc::axi_stream_frames* Arena::CreateMaybeMessage<::xtlm_ipc::axi_stream_frames>(Arena*);
template<> ::xtlm_ipc::axi_stream_packet* Arena::CreateMaybeMessage<::xtlm_ipc::axi_stream_packet>(Arena*);
template<> ::xtlm_ipc::axi_stream_resp* Arena::CreateMaybeMessage<::xtlm_ipc::axi_stream_resp>(Arena*);
template<> ::xtlm_ipc::axi_stream_responses* Arena::CreateMaybeMessage<::xtlm_ipc::axi_stream_responses>(Arena*);
template<> ::xtlm_ipc::axi_stream_sample_req* Arena::CreateMaybeMessage<::xtlm_ipc::axi_stream_sample_req>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xtlm_ipc {

// ===================================================================

class axi_stream_packet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xtlm_ipc.axi_stream_packet) */ {
 public:
  inline axi_stream_packet() : axi_stream_packet(nullptr) {}
  ~axi_stream_packet() override;
  explicit PROTOBUF_CONSTEXPR axi_stream_packet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  axi_stream_packet(const axi_stream_packet& from);
  axi_stream_packet(axi_stream_packet&& from) noexcept
    : axi_stream_packet() {
    *this = ::std::move(from);
  }

  inline axi_stream_packet& operator=(const axi_stream_packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline axi_stream_packet& operator=(axi_stream_packet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const axi_stream_packet& default_instance() {
    return *internal_default_instance();
  }
  static inline const axi_stream_packet* internal_default_instance() {
    return reinterpret_cast<const axi_stream_packet*>(
               &_axi_stream_packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(axi_stream_packet& a, axi_stream_packet& b) {
    a.Swap(&b);
  }
  inline void Swap(axi_stream_packet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(axi_stream_packet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  axi_stream_packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<axi_stream_packet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const axi_stream_packet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const axi_stream_packet& from) {
    axi_stream_packet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(axi_stream_packet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xtlm_ipc.axi_stream_packet";
  }
  protected:
  explicit axi_stream_packet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kTuserFieldNumber = 4,
    kTkeepFieldNumber = 5,
    kTstrbFieldNumber = 6,
    kDataLengthFieldNumber = 2,
    kTlastFieldNumber = 3,
    kDelayFieldNumber = 7,
  };
  // required bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes tuser = 4;
  bool has_tuser() const;
  private:
  bool _internal_has_tuser() const;
  public:
  void clear_tuser();
  const std::string& tuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tuser();
  PROTOBUF_NODISCARD std::string* release_tuser();
  void set_allocated_tuser(std::string* tuser);
  private:
  const std::string& _internal_tuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tuser(const std::string& value);
  std::string* _internal_mutable_tuser();
  public:

  // optional bytes tkeep = 5;
  bool has_tkeep() const;
  private:
  bool _internal_has_tkeep() const;
  public:
  void clear_tkeep();
  const std::string& tkeep() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tkeep(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tkeep();
  PROTOBUF_NODISCARD std::string* release_tkeep();
  void set_allocated_tkeep(std::string* tkeep);
  private:
  const std::string& _internal_tkeep() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tkeep(const std::string& value);
  std::string* _internal_mutable_tkeep();
  public:

  // optional bytes tstrb = 6;
  bool has_tstrb() const;
  private:
  bool _internal_has_tstrb() const;
  public:
  void clear_tstrb();
  const std::string& tstrb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tstrb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tstrb();
  PROTOBUF_NODISCARD std::string* release_tstrb();
  void set_allocated_tstrb(std::string* tstrb);
  private:
  const std::string& _internal_tstrb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tstrb(const std::string& value);
  std::string* _internal_mutable_tstrb();
  public:

  // required int32 data_length = 2;
  bool has_data_length() const;
  private:
  bool _internal_has_data_length() const;
  public:
  void clear_data_length();
  int32_t data_length() const;
  void set_data_length(int32_t value);
  private:
  int32_t _internal_data_length() const;
  void _internal_set_data_length(int32_t value);
  public:

  // optional bool tlast = 3;
  bool has_tlast() const;
  private:
  bool _internal_has_tlast() const;
  public:
  void clear_tlast();
  bool tlast() const;
  void set_tlast(bool value);
  private:
  bool _internal_tlast() const;
  void _internal_set_tlast(bool value);
  public:

  // optional float delay = 7;
  bool has_delay() const;
  private:
  bool _internal_has_delay() const;
  public:
  void clear_delay();
  float delay() const;
  void set_delay(float value);
  private:
  float _internal_delay() const;
  void _internal_set_delay(float value);
  public:

  // @@protoc_insertion_point(class_scope:xtlm_ipc.axi_stream_packet)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tuser_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tkeep_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tstrb_;
    int32_t data_length_;
    bool tlast_;
    float delay_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xtlm_5fipc_5faxis_2eproto;
};
// -------------------------------------------------------------------

class axi_stream_resp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xtlm_ipc.axi_stream_resp) */ {
 public:
  inline axi_stream_resp() : axi_stream_resp(nullptr) {}
  ~axi_stream_resp() override;
  explicit PROTOBUF_CONSTEXPR axi_stream_resp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  axi_stream_resp(const axi_stream_resp& from);
  axi_stream_resp(axi_stream_resp&& from) noexcept
    : axi_stream_resp() {
    *this = ::std::move(from);
  }

  inline axi_stream_resp& operator=(const axi_stream_resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline axi_stream_resp& operator=(axi_stream_resp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const axi_stream_resp& default_instance() {
    return *internal_default_instance();
  }
  static inline const axi_stream_resp* internal_default_instance() {
    return reinterpret_cast<const axi_stream_resp*>(
               &_axi_stream_resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(axi_stream_resp& a, axi_stream_resp& b) {
    a.Swap(&b);
  }
  inline void Swap(axi_stream_resp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(axi_stream_resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  axi_stream_resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<axi_stream_resp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const axi_stream_resp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const axi_stream_resp& from) {
    axi_stream_resp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(axi_stream_resp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xtlm_ipc.axi_stream_resp";
  }
  protected:
  explicit axi_stream_resp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // optional bool ready = 1 [default = true];
  bool has_ready() const;
  private:
  bool _internal_has_ready() const;
  public:
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xtlm_ipc.axi_stream_resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ready_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xtlm_5fipc_5faxis_2eproto;
};
// -------------------------------------------------------------------

class axi_stream_responses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xtlm_ipc.axi_stream_responses) */ {
 public:
  inline axi_stream_responses() : axi_stream_responses(nullptr) {}
  ~axi_stream_responses() override;
  explicit PROTOBUF_CONSTEXPR axi_stream_responses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  axi_stream_responses(const axi_stream_responses& from);
  axi_stream_responses(axi_stream_responses&& from) noexcept
    : axi_stream_responses() {
    *this = ::std::move(from);
  }

  inline axi_stream_responses& operator=(const axi_stream_responses& from) {
    CopyFrom(from);
    return *this;
  }
  inline axi_stream_responses& operator=(axi_stream_responses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const axi_stream_responses& default_instance() {
    return *internal_default_instance();
  }
  static inline const axi_stream_responses* internal_default_instance() {
    return reinterpret_cast<const axi_stream_responses*>(
               &_axi_stream_responses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(axi_stream_responses& a, axi_stream_responses& b) {
    a.Swap(&b);
  }
  inline void Swap(axi_stream_responses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(axi_stream_responses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  axi_stream_responses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<axi_stream_responses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const axi_stream_responses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const axi_stream_responses& from) {
    axi_stream_responses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(axi_stream_responses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xtlm_ipc.axi_stream_responses";
  }
  protected:
  explicit axi_stream_responses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // repeated bool ready = 1 [packed = true];
  int ready_size() const;
  private:
  int _internal_ready_size() const;
  public:
  void clear_ready();
  private:
  bool _internal_ready(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_ready() const;
  void _internal_add_ready(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_ready();
  public:
  bool ready(int index) const;
  void set_ready(int index, bool value);
  void add_ready(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      ready() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_ready();

  // @@protoc_insertion_point(class_scope:xtlm_ipc.axi_stream_responses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xtlm_5fipc_5faxis_2eproto;
};
// -------------------------------------------------------------------

class axi_stream_sample_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xtlm_ipc.axi_stream_sample_req) */ {
 public:
  inline axi_stream_sample_req() : axi_stream_sample_req(nullptr) {}
  ~axi_stream_sample_req() override;
  explicit PROTOBUF_CONSTEXPR axi_stream_sample_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  axi_stream_sample_req(const axi_stream_sample_req& from);
  axi_stream_sample_req(axi_stream_sample_req&& from) noexcept
    : axi_stream_sample_req() {
    *this = ::std::move(from);
  }

  inline axi_stream_sample_req& operator=(const axi_stream_sample_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline axi_stream_sample_req& operator=(axi_stream_sample_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const axi_stream_sample_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const axi_stream_sample_req* internal_default_instance() {
    return reinterpret_cast<const axi_stream_sample_req*>(
               &_axi_stream_sample_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(axi_stream_sample_req& a, axi_stream_sample_req& b) {
    a.Swap(&b);
  }
  inline void Swap(axi_stream_sample_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(axi_stream_sample_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  axi_stream_sample_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<axi_stream_sample_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const axi_stream_sample_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const axi_stream_sample_req& from) {
    axi_stream_sample_req::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(axi_stream_sample_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xtlm_ipc.axi_stream_sample_req";
  }
  protected:
  explicit axi_stream_sample_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleFieldNumber = 1,
  };
  // optional bool sample = 1 [default = true];
  bool has_sample() const;
  private:
  bool _internal_has_sample() const;
  public:
  void clear_sample();
  bool sample() const;
  void set_sample(bool value);
  private:
  bool _internal_sample() const;
  void _internal_set_sample(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xtlm_ipc.axi_stream_sample_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool sample_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xtlm_5fipc_5faxis_2eproto;
};
// -------------------------------------------------------------------

class axi_stream_frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xtlm_ipc.axi_stream_frame) */ {
 public:
  inline axi_stream_frame() : axi_stream_frame(nullptr) {}
  ~axi_stream_frame() override;
  explicit PROTOBUF_CONSTEXPR axi_stream_frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  axi_stream_frame(const axi_stream_frame& from);
  axi_stream_frame(axi_stream_frame&& from) noexcept
    : axi_stream_frame() {
    *this = ::std::move(from);
  }

  inline axi_stream_frame& operator=(const axi_stream_frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline axi_stream_frame& operator=(axi_stream_frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const axi_stream_frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const axi_stream_frame* internal_default_instance() {
    return reinterpret_cast<const axi_stream_frame*>(
               &_axi_stream_frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(axi_stream_frame& a, axi_stream_frame& b) {
    a.Swap(&b);
  }
  inline void Swap(axi_stream_frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(axi_stream_frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  axi_stream_frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<axi_stream_frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const axi_stream_frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const axi_stream_frame& from) {
    axi_stream_frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(axi_stream_frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xtlm_ipc.axi_stream_frame";
  }
  protected:
  explicit axi_stream_frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
  };
  // repeated .xtlm_ipc.axi_stream_packet frame = 1;
  int frame_size() const;
  private:
  int _internal_frame_size() const;
  public:
  void clear_frame();
  ::xtlm_ipc::axi_stream_packet* mutable_frame(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_packet >*
      mutable_frame();
  private:
  const ::xtlm_ipc::axi_stream_packet& _internal_frame(int index) const;
  ::xtlm_ipc::axi_stream_packet* _internal_add_frame();
  public:
  const ::xtlm_ipc::axi_stream_packet& frame(int index) const;
  ::xtlm_ipc::axi_stream_packet* add_frame();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_packet >&
      frame() const;

  // @@protoc_insertion_point(class_scope:xtlm_ipc.axi_stream_frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_packet > frame_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xtlm_5fipc_5faxis_2eproto;
};
// -------------------------------------------------------------------

class axi_stream_frames final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xtlm_ipc.axi_stream_frames) */ {
 public:
  inline axi_stream_frames() : axi_stream_frames(nullptr) {}
  ~axi_stream_frames() override;
  explicit PROTOBUF_CONSTEXPR axi_stream_frames(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  axi_stream_frames(const axi_stream_frames& from);
  axi_stream_frames(axi_stream_frames&& from) noexcept
    : axi_stream_frames() {
    *this = ::std::move(from);
  }

  inline axi_stream_frames& operator=(const axi_stream_frames& from) {
    CopyFrom(from);
    return *this;
  }
  inline axi_stream_frames& operator=(axi_stream_frames&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const axi_stream_frames& default_instance() {
    return *internal_default_instance();
  }
  static inline const axi_stream_frames* internal_default_instance() {
    return reinterpret_cast<const axi_stream_frames*>(
               &_axi_stream_frames_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(axi_stream_frames& a, axi_stream_frames& b) {
    a.Swap(&b);
  }
  inline void Swap(axi_stream_frames* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(axi_stream_frames* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  axi_stream_frames* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<axi_stream_frames>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const axi_stream_frames& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const axi_stream_frames& from) {
    axi_stream_frames::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(axi_stream_frames* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xtlm_ipc.axi_stream_frames";
  }
  protected:
  explicit axi_stream_frames(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 1,
  };
  // repeated .xtlm_ipc.axi_stream_frame frames = 1;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::xtlm_ipc::axi_stream_frame* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_frame >*
      mutable_frames();
  private:
  const ::xtlm_ipc::axi_stream_frame& _internal_frames(int index) const;
  ::xtlm_ipc::axi_stream_frame* _internal_add_frames();
  public:
  const ::xtlm_ipc::axi_stream_frame& frames(int index) const;
  ::xtlm_ipc::axi_stream_frame* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_frame >&
      frames() const;

  // @@protoc_insertion_point(class_scope:xtlm_ipc.axi_stream_frames)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_frame > frames_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xtlm_5fipc_5faxis_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// axi_stream_packet

// required bytes data = 1;
inline bool axi_stream_packet::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool axi_stream_packet::has_data() const {
  return _internal_has_data();
}
inline void axi_stream_packet::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& axi_stream_packet::data() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void axi_stream_packet::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.data)
}
inline std::string* axi_stream_packet::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xtlm_ipc.axi_stream_packet.data)
  return _s;
}
inline const std::string& axi_stream_packet::_internal_data() const {
  return _impl_.data_.Get();
}
inline void axi_stream_packet::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* axi_stream_packet::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* axi_stream_packet::release_data() {
  // @@protoc_insertion_point(field_release:xtlm_ipc.axi_stream_packet.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void axi_stream_packet::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xtlm_ipc.axi_stream_packet.data)
}

// required int32 data_length = 2;
inline bool axi_stream_packet::_internal_has_data_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool axi_stream_packet::has_data_length() const {
  return _internal_has_data_length();
}
inline void axi_stream_packet::clear_data_length() {
  _impl_.data_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t axi_stream_packet::_internal_data_length() const {
  return _impl_.data_length_;
}
inline int32_t axi_stream_packet::data_length() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.data_length)
  return _internal_data_length();
}
inline void axi_stream_packet::_internal_set_data_length(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.data_length_ = value;
}
inline void axi_stream_packet::set_data_length(int32_t value) {
  _internal_set_data_length(value);
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.data_length)
}

// optional bool tlast = 3;
inline bool axi_stream_packet::_internal_has_tlast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool axi_stream_packet::has_tlast() const {
  return _internal_has_tlast();
}
inline void axi_stream_packet::clear_tlast() {
  _impl_.tlast_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool axi_stream_packet::_internal_tlast() const {
  return _impl_.tlast_;
}
inline bool axi_stream_packet::tlast() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.tlast)
  return _internal_tlast();
}
inline void axi_stream_packet::_internal_set_tlast(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tlast_ = value;
}
inline void axi_stream_packet::set_tlast(bool value) {
  _internal_set_tlast(value);
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.tlast)
}

// optional bytes tuser = 4;
inline bool axi_stream_packet::_internal_has_tuser() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool axi_stream_packet::has_tuser() const {
  return _internal_has_tuser();
}
inline void axi_stream_packet::clear_tuser() {
  _impl_.tuser_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& axi_stream_packet::tuser() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.tuser)
  return _internal_tuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void axi_stream_packet::set_tuser(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tuser_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.tuser)
}
inline std::string* axi_stream_packet::mutable_tuser() {
  std::string* _s = _internal_mutable_tuser();
  // @@protoc_insertion_point(field_mutable:xtlm_ipc.axi_stream_packet.tuser)
  return _s;
}
inline const std::string& axi_stream_packet::_internal_tuser() const {
  return _impl_.tuser_.Get();
}
inline void axi_stream_packet::_internal_set_tuser(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tuser_.Set(value, GetArenaForAllocation());
}
inline std::string* axi_stream_packet::_internal_mutable_tuser() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tuser_.Mutable(GetArenaForAllocation());
}
inline std::string* axi_stream_packet::release_tuser() {
  // @@protoc_insertion_point(field_release:xtlm_ipc.axi_stream_packet.tuser)
  if (!_internal_has_tuser()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tuser_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tuser_.IsDefault()) {
    _impl_.tuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void axi_stream_packet::set_allocated_tuser(std::string* tuser) {
  if (tuser != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tuser_.SetAllocated(tuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tuser_.IsDefault()) {
    _impl_.tuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xtlm_ipc.axi_stream_packet.tuser)
}

// optional bytes tkeep = 5;
inline bool axi_stream_packet::_internal_has_tkeep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool axi_stream_packet::has_tkeep() const {
  return _internal_has_tkeep();
}
inline void axi_stream_packet::clear_tkeep() {
  _impl_.tkeep_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& axi_stream_packet::tkeep() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.tkeep)
  return _internal_tkeep();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void axi_stream_packet::set_tkeep(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.tkeep_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.tkeep)
}
inline std::string* axi_stream_packet::mutable_tkeep() {
  std::string* _s = _internal_mutable_tkeep();
  // @@protoc_insertion_point(field_mutable:xtlm_ipc.axi_stream_packet.tkeep)
  return _s;
}
inline const std::string& axi_stream_packet::_internal_tkeep() const {
  return _impl_.tkeep_.Get();
}
inline void axi_stream_packet::_internal_set_tkeep(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tkeep_.Set(value, GetArenaForAllocation());
}
inline std::string* axi_stream_packet::_internal_mutable_tkeep() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.tkeep_.Mutable(GetArenaForAllocation());
}
inline std::string* axi_stream_packet::release_tkeep() {
  // @@protoc_insertion_point(field_release:xtlm_ipc.axi_stream_packet.tkeep)
  if (!_internal_has_tkeep()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.tkeep_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tkeep_.IsDefault()) {
    _impl_.tkeep_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void axi_stream_packet::set_allocated_tkeep(std::string* tkeep) {
  if (tkeep != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tkeep_.SetAllocated(tkeep, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tkeep_.IsDefault()) {
    _impl_.tkeep_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xtlm_ipc.axi_stream_packet.tkeep)
}

// optional bytes tstrb = 6;
inline bool axi_stream_packet::_internal_has_tstrb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool axi_stream_packet::has_tstrb() const {
  return _internal_has_tstrb();
}
inline void axi_stream_packet::clear_tstrb() {
  _impl_.tstrb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& axi_stream_packet::tstrb() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.tstrb)
  return _internal_tstrb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void axi_stream_packet::set_tstrb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.tstrb_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.tstrb)
}
inline std::string* axi_stream_packet::mutable_tstrb() {
  std::string* _s = _internal_mutable_tstrb();
  // @@protoc_insertion_point(field_mutable:xtlm_ipc.axi_stream_packet.tstrb)
  return _s;
}
inline const std::string& axi_stream_packet::_internal_tstrb() const {
  return _impl_.tstrb_.Get();
}
inline void axi_stream_packet::_internal_set_tstrb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tstrb_.Set(value, GetArenaForAllocation());
}
inline std::string* axi_stream_packet::_internal_mutable_tstrb() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tstrb_.Mutable(GetArenaForAllocation());
}
inline std::string* axi_stream_packet::release_tstrb() {
  // @@protoc_insertion_point(field_release:xtlm_ipc.axi_stream_packet.tstrb)
  if (!_internal_has_tstrb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.tstrb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tstrb_.IsDefault()) {
    _impl_.tstrb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void axi_stream_packet::set_allocated_tstrb(std::string* tstrb) {
  if (tstrb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tstrb_.SetAllocated(tstrb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tstrb_.IsDefault()) {
    _impl_.tstrb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xtlm_ipc.axi_stream_packet.tstrb)
}

// optional float delay = 7;
inline bool axi_stream_packet::_internal_has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool axi_stream_packet::has_delay() const {
  return _internal_has_delay();
}
inline void axi_stream_packet::clear_delay() {
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float axi_stream_packet::_internal_delay() const {
  return _impl_.delay_;
}
inline float axi_stream_packet::delay() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_packet.delay)
  return _internal_delay();
}
inline void axi_stream_packet::_internal_set_delay(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.delay_ = value;
}
inline void axi_stream_packet::set_delay(float value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_packet.delay)
}

// -------------------------------------------------------------------

// axi_stream_resp

// optional bool ready = 1 [default = true];
inline bool axi_stream_resp::_internal_has_ready() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool axi_stream_resp::has_ready() const {
  return _internal_has_ready();
}
inline void axi_stream_resp::clear_ready() {
  _impl_.ready_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool axi_stream_resp::_internal_ready() const {
  return _impl_.ready_;
}
inline bool axi_stream_resp::ready() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_resp.ready)
  return _internal_ready();
}
inline void axi_stream_resp::_internal_set_ready(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ready_ = value;
}
inline void axi_stream_resp::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_resp.ready)
}

// -------------------------------------------------------------------

// axi_stream_responses

// repeated bool ready = 1 [packed = true];
inline int axi_stream_responses::_internal_ready_size() const {
  return _impl_.ready_.size();
}
inline int axi_stream_responses::ready_size() const {
  return _internal_ready_size();
}
inline void axi_stream_responses::clear_ready() {
  _impl_.ready_.Clear();
}
inline bool axi_stream_responses::_internal_ready(int index) const {
  return _impl_.ready_.Get(index);
}
inline bool axi_stream_responses::ready(int index) const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_responses.ready)
  return _internal_ready(index);
}
inline void axi_stream_responses::set_ready(int index, bool value) {
  _impl_.ready_.Set(index, value);
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_responses.ready)
}
inline void axi_stream_responses::_internal_add_ready(bool value) {
  _impl_.ready_.Add(value);
}
inline void axi_stream_responses::add_ready(bool value) {
  _internal_add_ready(value);
  // @@protoc_insertion_point(field_add:xtlm_ipc.axi_stream_responses.ready)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
axi_stream_responses::_internal_ready() const {
  return _impl_.ready_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
axi_stream_responses::ready() const {
  // @@protoc_insertion_point(field_list:xtlm_ipc.axi_stream_responses.ready)
  return _internal_ready();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
axi_stream_responses::_internal_mutable_ready() {
  return &_impl_.ready_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
axi_stream_responses::mutable_ready() {
  // @@protoc_insertion_point(field_mutable_list:xtlm_ipc.axi_stream_responses.ready)
  return _internal_mutable_ready();
}

// -------------------------------------------------------------------

// axi_stream_sample_req

// optional bool sample = 1 [default = true];
inline bool axi_stream_sample_req::_internal_has_sample() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool axi_stream_sample_req::has_sample() const {
  return _internal_has_sample();
}
inline void axi_stream_sample_req::clear_sample() {
  _impl_.sample_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool axi_stream_sample_req::_internal_sample() const {
  return _impl_.sample_;
}
inline bool axi_stream_sample_req::sample() const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_sample_req.sample)
  return _internal_sample();
}
inline void axi_stream_sample_req::_internal_set_sample(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sample_ = value;
}
inline void axi_stream_sample_req::set_sample(bool value) {
  _internal_set_sample(value);
  // @@protoc_insertion_point(field_set:xtlm_ipc.axi_stream_sample_req.sample)
}

// -------------------------------------------------------------------

// axi_stream_frame

// repeated .xtlm_ipc.axi_stream_packet frame = 1;
inline int axi_stream_frame::_internal_frame_size() const {
  return _impl_.frame_.size();
}
inline int axi_stream_frame::frame_size() const {
  return _internal_frame_size();
}
inline void axi_stream_frame::clear_frame() {
  _impl_.frame_.Clear();
}
inline ::xtlm_ipc::axi_stream_packet* axi_stream_frame::mutable_frame(int index) {
  // @@protoc_insertion_point(field_mutable:xtlm_ipc.axi_stream_frame.frame)
  return _impl_.frame_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_packet >*
axi_stream_frame::mutable_frame() {
  // @@protoc_insertion_point(field_mutable_list:xtlm_ipc.axi_stream_frame.frame)
  return &_impl_.frame_;
}
inline const ::xtlm_ipc::axi_stream_packet& axi_stream_frame::_internal_frame(int index) const {
  return _impl_.frame_.Get(index);
}
inline const ::xtlm_ipc::axi_stream_packet& axi_stream_frame::frame(int index) const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_frame.frame)
  return _internal_frame(index);
}
inline ::xtlm_ipc::axi_stream_packet* axi_stream_frame::_internal_add_frame() {
  return _impl_.frame_.Add();
}
inline ::xtlm_ipc::axi_stream_packet* axi_stream_frame::add_frame() {
  ::xtlm_ipc::axi_stream_packet* _add = _internal_add_frame();
  // @@protoc_insertion_point(field_add:xtlm_ipc.axi_stream_frame.frame)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_packet >&
axi_stream_frame::frame() const {
  // @@protoc_insertion_point(field_list:xtlm_ipc.axi_stream_frame.frame)
  return _impl_.frame_;
}

// -------------------------------------------------------------------

// axi_stream_frames

// repeated .xtlm_ipc.axi_stream_frame frames = 1;
inline int axi_stream_frames::_internal_frames_size() const {
  return _impl_.frames_.size();
}
inline int axi_stream_frames::frames_size() const {
  return _internal_frames_size();
}
inline void axi_stream_frames::clear_frames() {
  _impl_.frames_.Clear();
}
inline ::xtlm_ipc::axi_stream_frame* axi_stream_frames::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:xtlm_ipc.axi_stream_frames.frames)
  return _impl_.frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_frame >*
axi_stream_frames::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:xtlm_ipc.axi_stream_frames.frames)
  return &_impl_.frames_;
}
inline const ::xtlm_ipc::axi_stream_frame& axi_stream_frames::_internal_frames(int index) const {
  return _impl_.frames_.Get(index);
}
inline const ::xtlm_ipc::axi_stream_frame& axi_stream_frames::frames(int index) const {
  // @@protoc_insertion_point(field_get:xtlm_ipc.axi_stream_frames.frames)
  return _internal_frames(index);
}
inline ::xtlm_ipc::axi_stream_frame* axi_stream_frames::_internal_add_frames() {
  return _impl_.frames_.Add();
}
inline ::xtlm_ipc::axi_stream_frame* axi_stream_frames::add_frames() {
  ::xtlm_ipc::axi_stream_frame* _add = _internal_add_frames();
  // @@protoc_insertion_point(field_add:xtlm_ipc.axi_stream_frames.frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xtlm_ipc::axi_stream_frame >&
axi_stream_frames::frames() const {
  // @@protoc_insertion_point(field_list:xtlm_ipc.axi_stream_frames.frames)
  return _impl_.frames_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace xtlm_ipc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_xtlm_5fipc_5faxis_2eproto
