// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rpc_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rpc_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rpc_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rpc_5fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rpc_5fmessages_2eproto;
class call_packet_info;
struct call_packet_infoDefaultTypeInternal;
extern call_packet_infoDefaultTypeInternal _call_packet_info_default_instance_;
class ddr_mem_msg;
struct ddr_mem_msgDefaultTypeInternal;
extern ddr_mem_msgDefaultTypeInternal _ddr_mem_msg_default_instance_;
class response_packet_info;
struct response_packet_infoDefaultTypeInternal;
extern response_packet_infoDefaultTypeInternal _response_packet_info_default_instance_;
class xclAllocDeviceBuffer_call;
struct xclAllocDeviceBuffer_callDefaultTypeInternal;
extern xclAllocDeviceBuffer_callDefaultTypeInternal _xclAllocDeviceBuffer_call_default_instance_;
class xclAllocDeviceBuffer_response;
struct xclAllocDeviceBuffer_responseDefaultTypeInternal;
extern xclAllocDeviceBuffer_responseDefaultTypeInternal _xclAllocDeviceBuffer_response_default_instance_;
class xclClose_call;
struct xclClose_callDefaultTypeInternal;
extern xclClose_callDefaultTypeInternal _xclClose_call_default_instance_;
class xclClose_response;
struct xclClose_responseDefaultTypeInternal;
extern xclClose_responseDefaultTypeInternal _xclClose_response_default_instance_;
class xclCopyBO_call;
struct xclCopyBO_callDefaultTypeInternal;
extern xclCopyBO_callDefaultTypeInternal _xclCopyBO_call_default_instance_;
class xclCopyBO_response;
struct xclCopyBO_responseDefaultTypeInternal;
extern xclCopyBO_responseDefaultTypeInternal _xclCopyBO_response_default_instance_;
class xclCopyBufferDevice2Host_call;
struct xclCopyBufferDevice2Host_callDefaultTypeInternal;
extern xclCopyBufferDevice2Host_callDefaultTypeInternal _xclCopyBufferDevice2Host_call_default_instance_;
class xclCopyBufferDevice2Host_response;
struct xclCopyBufferDevice2Host_responseDefaultTypeInternal;
extern xclCopyBufferDevice2Host_responseDefaultTypeInternal _xclCopyBufferDevice2Host_response_default_instance_;
class xclCopyBufferHost2Device_call;
struct xclCopyBufferHost2Device_callDefaultTypeInternal;
extern xclCopyBufferHost2Device_callDefaultTypeInternal _xclCopyBufferHost2Device_call_default_instance_;
class xclCopyBufferHost2Device_response;
struct xclCopyBufferHost2Device_responseDefaultTypeInternal;
extern xclCopyBufferHost2Device_responseDefaultTypeInternal _xclCopyBufferHost2Device_response_default_instance_;
class xclCreateQueue_call;
struct xclCreateQueue_callDefaultTypeInternal;
extern xclCreateQueue_callDefaultTypeInternal _xclCreateQueue_call_default_instance_;
class xclCreateQueue_response;
struct xclCreateQueue_responseDefaultTypeInternal;
extern xclCreateQueue_responseDefaultTypeInternal _xclCreateQueue_response_default_instance_;
class xclDestroyQueue_call;
struct xclDestroyQueue_callDefaultTypeInternal;
extern xclDestroyQueue_callDefaultTypeInternal _xclDestroyQueue_call_default_instance_;
class xclDestroyQueue_response;
struct xclDestroyQueue_responseDefaultTypeInternal;
extern xclDestroyQueue_responseDefaultTypeInternal _xclDestroyQueue_response_default_instance_;
class xclFreeDeviceBuffer_call;
struct xclFreeDeviceBuffer_callDefaultTypeInternal;
extern xclFreeDeviceBuffer_callDefaultTypeInternal _xclFreeDeviceBuffer_call_default_instance_;
class xclFreeDeviceBuffer_response;
struct xclFreeDeviceBuffer_responseDefaultTypeInternal;
extern xclFreeDeviceBuffer_responseDefaultTypeInternal _xclFreeDeviceBuffer_response_default_instance_;
class xclGetDebugMessages_call;
struct xclGetDebugMessages_callDefaultTypeInternal;
extern xclGetDebugMessages_callDefaultTypeInternal _xclGetDebugMessages_call_default_instance_;
class xclGetDebugMessages_response;
struct xclGetDebugMessages_responseDefaultTypeInternal;
extern xclGetDebugMessages_responseDefaultTypeInternal _xclGetDebugMessages_response_default_instance_;
class xclGetDeviceTimestamp_call;
struct xclGetDeviceTimestamp_callDefaultTypeInternal;
extern xclGetDeviceTimestamp_callDefaultTypeInternal _xclGetDeviceTimestamp_call_default_instance_;
class xclGetDeviceTimestamp_response;
struct xclGetDeviceTimestamp_responseDefaultTypeInternal;
extern xclGetDeviceTimestamp_responseDefaultTypeInternal _xclGetDeviceTimestamp_response_default_instance_;
class xclImportBO_call;
struct xclImportBO_callDefaultTypeInternal;
extern xclImportBO_callDefaultTypeInternal _xclImportBO_call_default_instance_;
class xclImportBO_response;
struct xclImportBO_responseDefaultTypeInternal;
extern xclImportBO_responseDefaultTypeInternal _xclImportBO_response_default_instance_;
class xclInterruptOccured_call;
struct xclInterruptOccured_callDefaultTypeInternal;
extern xclInterruptOccured_callDefaultTypeInternal _xclInterruptOccured_call_default_instance_;
class xclInterruptOccured_response;
struct xclInterruptOccured_responseDefaultTypeInternal;
extern xclInterruptOccured_responseDefaultTypeInternal _xclInterruptOccured_response_default_instance_;
class xclLoadBitstream_call;
struct xclLoadBitstream_callDefaultTypeInternal;
extern xclLoadBitstream_callDefaultTypeInternal _xclLoadBitstream_call_default_instance_;
class xclLoadBitstream_call_ddrbank;
struct xclLoadBitstream_call_ddrbankDefaultTypeInternal;
extern xclLoadBitstream_call_ddrbankDefaultTypeInternal _xclLoadBitstream_call_ddrbank_default_instance_;
class xclLoadBitstream_response;
struct xclLoadBitstream_responseDefaultTypeInternal;
extern xclLoadBitstream_responseDefaultTypeInternal _xclLoadBitstream_response_default_instance_;
class xclPerfMonGetTraceCount_call;
struct xclPerfMonGetTraceCount_callDefaultTypeInternal;
extern xclPerfMonGetTraceCount_callDefaultTypeInternal _xclPerfMonGetTraceCount_call_default_instance_;
class xclPerfMonGetTraceCount_response;
struct xclPerfMonGetTraceCount_responseDefaultTypeInternal;
extern xclPerfMonGetTraceCount_responseDefaultTypeInternal _xclPerfMonGetTraceCount_response_default_instance_;
class xclPerfMonReadCounters_Streaming_call;
struct xclPerfMonReadCounters_Streaming_callDefaultTypeInternal;
extern xclPerfMonReadCounters_Streaming_callDefaultTypeInternal _xclPerfMonReadCounters_Streaming_call_default_instance_;
class xclPerfMonReadCounters_Streaming_response;
struct xclPerfMonReadCounters_Streaming_responseDefaultTypeInternal;
extern xclPerfMonReadCounters_Streaming_responseDefaultTypeInternal _xclPerfMonReadCounters_Streaming_response_default_instance_;
class xclPerfMonReadCounters_call;
struct xclPerfMonReadCounters_callDefaultTypeInternal;
extern xclPerfMonReadCounters_callDefaultTypeInternal _xclPerfMonReadCounters_call_default_instance_;
class xclPerfMonReadCounters_response;
struct xclPerfMonReadCounters_responseDefaultTypeInternal;
extern xclPerfMonReadCounters_responseDefaultTypeInternal _xclPerfMonReadCounters_response_default_instance_;
class xclPerfMonReadTrace_Streaming_call;
struct xclPerfMonReadTrace_Streaming_callDefaultTypeInternal;
extern xclPerfMonReadTrace_Streaming_callDefaultTypeInternal _xclPerfMonReadTrace_Streaming_call_default_instance_;
class xclPerfMonReadTrace_Streaming_response;
struct xclPerfMonReadTrace_Streaming_responseDefaultTypeInternal;
extern xclPerfMonReadTrace_Streaming_responseDefaultTypeInternal _xclPerfMonReadTrace_Streaming_response_default_instance_;
class xclPerfMonReadTrace_Streaming_response_events;
struct xclPerfMonReadTrace_Streaming_response_eventsDefaultTypeInternal;
extern xclPerfMonReadTrace_Streaming_response_eventsDefaultTypeInternal _xclPerfMonReadTrace_Streaming_response_events_default_instance_;
class xclPerfMonReadTrace_call;
struct xclPerfMonReadTrace_callDefaultTypeInternal;
extern xclPerfMonReadTrace_callDefaultTypeInternal _xclPerfMonReadTrace_call_default_instance_;
class xclPerfMonReadTrace_response;
struct xclPerfMonReadTrace_responseDefaultTypeInternal;
extern xclPerfMonReadTrace_responseDefaultTypeInternal _xclPerfMonReadTrace_response_default_instance_;
class xclPerfMonReadTrace_response_events;
struct xclPerfMonReadTrace_response_eventsDefaultTypeInternal;
extern xclPerfMonReadTrace_response_eventsDefaultTypeInternal _xclPerfMonReadTrace_response_events_default_instance_;
class xclPfBarAddrmap_call;
struct xclPfBarAddrmap_callDefaultTypeInternal;
extern xclPfBarAddrmap_callDefaultTypeInternal _xclPfBarAddrmap_call_default_instance_;
class xclPfBarAddrmap_response;
struct xclPfBarAddrmap_responseDefaultTypeInternal;
extern xclPfBarAddrmap_responseDefaultTypeInternal _xclPfBarAddrmap_response_default_instance_;
class xclPfBarAddrmap_response_PfBarmaps;
struct xclPfBarAddrmap_response_PfBarmapsDefaultTypeInternal;
extern xclPfBarAddrmap_response_PfBarmapsDefaultTypeInternal _xclPfBarAddrmap_response_PfBarmaps_default_instance_;
class xclPollCompletion_call;
struct xclPollCompletion_callDefaultTypeInternal;
extern xclPollCompletion_callDefaultTypeInternal _xclPollCompletion_call_default_instance_;
class xclPollCompletion_response;
struct xclPollCompletion_responseDefaultTypeInternal;
extern xclPollCompletion_responseDefaultTypeInternal _xclPollCompletion_response_default_instance_;
class xclPollCompletion_response_request;
struct xclPollCompletion_response_requestDefaultTypeInternal;
extern xclPollCompletion_response_requestDefaultTypeInternal _xclPollCompletion_response_request_default_instance_;
class xclReadAddrKernelCtrl_call;
struct xclReadAddrKernelCtrl_callDefaultTypeInternal;
extern xclReadAddrKernelCtrl_callDefaultTypeInternal _xclReadAddrKernelCtrl_call_default_instance_;
class xclReadAddrKernelCtrl_response;
struct xclReadAddrKernelCtrl_responseDefaultTypeInternal;
extern xclReadAddrKernelCtrl_responseDefaultTypeInternal _xclReadAddrKernelCtrl_response_default_instance_;
class xclReadAddrSpaceDeviceRam_call;
struct xclReadAddrSpaceDeviceRam_callDefaultTypeInternal;
extern xclReadAddrSpaceDeviceRam_callDefaultTypeInternal _xclReadAddrSpaceDeviceRam_call_default_instance_;
class xclReadAddrSpaceDeviceRam_response;
struct xclReadAddrSpaceDeviceRam_responseDefaultTypeInternal;
extern xclReadAddrSpaceDeviceRam_responseDefaultTypeInternal _xclReadAddrSpaceDeviceRam_response_default_instance_;
class xclReadBusStatus_call;
struct xclReadBusStatus_callDefaultTypeInternal;
extern xclReadBusStatus_callDefaultTypeInternal _xclReadBusStatus_call_default_instance_;
class xclReadBusStatus_response;
struct xclReadBusStatus_responseDefaultTypeInternal;
extern xclReadBusStatus_responseDefaultTypeInternal _xclReadBusStatus_response_default_instance_;
class xclReadQueue_call;
struct xclReadQueue_callDefaultTypeInternal;
extern xclReadQueue_callDefaultTypeInternal _xclReadQueue_call_default_instance_;
class xclReadQueue_response;
struct xclReadQueue_responseDefaultTypeInternal;
extern xclReadQueue_responseDefaultTypeInternal _xclReadQueue_response_default_instance_;
class xclSetEnvironment_call;
struct xclSetEnvironment_callDefaultTypeInternal;
extern xclSetEnvironment_callDefaultTypeInternal _xclSetEnvironment_call_default_instance_;
class xclSetEnvironment_call_namevaluepair;
struct xclSetEnvironment_call_namevaluepairDefaultTypeInternal;
extern xclSetEnvironment_call_namevaluepairDefaultTypeInternal _xclSetEnvironment_call_namevaluepair_default_instance_;
class xclSetEnvironment_response;
struct xclSetEnvironment_responseDefaultTypeInternal;
extern xclSetEnvironment_responseDefaultTypeInternal _xclSetEnvironment_response_default_instance_;
class xclSetupInstance_call;
struct xclSetupInstance_callDefaultTypeInternal;
extern xclSetupInstance_callDefaultTypeInternal _xclSetupInstance_call_default_instance_;
class xclSetupInstance_call_argflowpair;
struct xclSetupInstance_call_argflowpairDefaultTypeInternal;
extern xclSetupInstance_call_argflowpairDefaultTypeInternal _xclSetupInstance_call_argflowpair_default_instance_;
class xclSetupInstance_response;
struct xclSetupInstance_responseDefaultTypeInternal;
extern xclSetupInstance_responseDefaultTypeInternal _xclSetupInstance_response_default_instance_;
class xclSlaveReadReq_call;
struct xclSlaveReadReq_callDefaultTypeInternal;
extern xclSlaveReadReq_callDefaultTypeInternal _xclSlaveReadReq_call_default_instance_;
class xclSlaveReadReq_response;
struct xclSlaveReadReq_responseDefaultTypeInternal;
extern xclSlaveReadReq_responseDefaultTypeInternal _xclSlaveReadReq_response_default_instance_;
class xclSlaveWriteReq_call;
struct xclSlaveWriteReq_callDefaultTypeInternal;
extern xclSlaveWriteReq_callDefaultTypeInternal _xclSlaveWriteReq_call_default_instance_;
class xclSlaveWriteReq_response;
struct xclSlaveWriteReq_responseDefaultTypeInternal;
extern xclSlaveWriteReq_responseDefaultTypeInternal _xclSlaveWriteReq_response_default_instance_;
class xclWriteAddrKernelCtrl_call;
struct xclWriteAddrKernelCtrl_callDefaultTypeInternal;
extern xclWriteAddrKernelCtrl_callDefaultTypeInternal _xclWriteAddrKernelCtrl_call_default_instance_;
class xclWriteAddrKernelCtrl_call_kernelInfo;
struct xclWriteAddrKernelCtrl_call_kernelInfoDefaultTypeInternal;
extern xclWriteAddrKernelCtrl_call_kernelInfoDefaultTypeInternal _xclWriteAddrKernelCtrl_call_kernelInfo_default_instance_;
class xclWriteAddrKernelCtrl_response;
struct xclWriteAddrKernelCtrl_responseDefaultTypeInternal;
extern xclWriteAddrKernelCtrl_responseDefaultTypeInternal _xclWriteAddrKernelCtrl_response_default_instance_;
class xclWriteAddrSpaceDeviceRam_call;
struct xclWriteAddrSpaceDeviceRam_callDefaultTypeInternal;
extern xclWriteAddrSpaceDeviceRam_callDefaultTypeInternal _xclWriteAddrSpaceDeviceRam_call_default_instance_;
class xclWriteAddrSpaceDeviceRam_response;
struct xclWriteAddrSpaceDeviceRam_responseDefaultTypeInternal;
extern xclWriteAddrSpaceDeviceRam_responseDefaultTypeInternal _xclWriteAddrSpaceDeviceRam_response_default_instance_;
class xclWriteQueue_call;
struct xclWriteQueue_callDefaultTypeInternal;
extern xclWriteQueue_callDefaultTypeInternal _xclWriteQueue_call_default_instance_;
class xclWriteQueue_response;
struct xclWriteQueue_responseDefaultTypeInternal;
extern xclWriteQueue_responseDefaultTypeInternal _xclWriteQueue_response_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::call_packet_info* Arena::CreateMaybeMessage<::call_packet_info>(Arena*);
template<> ::ddr_mem_msg* Arena::CreateMaybeMessage<::ddr_mem_msg>(Arena*);
template<> ::response_packet_info* Arena::CreateMaybeMessage<::response_packet_info>(Arena*);
template<> ::xclAllocDeviceBuffer_call* Arena::CreateMaybeMessage<::xclAllocDeviceBuffer_call>(Arena*);
template<> ::xclAllocDeviceBuffer_response* Arena::CreateMaybeMessage<::xclAllocDeviceBuffer_response>(Arena*);
template<> ::xclClose_call* Arena::CreateMaybeMessage<::xclClose_call>(Arena*);
template<> ::xclClose_response* Arena::CreateMaybeMessage<::xclClose_response>(Arena*);
template<> ::xclCopyBO_call* Arena::CreateMaybeMessage<::xclCopyBO_call>(Arena*);
template<> ::xclCopyBO_response* Arena::CreateMaybeMessage<::xclCopyBO_response>(Arena*);
template<> ::xclCopyBufferDevice2Host_call* Arena::CreateMaybeMessage<::xclCopyBufferDevice2Host_call>(Arena*);
template<> ::xclCopyBufferDevice2Host_response* Arena::CreateMaybeMessage<::xclCopyBufferDevice2Host_response>(Arena*);
template<> ::xclCopyBufferHost2Device_call* Arena::CreateMaybeMessage<::xclCopyBufferHost2Device_call>(Arena*);
template<> ::xclCopyBufferHost2Device_response* Arena::CreateMaybeMessage<::xclCopyBufferHost2Device_response>(Arena*);
template<> ::xclCreateQueue_call* Arena::CreateMaybeMessage<::xclCreateQueue_call>(Arena*);
template<> ::xclCreateQueue_response* Arena::CreateMaybeMessage<::xclCreateQueue_response>(Arena*);
template<> ::xclDestroyQueue_call* Arena::CreateMaybeMessage<::xclDestroyQueue_call>(Arena*);
template<> ::xclDestroyQueue_response* Arena::CreateMaybeMessage<::xclDestroyQueue_response>(Arena*);
template<> ::xclFreeDeviceBuffer_call* Arena::CreateMaybeMessage<::xclFreeDeviceBuffer_call>(Arena*);
template<> ::xclFreeDeviceBuffer_response* Arena::CreateMaybeMessage<::xclFreeDeviceBuffer_response>(Arena*);
template<> ::xclGetDebugMessages_call* Arena::CreateMaybeMessage<::xclGetDebugMessages_call>(Arena*);
template<> ::xclGetDebugMessages_response* Arena::CreateMaybeMessage<::xclGetDebugMessages_response>(Arena*);
template<> ::xclGetDeviceTimestamp_call* Arena::CreateMaybeMessage<::xclGetDeviceTimestamp_call>(Arena*);
template<> ::xclGetDeviceTimestamp_response* Arena::CreateMaybeMessage<::xclGetDeviceTimestamp_response>(Arena*);
template<> ::xclImportBO_call* Arena::CreateMaybeMessage<::xclImportBO_call>(Arena*);
template<> ::xclImportBO_response* Arena::CreateMaybeMessage<::xclImportBO_response>(Arena*);
template<> ::xclInterruptOccured_call* Arena::CreateMaybeMessage<::xclInterruptOccured_call>(Arena*);
template<> ::xclInterruptOccured_response* Arena::CreateMaybeMessage<::xclInterruptOccured_response>(Arena*);
template<> ::xclLoadBitstream_call* Arena::CreateMaybeMessage<::xclLoadBitstream_call>(Arena*);
template<> ::xclLoadBitstream_call_ddrbank* Arena::CreateMaybeMessage<::xclLoadBitstream_call_ddrbank>(Arena*);
template<> ::xclLoadBitstream_response* Arena::CreateMaybeMessage<::xclLoadBitstream_response>(Arena*);
template<> ::xclPerfMonGetTraceCount_call* Arena::CreateMaybeMessage<::xclPerfMonGetTraceCount_call>(Arena*);
template<> ::xclPerfMonGetTraceCount_response* Arena::CreateMaybeMessage<::xclPerfMonGetTraceCount_response>(Arena*);
template<> ::xclPerfMonReadCounters_Streaming_call* Arena::CreateMaybeMessage<::xclPerfMonReadCounters_Streaming_call>(Arena*);
template<> ::xclPerfMonReadCounters_Streaming_response* Arena::CreateMaybeMessage<::xclPerfMonReadCounters_Streaming_response>(Arena*);
template<> ::xclPerfMonReadCounters_call* Arena::CreateMaybeMessage<::xclPerfMonReadCounters_call>(Arena*);
template<> ::xclPerfMonReadCounters_response* Arena::CreateMaybeMessage<::xclPerfMonReadCounters_response>(Arena*);
template<> ::xclPerfMonReadTrace_Streaming_call* Arena::CreateMaybeMessage<::xclPerfMonReadTrace_Streaming_call>(Arena*);
template<> ::xclPerfMonReadTrace_Streaming_response* Arena::CreateMaybeMessage<::xclPerfMonReadTrace_Streaming_response>(Arena*);
template<> ::xclPerfMonReadTrace_Streaming_response_events* Arena::CreateMaybeMessage<::xclPerfMonReadTrace_Streaming_response_events>(Arena*);
template<> ::xclPerfMonReadTrace_call* Arena::CreateMaybeMessage<::xclPerfMonReadTrace_call>(Arena*);
template<> ::xclPerfMonReadTrace_response* Arena::CreateMaybeMessage<::xclPerfMonReadTrace_response>(Arena*);
template<> ::xclPerfMonReadTrace_response_events* Arena::CreateMaybeMessage<::xclPerfMonReadTrace_response_events>(Arena*);
template<> ::xclPfBarAddrmap_call* Arena::CreateMaybeMessage<::xclPfBarAddrmap_call>(Arena*);
template<> ::xclPfBarAddrmap_response* Arena::CreateMaybeMessage<::xclPfBarAddrmap_response>(Arena*);
template<> ::xclPfBarAddrmap_response_PfBarmaps* Arena::CreateMaybeMessage<::xclPfBarAddrmap_response_PfBarmaps>(Arena*);
template<> ::xclPollCompletion_call* Arena::CreateMaybeMessage<::xclPollCompletion_call>(Arena*);
template<> ::xclPollCompletion_response* Arena::CreateMaybeMessage<::xclPollCompletion_response>(Arena*);
template<> ::xclPollCompletion_response_request* Arena::CreateMaybeMessage<::xclPollCompletion_response_request>(Arena*);
template<> ::xclReadAddrKernelCtrl_call* Arena::CreateMaybeMessage<::xclReadAddrKernelCtrl_call>(Arena*);
template<> ::xclReadAddrKernelCtrl_response* Arena::CreateMaybeMessage<::xclReadAddrKernelCtrl_response>(Arena*);
template<> ::xclReadAddrSpaceDeviceRam_call* Arena::CreateMaybeMessage<::xclReadAddrSpaceDeviceRam_call>(Arena*);
template<> ::xclReadAddrSpaceDeviceRam_response* Arena::CreateMaybeMessage<::xclReadAddrSpaceDeviceRam_response>(Arena*);
template<> ::xclReadBusStatus_call* Arena::CreateMaybeMessage<::xclReadBusStatus_call>(Arena*);
template<> ::xclReadBusStatus_response* Arena::CreateMaybeMessage<::xclReadBusStatus_response>(Arena*);
template<> ::xclReadQueue_call* Arena::CreateMaybeMessage<::xclReadQueue_call>(Arena*);
template<> ::xclReadQueue_response* Arena::CreateMaybeMessage<::xclReadQueue_response>(Arena*);
template<> ::xclSetEnvironment_call* Arena::CreateMaybeMessage<::xclSetEnvironment_call>(Arena*);
template<> ::xclSetEnvironment_call_namevaluepair* Arena::CreateMaybeMessage<::xclSetEnvironment_call_namevaluepair>(Arena*);
template<> ::xclSetEnvironment_response* Arena::CreateMaybeMessage<::xclSetEnvironment_response>(Arena*);
template<> ::xclSetupInstance_call* Arena::CreateMaybeMessage<::xclSetupInstance_call>(Arena*);
template<> ::xclSetupInstance_call_argflowpair* Arena::CreateMaybeMessage<::xclSetupInstance_call_argflowpair>(Arena*);
template<> ::xclSetupInstance_response* Arena::CreateMaybeMessage<::xclSetupInstance_response>(Arena*);
template<> ::xclSlaveReadReq_call* Arena::CreateMaybeMessage<::xclSlaveReadReq_call>(Arena*);
template<> ::xclSlaveReadReq_response* Arena::CreateMaybeMessage<::xclSlaveReadReq_response>(Arena*);
template<> ::xclSlaveWriteReq_call* Arena::CreateMaybeMessage<::xclSlaveWriteReq_call>(Arena*);
template<> ::xclSlaveWriteReq_response* Arena::CreateMaybeMessage<::xclSlaveWriteReq_response>(Arena*);
template<> ::xclWriteAddrKernelCtrl_call* Arena::CreateMaybeMessage<::xclWriteAddrKernelCtrl_call>(Arena*);
template<> ::xclWriteAddrKernelCtrl_call_kernelInfo* Arena::CreateMaybeMessage<::xclWriteAddrKernelCtrl_call_kernelInfo>(Arena*);
template<> ::xclWriteAddrKernelCtrl_response* Arena::CreateMaybeMessage<::xclWriteAddrKernelCtrl_response>(Arena*);
template<> ::xclWriteAddrSpaceDeviceRam_call* Arena::CreateMaybeMessage<::xclWriteAddrSpaceDeviceRam_call>(Arena*);
template<> ::xclWriteAddrSpaceDeviceRam_response* Arena::CreateMaybeMessage<::xclWriteAddrSpaceDeviceRam_response>(Arena*);
template<> ::xclWriteQueue_call* Arena::CreateMaybeMessage<::xclWriteQueue_call>(Arena*);
template<> ::xclWriteQueue_response* Arena::CreateMaybeMessage<::xclWriteQueue_response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class call_packet_info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:call_packet_info) */ {
 public:
  inline call_packet_info() : call_packet_info(nullptr) {}
  ~call_packet_info() override;
  explicit PROTOBUF_CONSTEXPR call_packet_info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  call_packet_info(const call_packet_info& from);
  call_packet_info(call_packet_info&& from) noexcept
    : call_packet_info() {
    *this = ::std::move(from);
  }

  inline call_packet_info& operator=(const call_packet_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline call_packet_info& operator=(call_packet_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const call_packet_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const call_packet_info* internal_default_instance() {
    return reinterpret_cast<const call_packet_info*>(
               &_call_packet_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(call_packet_info& a, call_packet_info& b) {
    a.Swap(&b);
  }
  inline void Swap(call_packet_info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(call_packet_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  call_packet_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<call_packet_info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const call_packet_info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const call_packet_info& from) {
    call_packet_info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(call_packet_info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "call_packet_info";
  }
  protected:
  explicit call_packet_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kXclApiFieldNumber = 2,
  };
  // required fixed64 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional fixed32 xcl_api = 2;
  bool has_xcl_api() const;
  private:
  bool _internal_has_xcl_api() const;
  public:
  void clear_xcl_api();
  uint32_t xcl_api() const;
  void set_xcl_api(uint32_t value);
  private:
  uint32_t _internal_xcl_api() const;
  void _internal_set_xcl_api(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:call_packet_info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t size_;
    uint32_t xcl_api_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class response_packet_info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:response_packet_info) */ {
 public:
  inline response_packet_info() : response_packet_info(nullptr) {}
  ~response_packet_info() override;
  explicit PROTOBUF_CONSTEXPR response_packet_info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  response_packet_info(const response_packet_info& from);
  response_packet_info(response_packet_info&& from) noexcept
    : response_packet_info() {
    *this = ::std::move(from);
  }

  inline response_packet_info& operator=(const response_packet_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline response_packet_info& operator=(response_packet_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const response_packet_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const response_packet_info* internal_default_instance() {
    return reinterpret_cast<const response_packet_info*>(
               &_response_packet_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(response_packet_info& a, response_packet_info& b) {
    a.Swap(&b);
  }
  inline void Swap(response_packet_info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(response_packet_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  response_packet_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<response_packet_info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const response_packet_info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const response_packet_info& from) {
    response_packet_info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(response_packet_info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "response_packet_info";
  }
  protected:
  explicit response_packet_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kXclApiFieldNumber = 2,
  };
  // required fixed64 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional fixed32 xcl_api = 2;
  bool has_xcl_api() const;
  private:
  bool _internal_has_xcl_api() const;
  public:
  void clear_xcl_api();
  uint32_t xcl_api() const;
  void set_xcl_api(uint32_t value);
  private:
  uint32_t _internal_xcl_api() const;
  void _internal_set_xcl_api(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:response_packet_info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t size_;
    uint32_t xcl_api_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSetEnvironment_call_namevaluepair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSetEnvironment_call.namevaluepair) */ {
 public:
  inline xclSetEnvironment_call_namevaluepair() : xclSetEnvironment_call_namevaluepair(nullptr) {}
  ~xclSetEnvironment_call_namevaluepair() override;
  explicit PROTOBUF_CONSTEXPR xclSetEnvironment_call_namevaluepair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSetEnvironment_call_namevaluepair(const xclSetEnvironment_call_namevaluepair& from);
  xclSetEnvironment_call_namevaluepair(xclSetEnvironment_call_namevaluepair&& from) noexcept
    : xclSetEnvironment_call_namevaluepair() {
    *this = ::std::move(from);
  }

  inline xclSetEnvironment_call_namevaluepair& operator=(const xclSetEnvironment_call_namevaluepair& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSetEnvironment_call_namevaluepair& operator=(xclSetEnvironment_call_namevaluepair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSetEnvironment_call_namevaluepair& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSetEnvironment_call_namevaluepair* internal_default_instance() {
    return reinterpret_cast<const xclSetEnvironment_call_namevaluepair*>(
               &_xclSetEnvironment_call_namevaluepair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(xclSetEnvironment_call_namevaluepair& a, xclSetEnvironment_call_namevaluepair& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSetEnvironment_call_namevaluepair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSetEnvironment_call_namevaluepair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSetEnvironment_call_namevaluepair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSetEnvironment_call_namevaluepair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSetEnvironment_call_namevaluepair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSetEnvironment_call_namevaluepair& from) {
    xclSetEnvironment_call_namevaluepair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSetEnvironment_call_namevaluepair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSetEnvironment_call.namevaluepair";
  }
  protected:
  explicit xclSetEnvironment_call_namevaluepair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:xclSetEnvironment_call.namevaluepair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSetEnvironment_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSetEnvironment_call) */ {
 public:
  inline xclSetEnvironment_call() : xclSetEnvironment_call(nullptr) {}
  ~xclSetEnvironment_call() override;
  explicit PROTOBUF_CONSTEXPR xclSetEnvironment_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSetEnvironment_call(const xclSetEnvironment_call& from);
  xclSetEnvironment_call(xclSetEnvironment_call&& from) noexcept
    : xclSetEnvironment_call() {
    *this = ::std::move(from);
  }

  inline xclSetEnvironment_call& operator=(const xclSetEnvironment_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSetEnvironment_call& operator=(xclSetEnvironment_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSetEnvironment_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSetEnvironment_call* internal_default_instance() {
    return reinterpret_cast<const xclSetEnvironment_call*>(
               &_xclSetEnvironment_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(xclSetEnvironment_call& a, xclSetEnvironment_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSetEnvironment_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSetEnvironment_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSetEnvironment_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSetEnvironment_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSetEnvironment_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSetEnvironment_call& from) {
    xclSetEnvironment_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSetEnvironment_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSetEnvironment_call";
  }
  protected:
  explicit xclSetEnvironment_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclSetEnvironment_call_namevaluepair namevaluepair;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvironmentFieldNumber = 3,
  };
  // repeated .xclSetEnvironment_call.namevaluepair environment = 3;
  int environment_size() const;
  private:
  int _internal_environment_size() const;
  public:
  void clear_environment();
  ::xclSetEnvironment_call_namevaluepair* mutable_environment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetEnvironment_call_namevaluepair >*
      mutable_environment();
  private:
  const ::xclSetEnvironment_call_namevaluepair& _internal_environment(int index) const;
  ::xclSetEnvironment_call_namevaluepair* _internal_add_environment();
  public:
  const ::xclSetEnvironment_call_namevaluepair& environment(int index) const;
  ::xclSetEnvironment_call_namevaluepair* add_environment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetEnvironment_call_namevaluepair >&
      environment() const;

  // @@protoc_insertion_point(class_scope:xclSetEnvironment_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetEnvironment_call_namevaluepair > environment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSetEnvironment_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSetEnvironment_response) */ {
 public:
  inline xclSetEnvironment_response() : xclSetEnvironment_response(nullptr) {}
  ~xclSetEnvironment_response() override;
  explicit PROTOBUF_CONSTEXPR xclSetEnvironment_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSetEnvironment_response(const xclSetEnvironment_response& from);
  xclSetEnvironment_response(xclSetEnvironment_response&& from) noexcept
    : xclSetEnvironment_response() {
    *this = ::std::move(from);
  }

  inline xclSetEnvironment_response& operator=(const xclSetEnvironment_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSetEnvironment_response& operator=(xclSetEnvironment_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSetEnvironment_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSetEnvironment_response* internal_default_instance() {
    return reinterpret_cast<const xclSetEnvironment_response*>(
               &_xclSetEnvironment_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(xclSetEnvironment_response& a, xclSetEnvironment_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSetEnvironment_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSetEnvironment_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSetEnvironment_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSetEnvironment_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSetEnvironment_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSetEnvironment_response& from) {
    xclSetEnvironment_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSetEnvironment_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSetEnvironment_response";
  }
  protected:
  explicit xclSetEnvironment_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclSetEnvironment_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclLoadBitstream_call_ddrbank final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclLoadBitstream_call.ddrbank) */ {
 public:
  inline xclLoadBitstream_call_ddrbank() : xclLoadBitstream_call_ddrbank(nullptr) {}
  ~xclLoadBitstream_call_ddrbank() override;
  explicit PROTOBUF_CONSTEXPR xclLoadBitstream_call_ddrbank(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclLoadBitstream_call_ddrbank(const xclLoadBitstream_call_ddrbank& from);
  xclLoadBitstream_call_ddrbank(xclLoadBitstream_call_ddrbank&& from) noexcept
    : xclLoadBitstream_call_ddrbank() {
    *this = ::std::move(from);
  }

  inline xclLoadBitstream_call_ddrbank& operator=(const xclLoadBitstream_call_ddrbank& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclLoadBitstream_call_ddrbank& operator=(xclLoadBitstream_call_ddrbank&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclLoadBitstream_call_ddrbank& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclLoadBitstream_call_ddrbank* internal_default_instance() {
    return reinterpret_cast<const xclLoadBitstream_call_ddrbank*>(
               &_xclLoadBitstream_call_ddrbank_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(xclLoadBitstream_call_ddrbank& a, xclLoadBitstream_call_ddrbank& b) {
    a.Swap(&b);
  }
  inline void Swap(xclLoadBitstream_call_ddrbank* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclLoadBitstream_call_ddrbank* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclLoadBitstream_call_ddrbank* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclLoadBitstream_call_ddrbank>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclLoadBitstream_call_ddrbank& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclLoadBitstream_call_ddrbank& from) {
    xclLoadBitstream_call_ddrbank::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclLoadBitstream_call_ddrbank* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclLoadBitstream_call.ddrbank";
  }
  protected:
  explicit xclLoadBitstream_call_ddrbank(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 7,
  };
  // optional uint64 size = 7;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclLoadBitstream_call.ddrbank)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclLoadBitstream_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclLoadBitstream_call) */ {
 public:
  inline xclLoadBitstream_call() : xclLoadBitstream_call(nullptr) {}
  ~xclLoadBitstream_call() override;
  explicit PROTOBUF_CONSTEXPR xclLoadBitstream_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclLoadBitstream_call(const xclLoadBitstream_call& from);
  xclLoadBitstream_call(xclLoadBitstream_call&& from) noexcept
    : xclLoadBitstream_call() {
    *this = ::std::move(from);
  }

  inline xclLoadBitstream_call& operator=(const xclLoadBitstream_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclLoadBitstream_call& operator=(xclLoadBitstream_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclLoadBitstream_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclLoadBitstream_call* internal_default_instance() {
    return reinterpret_cast<const xclLoadBitstream_call*>(
               &_xclLoadBitstream_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(xclLoadBitstream_call& a, xclLoadBitstream_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclLoadBitstream_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclLoadBitstream_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclLoadBitstream_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclLoadBitstream_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclLoadBitstream_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclLoadBitstream_call& from) {
    xclLoadBitstream_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclLoadBitstream_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclLoadBitstream_call";
  }
  protected:
  explicit xclLoadBitstream_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclLoadBitstream_call_ddrbank ddrbank;

  // accessors -------------------------------------------------------

  enum : int {
    kDdrbanksFieldNumber = 8,
    kXmlfileFieldNumber = 1,
    kDlopenfilenameFieldNumber = 2,
    kDevicenameFieldNumber = 3,
    kDevicedirectoryFieldNumber = 4,
    kBinarydirectoryFieldNumber = 5,
    kVerboseFieldNumber = 6,
  };
  // repeated .xclLoadBitstream_call.ddrbank ddrbanks = 8;
  int ddrbanks_size() const;
  private:
  int _internal_ddrbanks_size() const;
  public:
  void clear_ddrbanks();
  ::xclLoadBitstream_call_ddrbank* mutable_ddrbanks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclLoadBitstream_call_ddrbank >*
      mutable_ddrbanks();
  private:
  const ::xclLoadBitstream_call_ddrbank& _internal_ddrbanks(int index) const;
  ::xclLoadBitstream_call_ddrbank* _internal_add_ddrbanks();
  public:
  const ::xclLoadBitstream_call_ddrbank& ddrbanks(int index) const;
  ::xclLoadBitstream_call_ddrbank* add_ddrbanks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclLoadBitstream_call_ddrbank >&
      ddrbanks() const;

  // required bytes xmlfile = 1;
  bool has_xmlfile() const;
  private:
  bool _internal_has_xmlfile() const;
  public:
  void clear_xmlfile();
  const std::string& xmlfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xmlfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xmlfile();
  PROTOBUF_NODISCARD std::string* release_xmlfile();
  void set_allocated_xmlfile(std::string* xmlfile);
  private:
  const std::string& _internal_xmlfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xmlfile(const std::string& value);
  std::string* _internal_mutable_xmlfile();
  public:

  // required bytes dlopenfilename = 2;
  bool has_dlopenfilename() const;
  private:
  bool _internal_has_dlopenfilename() const;
  public:
  void clear_dlopenfilename();
  const std::string& dlopenfilename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dlopenfilename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dlopenfilename();
  PROTOBUF_NODISCARD std::string* release_dlopenfilename();
  void set_allocated_dlopenfilename(std::string* dlopenfilename);
  private:
  const std::string& _internal_dlopenfilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dlopenfilename(const std::string& value);
  std::string* _internal_mutable_dlopenfilename();
  public:

  // required bytes devicename = 3;
  bool has_devicename() const;
  private:
  bool _internal_has_devicename() const;
  public:
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_NODISCARD std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // required bytes devicedirectory = 4;
  bool has_devicedirectory() const;
  private:
  bool _internal_has_devicedirectory() const;
  public:
  void clear_devicedirectory();
  const std::string& devicedirectory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicedirectory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicedirectory();
  PROTOBUF_NODISCARD std::string* release_devicedirectory();
  void set_allocated_devicedirectory(std::string* devicedirectory);
  private:
  const std::string& _internal_devicedirectory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicedirectory(const std::string& value);
  std::string* _internal_mutable_devicedirectory();
  public:

  // required bytes binarydirectory = 5;
  bool has_binarydirectory() const;
  private:
  bool _internal_has_binarydirectory() const;
  public:
  void clear_binarydirectory();
  const std::string& binarydirectory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binarydirectory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binarydirectory();
  PROTOBUF_NODISCARD std::string* release_binarydirectory();
  void set_allocated_binarydirectory(std::string* binarydirectory);
  private:
  const std::string& _internal_binarydirectory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binarydirectory(const std::string& value);
  std::string* _internal_mutable_binarydirectory();
  public:

  // required bool verbose = 6;
  bool has_verbose() const;
  private:
  bool _internal_has_verbose() const;
  public:
  void clear_verbose();
  bool verbose() const;
  void set_verbose(bool value);
  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclLoadBitstream_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclLoadBitstream_call_ddrbank > ddrbanks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xmlfile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dlopenfilename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicedirectory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binarydirectory_;
    bool verbose_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclLoadBitstream_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclLoadBitstream_response) */ {
 public:
  inline xclLoadBitstream_response() : xclLoadBitstream_response(nullptr) {}
  ~xclLoadBitstream_response() override;
  explicit PROTOBUF_CONSTEXPR xclLoadBitstream_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclLoadBitstream_response(const xclLoadBitstream_response& from);
  xclLoadBitstream_response(xclLoadBitstream_response&& from) noexcept
    : xclLoadBitstream_response() {
    *this = ::std::move(from);
  }

  inline xclLoadBitstream_response& operator=(const xclLoadBitstream_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclLoadBitstream_response& operator=(xclLoadBitstream_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclLoadBitstream_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclLoadBitstream_response* internal_default_instance() {
    return reinterpret_cast<const xclLoadBitstream_response*>(
               &_xclLoadBitstream_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(xclLoadBitstream_response& a, xclLoadBitstream_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclLoadBitstream_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclLoadBitstream_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclLoadBitstream_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclLoadBitstream_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclLoadBitstream_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclLoadBitstream_response& from) {
    xclLoadBitstream_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclLoadBitstream_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclLoadBitstream_response";
  }
  protected:
  explicit xclLoadBitstream_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // required bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclLoadBitstream_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclAllocDeviceBuffer_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclAllocDeviceBuffer_call) */ {
 public:
  inline xclAllocDeviceBuffer_call() : xclAllocDeviceBuffer_call(nullptr) {}
  ~xclAllocDeviceBuffer_call() override;
  explicit PROTOBUF_CONSTEXPR xclAllocDeviceBuffer_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclAllocDeviceBuffer_call(const xclAllocDeviceBuffer_call& from);
  xclAllocDeviceBuffer_call(xclAllocDeviceBuffer_call&& from) noexcept
    : xclAllocDeviceBuffer_call() {
    *this = ::std::move(from);
  }

  inline xclAllocDeviceBuffer_call& operator=(const xclAllocDeviceBuffer_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclAllocDeviceBuffer_call& operator=(xclAllocDeviceBuffer_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclAllocDeviceBuffer_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclAllocDeviceBuffer_call* internal_default_instance() {
    return reinterpret_cast<const xclAllocDeviceBuffer_call*>(
               &_xclAllocDeviceBuffer_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(xclAllocDeviceBuffer_call& a, xclAllocDeviceBuffer_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclAllocDeviceBuffer_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclAllocDeviceBuffer_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclAllocDeviceBuffer_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclAllocDeviceBuffer_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclAllocDeviceBuffer_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclAllocDeviceBuffer_call& from) {
    xclAllocDeviceBuffer_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclAllocDeviceBuffer_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclAllocDeviceBuffer_call";
  }
  protected:
  explicit xclAllocDeviceBuffer_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDdraddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kPeertopeerFieldNumber = 3,
  };
  // required uint64 ddraddress = 1;
  bool has_ddraddress() const;
  private:
  bool _internal_has_ddraddress() const;
  public:
  void clear_ddraddress();
  uint64_t ddraddress() const;
  void set_ddraddress(uint64_t value);
  private:
  uint64_t _internal_ddraddress() const;
  void _internal_set_ddraddress(uint64_t value);
  public:

  // required uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional bool peertopeer = 3;
  bool has_peertopeer() const;
  private:
  bool _internal_has_peertopeer() const;
  public:
  void clear_peertopeer();
  bool peertopeer() const;
  void set_peertopeer(bool value);
  private:
  bool _internal_peertopeer() const;
  void _internal_set_peertopeer(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclAllocDeviceBuffer_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t ddraddress_;
    uint64_t size_;
    bool peertopeer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclAllocDeviceBuffer_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclAllocDeviceBuffer_response) */ {
 public:
  inline xclAllocDeviceBuffer_response() : xclAllocDeviceBuffer_response(nullptr) {}
  ~xclAllocDeviceBuffer_response() override;
  explicit PROTOBUF_CONSTEXPR xclAllocDeviceBuffer_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclAllocDeviceBuffer_response(const xclAllocDeviceBuffer_response& from);
  xclAllocDeviceBuffer_response(xclAllocDeviceBuffer_response&& from) noexcept
    : xclAllocDeviceBuffer_response() {
    *this = ::std::move(from);
  }

  inline xclAllocDeviceBuffer_response& operator=(const xclAllocDeviceBuffer_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclAllocDeviceBuffer_response& operator=(xclAllocDeviceBuffer_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclAllocDeviceBuffer_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclAllocDeviceBuffer_response* internal_default_instance() {
    return reinterpret_cast<const xclAllocDeviceBuffer_response*>(
               &_xclAllocDeviceBuffer_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(xclAllocDeviceBuffer_response& a, xclAllocDeviceBuffer_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclAllocDeviceBuffer_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclAllocDeviceBuffer_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclAllocDeviceBuffer_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclAllocDeviceBuffer_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclAllocDeviceBuffer_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclAllocDeviceBuffer_response& from) {
    xclAllocDeviceBuffer_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclAllocDeviceBuffer_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclAllocDeviceBuffer_response";
  }
  protected:
  explicit xclAllocDeviceBuffer_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 2,
    kAckFieldNumber = 1,
  };
  // optional string filename = 2;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // required bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclAllocDeviceBuffer_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclFreeDeviceBuffer_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclFreeDeviceBuffer_call) */ {
 public:
  inline xclFreeDeviceBuffer_call() : xclFreeDeviceBuffer_call(nullptr) {}
  ~xclFreeDeviceBuffer_call() override;
  explicit PROTOBUF_CONSTEXPR xclFreeDeviceBuffer_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclFreeDeviceBuffer_call(const xclFreeDeviceBuffer_call& from);
  xclFreeDeviceBuffer_call(xclFreeDeviceBuffer_call&& from) noexcept
    : xclFreeDeviceBuffer_call() {
    *this = ::std::move(from);
  }

  inline xclFreeDeviceBuffer_call& operator=(const xclFreeDeviceBuffer_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclFreeDeviceBuffer_call& operator=(xclFreeDeviceBuffer_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclFreeDeviceBuffer_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclFreeDeviceBuffer_call* internal_default_instance() {
    return reinterpret_cast<const xclFreeDeviceBuffer_call*>(
               &_xclFreeDeviceBuffer_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(xclFreeDeviceBuffer_call& a, xclFreeDeviceBuffer_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclFreeDeviceBuffer_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclFreeDeviceBuffer_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclFreeDeviceBuffer_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclFreeDeviceBuffer_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclFreeDeviceBuffer_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclFreeDeviceBuffer_call& from) {
    xclFreeDeviceBuffer_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclFreeDeviceBuffer_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclFreeDeviceBuffer_call";
  }
  protected:
  explicit xclFreeDeviceBuffer_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDdraddressFieldNumber = 1,
  };
  // required uint64 ddraddress = 1;
  bool has_ddraddress() const;
  private:
  bool _internal_has_ddraddress() const;
  public:
  void clear_ddraddress();
  uint64_t ddraddress() const;
  void set_ddraddress(uint64_t value);
  private:
  uint64_t _internal_ddraddress() const;
  void _internal_set_ddraddress(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclFreeDeviceBuffer_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t ddraddress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclFreeDeviceBuffer_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclFreeDeviceBuffer_response) */ {
 public:
  inline xclFreeDeviceBuffer_response() : xclFreeDeviceBuffer_response(nullptr) {}
  ~xclFreeDeviceBuffer_response() override;
  explicit PROTOBUF_CONSTEXPR xclFreeDeviceBuffer_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclFreeDeviceBuffer_response(const xclFreeDeviceBuffer_response& from);
  xclFreeDeviceBuffer_response(xclFreeDeviceBuffer_response&& from) noexcept
    : xclFreeDeviceBuffer_response() {
    *this = ::std::move(from);
  }

  inline xclFreeDeviceBuffer_response& operator=(const xclFreeDeviceBuffer_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclFreeDeviceBuffer_response& operator=(xclFreeDeviceBuffer_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclFreeDeviceBuffer_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclFreeDeviceBuffer_response* internal_default_instance() {
    return reinterpret_cast<const xclFreeDeviceBuffer_response*>(
               &_xclFreeDeviceBuffer_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(xclFreeDeviceBuffer_response& a, xclFreeDeviceBuffer_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclFreeDeviceBuffer_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclFreeDeviceBuffer_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclFreeDeviceBuffer_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclFreeDeviceBuffer_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclFreeDeviceBuffer_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclFreeDeviceBuffer_response& from) {
    xclFreeDeviceBuffer_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclFreeDeviceBuffer_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclFreeDeviceBuffer_response";
  }
  protected:
  explicit xclFreeDeviceBuffer_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // required bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclFreeDeviceBuffer_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclClose_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclClose_call) */ {
 public:
  inline xclClose_call() : xclClose_call(nullptr) {}
  ~xclClose_call() override;
  explicit PROTOBUF_CONSTEXPR xclClose_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclClose_call(const xclClose_call& from);
  xclClose_call(xclClose_call&& from) noexcept
    : xclClose_call() {
    *this = ::std::move(from);
  }

  inline xclClose_call& operator=(const xclClose_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclClose_call& operator=(xclClose_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclClose_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclClose_call* internal_default_instance() {
    return reinterpret_cast<const xclClose_call*>(
               &_xclClose_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(xclClose_call& a, xclClose_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclClose_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclClose_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclClose_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclClose_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclClose_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclClose_call& from) {
    xclClose_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclClose_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclClose_call";
  }
  protected:
  explicit xclClose_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXclDeviceHandleFieldNumber = 2,
    kCloseallFieldNumber = 3,
  };
  // optional bytes xclDeviceHandle = 2;
  bool has_xcldevicehandle() const;
  private:
  bool _internal_has_xcldevicehandle() const;
  public:
  void clear_xcldevicehandle();
  const std::string& xcldevicehandle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xcldevicehandle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xcldevicehandle();
  PROTOBUF_NODISCARD std::string* release_xcldevicehandle();
  void set_allocated_xcldevicehandle(std::string* xcldevicehandle);
  private:
  const std::string& _internal_xcldevicehandle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xcldevicehandle(const std::string& value);
  std::string* _internal_mutable_xcldevicehandle();
  public:

  // optional bool closeall = 3;
  bool has_closeall() const;
  private:
  bool _internal_has_closeall() const;
  public:
  void clear_closeall();
  bool closeall() const;
  void set_closeall(bool value);
  private:
  bool _internal_closeall() const;
  void _internal_set_closeall(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclClose_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xcldevicehandle_;
    bool closeall_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclClose_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclClose_response) */ {
 public:
  inline xclClose_response() : xclClose_response(nullptr) {}
  ~xclClose_response() override;
  explicit PROTOBUF_CONSTEXPR xclClose_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclClose_response(const xclClose_response& from);
  xclClose_response(xclClose_response&& from) noexcept
    : xclClose_response() {
    *this = ::std::move(from);
  }

  inline xclClose_response& operator=(const xclClose_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclClose_response& operator=(xclClose_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclClose_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclClose_response* internal_default_instance() {
    return reinterpret_cast<const xclClose_response*>(
               &_xclClose_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(xclClose_response& a, xclClose_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclClose_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclClose_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclClose_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclClose_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclClose_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclClose_response& from) {
    xclClose_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclClose_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclClose_response";
  }
  protected:
  explicit xclClose_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclClose_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCopyBufferHost2Device_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCopyBufferHost2Device_call) */ {
 public:
  inline xclCopyBufferHost2Device_call() : xclCopyBufferHost2Device_call(nullptr) {}
  ~xclCopyBufferHost2Device_call() override;
  explicit PROTOBUF_CONSTEXPR xclCopyBufferHost2Device_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCopyBufferHost2Device_call(const xclCopyBufferHost2Device_call& from);
  xclCopyBufferHost2Device_call(xclCopyBufferHost2Device_call&& from) noexcept
    : xclCopyBufferHost2Device_call() {
    *this = ::std::move(from);
  }

  inline xclCopyBufferHost2Device_call& operator=(const xclCopyBufferHost2Device_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCopyBufferHost2Device_call& operator=(xclCopyBufferHost2Device_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCopyBufferHost2Device_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCopyBufferHost2Device_call* internal_default_instance() {
    return reinterpret_cast<const xclCopyBufferHost2Device_call*>(
               &_xclCopyBufferHost2Device_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(xclCopyBufferHost2Device_call& a, xclCopyBufferHost2Device_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCopyBufferHost2Device_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCopyBufferHost2Device_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCopyBufferHost2Device_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCopyBufferHost2Device_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCopyBufferHost2Device_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCopyBufferHost2Device_call& from) {
    xclCopyBufferHost2Device_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCopyBufferHost2Device_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCopyBufferHost2Device_call";
  }
  protected:
  explicit xclCopyBufferHost2Device_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXclDeviceHandleFieldNumber = 2,
    kSrcFieldNumber = 4,
    kDestFieldNumber = 3,
    kSizeFieldNumber = 5,
    kSeekFieldNumber = 6,
    kSpaceFieldNumber = 7,
  };
  // required bytes xclDeviceHandle = 2;
  bool has_xcldevicehandle() const;
  private:
  bool _internal_has_xcldevicehandle() const;
  public:
  void clear_xcldevicehandle();
  const std::string& xcldevicehandle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xcldevicehandle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xcldevicehandle();
  PROTOBUF_NODISCARD std::string* release_xcldevicehandle();
  void set_allocated_xcldevicehandle(std::string* xcldevicehandle);
  private:
  const std::string& _internal_xcldevicehandle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xcldevicehandle(const std::string& value);
  std::string* _internal_mutable_xcldevicehandle();
  public:

  // required bytes src = 4;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // required uint64 dest = 3;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  uint64_t dest() const;
  void set_dest(uint64_t value);
  private:
  uint64_t _internal_dest() const;
  void _internal_set_dest(uint64_t value);
  public:

  // required uint64 size = 5;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // required uint64 seek = 6;
  bool has_seek() const;
  private:
  bool _internal_has_seek() const;
  public:
  void clear_seek();
  uint64_t seek() const;
  void set_seek(uint64_t value);
  private:
  uint64_t _internal_seek() const;
  void _internal_set_seek(uint64_t value);
  public:

  // optional uint32 space = 7;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  uint32_t space() const;
  void set_space(uint32_t value);
  private:
  uint32_t _internal_space() const;
  void _internal_set_space(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCopyBufferHost2Device_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xcldevicehandle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    uint64_t dest_;
    uint64_t size_;
    uint64_t seek_;
    uint32_t space_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCopyBufferHost2Device_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCopyBufferHost2Device_response) */ {
 public:
  inline xclCopyBufferHost2Device_response() : xclCopyBufferHost2Device_response(nullptr) {}
  ~xclCopyBufferHost2Device_response() override;
  explicit PROTOBUF_CONSTEXPR xclCopyBufferHost2Device_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCopyBufferHost2Device_response(const xclCopyBufferHost2Device_response& from);
  xclCopyBufferHost2Device_response(xclCopyBufferHost2Device_response&& from) noexcept
    : xclCopyBufferHost2Device_response() {
    *this = ::std::move(from);
  }

  inline xclCopyBufferHost2Device_response& operator=(const xclCopyBufferHost2Device_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCopyBufferHost2Device_response& operator=(xclCopyBufferHost2Device_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCopyBufferHost2Device_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCopyBufferHost2Device_response* internal_default_instance() {
    return reinterpret_cast<const xclCopyBufferHost2Device_response*>(
               &_xclCopyBufferHost2Device_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(xclCopyBufferHost2Device_response& a, xclCopyBufferHost2Device_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCopyBufferHost2Device_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCopyBufferHost2Device_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCopyBufferHost2Device_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCopyBufferHost2Device_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCopyBufferHost2Device_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCopyBufferHost2Device_response& from) {
    xclCopyBufferHost2Device_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCopyBufferHost2Device_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCopyBufferHost2Device_response";
  }
  protected:
  explicit xclCopyBufferHost2Device_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // required uint64 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCopyBufferHost2Device_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCopyBufferDevice2Host_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCopyBufferDevice2Host_call) */ {
 public:
  inline xclCopyBufferDevice2Host_call() : xclCopyBufferDevice2Host_call(nullptr) {}
  ~xclCopyBufferDevice2Host_call() override;
  explicit PROTOBUF_CONSTEXPR xclCopyBufferDevice2Host_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCopyBufferDevice2Host_call(const xclCopyBufferDevice2Host_call& from);
  xclCopyBufferDevice2Host_call(xclCopyBufferDevice2Host_call&& from) noexcept
    : xclCopyBufferDevice2Host_call() {
    *this = ::std::move(from);
  }

  inline xclCopyBufferDevice2Host_call& operator=(const xclCopyBufferDevice2Host_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCopyBufferDevice2Host_call& operator=(xclCopyBufferDevice2Host_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCopyBufferDevice2Host_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCopyBufferDevice2Host_call* internal_default_instance() {
    return reinterpret_cast<const xclCopyBufferDevice2Host_call*>(
               &_xclCopyBufferDevice2Host_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(xclCopyBufferDevice2Host_call& a, xclCopyBufferDevice2Host_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCopyBufferDevice2Host_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCopyBufferDevice2Host_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCopyBufferDevice2Host_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCopyBufferDevice2Host_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCopyBufferDevice2Host_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCopyBufferDevice2Host_call& from) {
    xclCopyBufferDevice2Host_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCopyBufferDevice2Host_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCopyBufferDevice2Host_call";
  }
  protected:
  explicit xclCopyBufferDevice2Host_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXclDeviceHandleFieldNumber = 2,
    kDestFieldNumber = 3,
    kSrcFieldNumber = 4,
    kSizeFieldNumber = 5,
    kSkipFieldNumber = 6,
    kSpaceFieldNumber = 7,
  };
  // required bytes xclDeviceHandle = 2;
  bool has_xcldevicehandle() const;
  private:
  bool _internal_has_xcldevicehandle() const;
  public:
  void clear_xcldevicehandle();
  const std::string& xcldevicehandle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xcldevicehandle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xcldevicehandle();
  PROTOBUF_NODISCARD std::string* release_xcldevicehandle();
  void set_allocated_xcldevicehandle(std::string* xcldevicehandle);
  private:
  const std::string& _internal_xcldevicehandle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xcldevicehandle(const std::string& value);
  std::string* _internal_mutable_xcldevicehandle();
  public:

  // required bytes dest = 3;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const std::string& dest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // required uint64 src = 4;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  uint64_t src() const;
  void set_src(uint64_t value);
  private:
  uint64_t _internal_src() const;
  void _internal_set_src(uint64_t value);
  public:

  // required uint64 size = 5;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // required uint64 skip = 6;
  bool has_skip() const;
  private:
  bool _internal_has_skip() const;
  public:
  void clear_skip();
  uint64_t skip() const;
  void set_skip(uint64_t value);
  private:
  uint64_t _internal_skip() const;
  void _internal_set_skip(uint64_t value);
  public:

  // optional uint32 space = 7;
  bool has_space() const;
  private:
  bool _internal_has_space() const;
  public:
  void clear_space();
  uint32_t space() const;
  void set_space(uint32_t value);
  private:
  uint32_t _internal_space() const;
  void _internal_set_space(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCopyBufferDevice2Host_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xcldevicehandle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
    uint64_t src_;
    uint64_t size_;
    uint64_t skip_;
    uint32_t space_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCopyBufferDevice2Host_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCopyBufferDevice2Host_response) */ {
 public:
  inline xclCopyBufferDevice2Host_response() : xclCopyBufferDevice2Host_response(nullptr) {}
  ~xclCopyBufferDevice2Host_response() override;
  explicit PROTOBUF_CONSTEXPR xclCopyBufferDevice2Host_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCopyBufferDevice2Host_response(const xclCopyBufferDevice2Host_response& from);
  xclCopyBufferDevice2Host_response(xclCopyBufferDevice2Host_response&& from) noexcept
    : xclCopyBufferDevice2Host_response() {
    *this = ::std::move(from);
  }

  inline xclCopyBufferDevice2Host_response& operator=(const xclCopyBufferDevice2Host_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCopyBufferDevice2Host_response& operator=(xclCopyBufferDevice2Host_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCopyBufferDevice2Host_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCopyBufferDevice2Host_response* internal_default_instance() {
    return reinterpret_cast<const xclCopyBufferDevice2Host_response*>(
               &_xclCopyBufferDevice2Host_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(xclCopyBufferDevice2Host_response& a, xclCopyBufferDevice2Host_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCopyBufferDevice2Host_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCopyBufferDevice2Host_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCopyBufferDevice2Host_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCopyBufferDevice2Host_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCopyBufferDevice2Host_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCopyBufferDevice2Host_response& from) {
    xclCopyBufferDevice2Host_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCopyBufferDevice2Host_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCopyBufferDevice2Host_response";
  }
  protected:
  explicit xclCopyBufferDevice2Host_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // required bytes dest = 2;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const std::string& dest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // required uint64 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCopyBufferDevice2Host_response)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteAddrSpaceDeviceRam_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteAddrSpaceDeviceRam_call) */ {
 public:
  inline xclWriteAddrSpaceDeviceRam_call() : xclWriteAddrSpaceDeviceRam_call(nullptr) {}
  ~xclWriteAddrSpaceDeviceRam_call() override;
  explicit PROTOBUF_CONSTEXPR xclWriteAddrSpaceDeviceRam_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteAddrSpaceDeviceRam_call(const xclWriteAddrSpaceDeviceRam_call& from);
  xclWriteAddrSpaceDeviceRam_call(xclWriteAddrSpaceDeviceRam_call&& from) noexcept
    : xclWriteAddrSpaceDeviceRam_call() {
    *this = ::std::move(from);
  }

  inline xclWriteAddrSpaceDeviceRam_call& operator=(const xclWriteAddrSpaceDeviceRam_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteAddrSpaceDeviceRam_call& operator=(xclWriteAddrSpaceDeviceRam_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteAddrSpaceDeviceRam_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteAddrSpaceDeviceRam_call* internal_default_instance() {
    return reinterpret_cast<const xclWriteAddrSpaceDeviceRam_call*>(
               &_xclWriteAddrSpaceDeviceRam_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(xclWriteAddrSpaceDeviceRam_call& a, xclWriteAddrSpaceDeviceRam_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteAddrSpaceDeviceRam_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteAddrSpaceDeviceRam_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteAddrSpaceDeviceRam_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteAddrSpaceDeviceRam_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteAddrSpaceDeviceRam_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteAddrSpaceDeviceRam_call& from) {
    xclWriteAddrSpaceDeviceRam_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteAddrSpaceDeviceRam_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteAddrSpaceDeviceRam_call";
  }
  protected:
  explicit xclWriteAddrSpaceDeviceRam_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kAddrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kPFIDFieldNumber = 5,
    kBARIDFieldNumber = 6,
  };
  // required bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint64 addr = 2;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional uint32 PF_ID = 5;
  bool has_pf_id() const;
  private:
  bool _internal_has_pf_id() const;
  public:
  void clear_pf_id();
  uint32_t pf_id() const;
  void set_pf_id(uint32_t value);
  private:
  uint32_t _internal_pf_id() const;
  void _internal_set_pf_id(uint32_t value);
  public:

  // optional uint32 BAR_ID = 6;
  bool has_bar_id() const;
  private:
  bool _internal_has_bar_id() const;
  public:
  void clear_bar_id();
  uint32_t bar_id() const;
  void set_bar_id(uint32_t value);
  private:
  uint32_t _internal_bar_id() const;
  void _internal_set_bar_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteAddrSpaceDeviceRam_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t addr_;
    uint32_t size_;
    uint32_t pf_id_;
    uint32_t bar_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteAddrSpaceDeviceRam_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteAddrSpaceDeviceRam_response) */ {
 public:
  inline xclWriteAddrSpaceDeviceRam_response() : xclWriteAddrSpaceDeviceRam_response(nullptr) {}
  ~xclWriteAddrSpaceDeviceRam_response() override;
  explicit PROTOBUF_CONSTEXPR xclWriteAddrSpaceDeviceRam_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteAddrSpaceDeviceRam_response(const xclWriteAddrSpaceDeviceRam_response& from);
  xclWriteAddrSpaceDeviceRam_response(xclWriteAddrSpaceDeviceRam_response&& from) noexcept
    : xclWriteAddrSpaceDeviceRam_response() {
    *this = ::std::move(from);
  }

  inline xclWriteAddrSpaceDeviceRam_response& operator=(const xclWriteAddrSpaceDeviceRam_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteAddrSpaceDeviceRam_response& operator=(xclWriteAddrSpaceDeviceRam_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteAddrSpaceDeviceRam_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteAddrSpaceDeviceRam_response* internal_default_instance() {
    return reinterpret_cast<const xclWriteAddrSpaceDeviceRam_response*>(
               &_xclWriteAddrSpaceDeviceRam_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(xclWriteAddrSpaceDeviceRam_response& a, xclWriteAddrSpaceDeviceRam_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteAddrSpaceDeviceRam_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteAddrSpaceDeviceRam_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteAddrSpaceDeviceRam_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteAddrSpaceDeviceRam_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteAddrSpaceDeviceRam_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteAddrSpaceDeviceRam_response& from) {
    xclWriteAddrSpaceDeviceRam_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteAddrSpaceDeviceRam_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteAddrSpaceDeviceRam_response";
  }
  protected:
  explicit xclWriteAddrSpaceDeviceRam_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteAddrSpaceDeviceRam_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteAddrKernelCtrl_call_kernelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteAddrKernelCtrl_call.kernelInfo) */ {
 public:
  inline xclWriteAddrKernelCtrl_call_kernelInfo() : xclWriteAddrKernelCtrl_call_kernelInfo(nullptr) {}
  ~xclWriteAddrKernelCtrl_call_kernelInfo() override;
  explicit PROTOBUF_CONSTEXPR xclWriteAddrKernelCtrl_call_kernelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteAddrKernelCtrl_call_kernelInfo(const xclWriteAddrKernelCtrl_call_kernelInfo& from);
  xclWriteAddrKernelCtrl_call_kernelInfo(xclWriteAddrKernelCtrl_call_kernelInfo&& from) noexcept
    : xclWriteAddrKernelCtrl_call_kernelInfo() {
    *this = ::std::move(from);
  }

  inline xclWriteAddrKernelCtrl_call_kernelInfo& operator=(const xclWriteAddrKernelCtrl_call_kernelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteAddrKernelCtrl_call_kernelInfo& operator=(xclWriteAddrKernelCtrl_call_kernelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteAddrKernelCtrl_call_kernelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteAddrKernelCtrl_call_kernelInfo* internal_default_instance() {
    return reinterpret_cast<const xclWriteAddrKernelCtrl_call_kernelInfo*>(
               &_xclWriteAddrKernelCtrl_call_kernelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(xclWriteAddrKernelCtrl_call_kernelInfo& a, xclWriteAddrKernelCtrl_call_kernelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteAddrKernelCtrl_call_kernelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteAddrKernelCtrl_call_kernelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteAddrKernelCtrl_call_kernelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteAddrKernelCtrl_call_kernelInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteAddrKernelCtrl_call_kernelInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteAddrKernelCtrl_call_kernelInfo& from) {
    xclWriteAddrKernelCtrl_call_kernelInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteAddrKernelCtrl_call_kernelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteAddrKernelCtrl_call.kernelInfo";
  }
  protected:
  explicit xclWriteAddrKernelCtrl_call_kernelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kAddrFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 addr = 1;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // optional uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteAddrKernelCtrl_call.kernelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t addr_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteAddrKernelCtrl_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteAddrKernelCtrl_call) */ {
 public:
  inline xclWriteAddrKernelCtrl_call() : xclWriteAddrKernelCtrl_call(nullptr) {}
  ~xclWriteAddrKernelCtrl_call() override;
  explicit PROTOBUF_CONSTEXPR xclWriteAddrKernelCtrl_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteAddrKernelCtrl_call(const xclWriteAddrKernelCtrl_call& from);
  xclWriteAddrKernelCtrl_call(xclWriteAddrKernelCtrl_call&& from) noexcept
    : xclWriteAddrKernelCtrl_call() {
    *this = ::std::move(from);
  }

  inline xclWriteAddrKernelCtrl_call& operator=(const xclWriteAddrKernelCtrl_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteAddrKernelCtrl_call& operator=(xclWriteAddrKernelCtrl_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteAddrKernelCtrl_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteAddrKernelCtrl_call* internal_default_instance() {
    return reinterpret_cast<const xclWriteAddrKernelCtrl_call*>(
               &_xclWriteAddrKernelCtrl_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(xclWriteAddrKernelCtrl_call& a, xclWriteAddrKernelCtrl_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteAddrKernelCtrl_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteAddrKernelCtrl_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteAddrKernelCtrl_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteAddrKernelCtrl_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteAddrKernelCtrl_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteAddrKernelCtrl_call& from) {
    xclWriteAddrKernelCtrl_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteAddrKernelCtrl_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteAddrKernelCtrl_call";
  }
  protected:
  explicit xclWriteAddrKernelCtrl_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclWriteAddrKernelCtrl_call_kernelInfo kernelInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kKernelInfoFieldNumber = 5,
    kDataFieldNumber = 4,
    kAddrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kPFIDFieldNumber = 6,
    kBARIDFieldNumber = 7,
  };
  // repeated .xclWriteAddrKernelCtrl_call.kernelInfo kernel_info = 5;
  int kernel_info_size() const;
  private:
  int _internal_kernel_info_size() const;
  public:
  void clear_kernel_info();
  ::xclWriteAddrKernelCtrl_call_kernelInfo* mutable_kernel_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclWriteAddrKernelCtrl_call_kernelInfo >*
      mutable_kernel_info();
  private:
  const ::xclWriteAddrKernelCtrl_call_kernelInfo& _internal_kernel_info(int index) const;
  ::xclWriteAddrKernelCtrl_call_kernelInfo* _internal_add_kernel_info();
  public:
  const ::xclWriteAddrKernelCtrl_call_kernelInfo& kernel_info(int index) const;
  ::xclWriteAddrKernelCtrl_call_kernelInfo* add_kernel_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclWriteAddrKernelCtrl_call_kernelInfo >&
      kernel_info() const;

  // required bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint64 addr = 2;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional uint32 PF_ID = 6;
  bool has_pf_id() const;
  private:
  bool _internal_has_pf_id() const;
  public:
  void clear_pf_id();
  uint32_t pf_id() const;
  void set_pf_id(uint32_t value);
  private:
  uint32_t _internal_pf_id() const;
  void _internal_set_pf_id(uint32_t value);
  public:

  // optional uint32 BAR_ID = 7;
  bool has_bar_id() const;
  private:
  bool _internal_has_bar_id() const;
  public:
  void clear_bar_id();
  uint32_t bar_id() const;
  void set_bar_id(uint32_t value);
  private:
  uint32_t _internal_bar_id() const;
  void _internal_set_bar_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteAddrKernelCtrl_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclWriteAddrKernelCtrl_call_kernelInfo > kernel_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t addr_;
    uint32_t size_;
    uint32_t pf_id_;
    uint32_t bar_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteAddrKernelCtrl_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteAddrKernelCtrl_response) */ {
 public:
  inline xclWriteAddrKernelCtrl_response() : xclWriteAddrKernelCtrl_response(nullptr) {}
  ~xclWriteAddrKernelCtrl_response() override;
  explicit PROTOBUF_CONSTEXPR xclWriteAddrKernelCtrl_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteAddrKernelCtrl_response(const xclWriteAddrKernelCtrl_response& from);
  xclWriteAddrKernelCtrl_response(xclWriteAddrKernelCtrl_response&& from) noexcept
    : xclWriteAddrKernelCtrl_response() {
    *this = ::std::move(from);
  }

  inline xclWriteAddrKernelCtrl_response& operator=(const xclWriteAddrKernelCtrl_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteAddrKernelCtrl_response& operator=(xclWriteAddrKernelCtrl_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteAddrKernelCtrl_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteAddrKernelCtrl_response* internal_default_instance() {
    return reinterpret_cast<const xclWriteAddrKernelCtrl_response*>(
               &_xclWriteAddrKernelCtrl_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(xclWriteAddrKernelCtrl_response& a, xclWriteAddrKernelCtrl_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteAddrKernelCtrl_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteAddrKernelCtrl_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteAddrKernelCtrl_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteAddrKernelCtrl_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteAddrKernelCtrl_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteAddrKernelCtrl_response& from) {
    xclWriteAddrKernelCtrl_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteAddrKernelCtrl_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteAddrKernelCtrl_response";
  }
  protected:
  explicit xclWriteAddrKernelCtrl_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteAddrKernelCtrl_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadAddrSpaceDeviceRam_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadAddrSpaceDeviceRam_call) */ {
 public:
  inline xclReadAddrSpaceDeviceRam_call() : xclReadAddrSpaceDeviceRam_call(nullptr) {}
  ~xclReadAddrSpaceDeviceRam_call() override;
  explicit PROTOBUF_CONSTEXPR xclReadAddrSpaceDeviceRam_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadAddrSpaceDeviceRam_call(const xclReadAddrSpaceDeviceRam_call& from);
  xclReadAddrSpaceDeviceRam_call(xclReadAddrSpaceDeviceRam_call&& from) noexcept
    : xclReadAddrSpaceDeviceRam_call() {
    *this = ::std::move(from);
  }

  inline xclReadAddrSpaceDeviceRam_call& operator=(const xclReadAddrSpaceDeviceRam_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadAddrSpaceDeviceRam_call& operator=(xclReadAddrSpaceDeviceRam_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadAddrSpaceDeviceRam_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadAddrSpaceDeviceRam_call* internal_default_instance() {
    return reinterpret_cast<const xclReadAddrSpaceDeviceRam_call*>(
               &_xclReadAddrSpaceDeviceRam_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(xclReadAddrSpaceDeviceRam_call& a, xclReadAddrSpaceDeviceRam_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadAddrSpaceDeviceRam_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadAddrSpaceDeviceRam_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadAddrSpaceDeviceRam_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadAddrSpaceDeviceRam_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadAddrSpaceDeviceRam_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadAddrSpaceDeviceRam_call& from) {
    xclReadAddrSpaceDeviceRam_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadAddrSpaceDeviceRam_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadAddrSpaceDeviceRam_call";
  }
  protected:
  explicit xclReadAddrSpaceDeviceRam_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kAddrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kPFIDFieldNumber = 5,
    kBARIDFieldNumber = 6,
  };
  // optional bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint64 addr = 2;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional uint32 PF_ID = 5;
  bool has_pf_id() const;
  private:
  bool _internal_has_pf_id() const;
  public:
  void clear_pf_id();
  uint32_t pf_id() const;
  void set_pf_id(uint32_t value);
  private:
  uint32_t _internal_pf_id() const;
  void _internal_set_pf_id(uint32_t value);
  public:

  // optional uint32 BAR_ID = 6;
  bool has_bar_id() const;
  private:
  bool _internal_has_bar_id() const;
  public:
  void clear_bar_id();
  uint32_t bar_id() const;
  void set_bar_id(uint32_t value);
  private:
  uint32_t _internal_bar_id() const;
  void _internal_set_bar_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadAddrSpaceDeviceRam_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t addr_;
    uint32_t size_;
    uint32_t pf_id_;
    uint32_t bar_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadAddrSpaceDeviceRam_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadAddrSpaceDeviceRam_response) */ {
 public:
  inline xclReadAddrSpaceDeviceRam_response() : xclReadAddrSpaceDeviceRam_response(nullptr) {}
  ~xclReadAddrSpaceDeviceRam_response() override;
  explicit PROTOBUF_CONSTEXPR xclReadAddrSpaceDeviceRam_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadAddrSpaceDeviceRam_response(const xclReadAddrSpaceDeviceRam_response& from);
  xclReadAddrSpaceDeviceRam_response(xclReadAddrSpaceDeviceRam_response&& from) noexcept
    : xclReadAddrSpaceDeviceRam_response() {
    *this = ::std::move(from);
  }

  inline xclReadAddrSpaceDeviceRam_response& operator=(const xclReadAddrSpaceDeviceRam_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadAddrSpaceDeviceRam_response& operator=(xclReadAddrSpaceDeviceRam_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadAddrSpaceDeviceRam_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadAddrSpaceDeviceRam_response* internal_default_instance() {
    return reinterpret_cast<const xclReadAddrSpaceDeviceRam_response*>(
               &_xclReadAddrSpaceDeviceRam_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(xclReadAddrSpaceDeviceRam_response& a, xclReadAddrSpaceDeviceRam_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadAddrSpaceDeviceRam_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadAddrSpaceDeviceRam_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadAddrSpaceDeviceRam_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadAddrSpaceDeviceRam_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadAddrSpaceDeviceRam_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadAddrSpaceDeviceRam_response& from) {
    xclReadAddrSpaceDeviceRam_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadAddrSpaceDeviceRam_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadAddrSpaceDeviceRam_response";
  }
  protected:
  explicit xclReadAddrSpaceDeviceRam_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kValidFieldNumber = 1,
  };
  // optional bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadAddrSpaceDeviceRam_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadAddrKernelCtrl_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadAddrKernelCtrl_call) */ {
 public:
  inline xclReadAddrKernelCtrl_call() : xclReadAddrKernelCtrl_call(nullptr) {}
  ~xclReadAddrKernelCtrl_call() override;
  explicit PROTOBUF_CONSTEXPR xclReadAddrKernelCtrl_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadAddrKernelCtrl_call(const xclReadAddrKernelCtrl_call& from);
  xclReadAddrKernelCtrl_call(xclReadAddrKernelCtrl_call&& from) noexcept
    : xclReadAddrKernelCtrl_call() {
    *this = ::std::move(from);
  }

  inline xclReadAddrKernelCtrl_call& operator=(const xclReadAddrKernelCtrl_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadAddrKernelCtrl_call& operator=(xclReadAddrKernelCtrl_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadAddrKernelCtrl_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadAddrKernelCtrl_call* internal_default_instance() {
    return reinterpret_cast<const xclReadAddrKernelCtrl_call*>(
               &_xclReadAddrKernelCtrl_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(xclReadAddrKernelCtrl_call& a, xclReadAddrKernelCtrl_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadAddrKernelCtrl_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadAddrKernelCtrl_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadAddrKernelCtrl_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadAddrKernelCtrl_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadAddrKernelCtrl_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadAddrKernelCtrl_call& from) {
    xclReadAddrKernelCtrl_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadAddrKernelCtrl_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadAddrKernelCtrl_call";
  }
  protected:
  explicit xclReadAddrKernelCtrl_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kAddrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kPFIDFieldNumber = 5,
    kBARIDFieldNumber = 6,
  };
  // optional bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint64 addr = 2;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional uint32 PF_ID = 5;
  bool has_pf_id() const;
  private:
  bool _internal_has_pf_id() const;
  public:
  void clear_pf_id();
  uint32_t pf_id() const;
  void set_pf_id(uint32_t value);
  private:
  uint32_t _internal_pf_id() const;
  void _internal_set_pf_id(uint32_t value);
  public:

  // optional uint32 BAR_ID = 6;
  bool has_bar_id() const;
  private:
  bool _internal_has_bar_id() const;
  public:
  void clear_bar_id();
  uint32_t bar_id() const;
  void set_bar_id(uint32_t value);
  private:
  uint32_t _internal_bar_id() const;
  void _internal_set_bar_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadAddrKernelCtrl_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t addr_;
    uint32_t size_;
    uint32_t pf_id_;
    uint32_t bar_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadAddrKernelCtrl_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadAddrKernelCtrl_response) */ {
 public:
  inline xclReadAddrKernelCtrl_response() : xclReadAddrKernelCtrl_response(nullptr) {}
  ~xclReadAddrKernelCtrl_response() override;
  explicit PROTOBUF_CONSTEXPR xclReadAddrKernelCtrl_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadAddrKernelCtrl_response(const xclReadAddrKernelCtrl_response& from);
  xclReadAddrKernelCtrl_response(xclReadAddrKernelCtrl_response&& from) noexcept
    : xclReadAddrKernelCtrl_response() {
    *this = ::std::move(from);
  }

  inline xclReadAddrKernelCtrl_response& operator=(const xclReadAddrKernelCtrl_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadAddrKernelCtrl_response& operator=(xclReadAddrKernelCtrl_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadAddrKernelCtrl_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadAddrKernelCtrl_response* internal_default_instance() {
    return reinterpret_cast<const xclReadAddrKernelCtrl_response*>(
               &_xclReadAddrKernelCtrl_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(xclReadAddrKernelCtrl_response& a, xclReadAddrKernelCtrl_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadAddrKernelCtrl_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadAddrKernelCtrl_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadAddrKernelCtrl_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadAddrKernelCtrl_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadAddrKernelCtrl_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadAddrKernelCtrl_response& from) {
    xclReadAddrKernelCtrl_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadAddrKernelCtrl_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadAddrKernelCtrl_response";
  }
  protected:
  explicit xclReadAddrKernelCtrl_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kValidFieldNumber = 1,
  };
  // optional bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadAddrKernelCtrl_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadCounters_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadCounters_call) */ {
 public:
  inline xclPerfMonReadCounters_call() : xclPerfMonReadCounters_call(nullptr) {}
  ~xclPerfMonReadCounters_call() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadCounters_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadCounters_call(const xclPerfMonReadCounters_call& from);
  xclPerfMonReadCounters_call(xclPerfMonReadCounters_call&& from) noexcept
    : xclPerfMonReadCounters_call() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadCounters_call& operator=(const xclPerfMonReadCounters_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadCounters_call& operator=(xclPerfMonReadCounters_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadCounters_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadCounters_call* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadCounters_call*>(
               &_xclPerfMonReadCounters_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(xclPerfMonReadCounters_call& a, xclPerfMonReadCounters_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadCounters_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadCounters_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadCounters_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadCounters_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadCounters_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadCounters_call& from) {
    xclPerfMonReadCounters_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadCounters_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadCounters_call";
  }
  protected:
  explicit xclPerfMonReadCounters_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotnameFieldNumber = 1,
    kAccelFieldNumber = 2,
  };
  // required string slotname = 1;
  bool has_slotname() const;
  private:
  bool _internal_has_slotname() const;
  public:
  void clear_slotname();
  const std::string& slotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slotname();
  PROTOBUF_NODISCARD std::string* release_slotname();
  void set_allocated_slotname(std::string* slotname);
  private:
  const std::string& _internal_slotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotname(const std::string& value);
  std::string* _internal_mutable_slotname();
  public:

  // optional bool accel = 2;
  bool has_accel() const;
  private:
  bool _internal_has_accel() const;
  public:
  void clear_accel();
  bool accel() const;
  void set_accel(bool value);
  private:
  bool _internal_accel() const;
  void _internal_set_accel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadCounters_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slotname_;
    bool accel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadCounters_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadCounters_response) */ {
 public:
  inline xclPerfMonReadCounters_response() : xclPerfMonReadCounters_response(nullptr) {}
  ~xclPerfMonReadCounters_response() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadCounters_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadCounters_response(const xclPerfMonReadCounters_response& from);
  xclPerfMonReadCounters_response(xclPerfMonReadCounters_response&& from) noexcept
    : xclPerfMonReadCounters_response() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadCounters_response& operator=(const xclPerfMonReadCounters_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadCounters_response& operator=(xclPerfMonReadCounters_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadCounters_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadCounters_response* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadCounters_response*>(
               &_xclPerfMonReadCounters_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(xclPerfMonReadCounters_response& a, xclPerfMonReadCounters_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadCounters_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadCounters_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadCounters_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadCounters_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadCounters_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadCounters_response& from) {
    xclPerfMonReadCounters_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadCounters_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadCounters_response";
  }
  protected:
  explicit xclPerfMonReadCounters_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWrByteCountFieldNumber = 1,
    kWrTransCountFieldNumber = 2,
    kTotalWrLatencyFieldNumber = 3,
    kRdByteCountFieldNumber = 4,
    kRdTransCountFieldNumber = 5,
    kTotalRdLatencyFieldNumber = 6,
  };
  // optional uint32 wr_byte_count = 1;
  bool has_wr_byte_count() const;
  private:
  bool _internal_has_wr_byte_count() const;
  public:
  void clear_wr_byte_count();
  uint32_t wr_byte_count() const;
  void set_wr_byte_count(uint32_t value);
  private:
  uint32_t _internal_wr_byte_count() const;
  void _internal_set_wr_byte_count(uint32_t value);
  public:

  // optional uint32 wr_trans_count = 2;
  bool has_wr_trans_count() const;
  private:
  bool _internal_has_wr_trans_count() const;
  public:
  void clear_wr_trans_count();
  uint32_t wr_trans_count() const;
  void set_wr_trans_count(uint32_t value);
  private:
  uint32_t _internal_wr_trans_count() const;
  void _internal_set_wr_trans_count(uint32_t value);
  public:

  // optional uint32 total_wr_latency = 3;
  bool has_total_wr_latency() const;
  private:
  bool _internal_has_total_wr_latency() const;
  public:
  void clear_total_wr_latency();
  uint32_t total_wr_latency() const;
  void set_total_wr_latency(uint32_t value);
  private:
  uint32_t _internal_total_wr_latency() const;
  void _internal_set_total_wr_latency(uint32_t value);
  public:

  // optional uint32 rd_byte_count = 4;
  bool has_rd_byte_count() const;
  private:
  bool _internal_has_rd_byte_count() const;
  public:
  void clear_rd_byte_count();
  uint32_t rd_byte_count() const;
  void set_rd_byte_count(uint32_t value);
  private:
  uint32_t _internal_rd_byte_count() const;
  void _internal_set_rd_byte_count(uint32_t value);
  public:

  // optional uint32 rd_trans_count = 5;
  bool has_rd_trans_count() const;
  private:
  bool _internal_has_rd_trans_count() const;
  public:
  void clear_rd_trans_count();
  uint32_t rd_trans_count() const;
  void set_rd_trans_count(uint32_t value);
  private:
  uint32_t _internal_rd_trans_count() const;
  void _internal_set_rd_trans_count(uint32_t value);
  public:

  // optional uint32 total_rd_latency = 6;
  bool has_total_rd_latency() const;
  private:
  bool _internal_has_total_rd_latency() const;
  public:
  void clear_total_rd_latency();
  uint32_t total_rd_latency() const;
  void set_total_rd_latency(uint32_t value);
  private:
  uint32_t _internal_total_rd_latency() const;
  void _internal_set_total_rd_latency(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadCounters_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t wr_byte_count_;
    uint32_t wr_trans_count_;
    uint32_t total_wr_latency_;
    uint32_t rd_byte_count_;
    uint32_t rd_trans_count_;
    uint32_t total_rd_latency_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonGetTraceCount_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonGetTraceCount_call) */ {
 public:
  inline xclPerfMonGetTraceCount_call() : xclPerfMonGetTraceCount_call(nullptr) {}
  ~xclPerfMonGetTraceCount_call() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonGetTraceCount_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonGetTraceCount_call(const xclPerfMonGetTraceCount_call& from);
  xclPerfMonGetTraceCount_call(xclPerfMonGetTraceCount_call&& from) noexcept
    : xclPerfMonGetTraceCount_call() {
    *this = ::std::move(from);
  }

  inline xclPerfMonGetTraceCount_call& operator=(const xclPerfMonGetTraceCount_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonGetTraceCount_call& operator=(xclPerfMonGetTraceCount_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonGetTraceCount_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonGetTraceCount_call* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonGetTraceCount_call*>(
               &_xclPerfMonGetTraceCount_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(xclPerfMonGetTraceCount_call& a, xclPerfMonGetTraceCount_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonGetTraceCount_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonGetTraceCount_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonGetTraceCount_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonGetTraceCount_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonGetTraceCount_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonGetTraceCount_call& from) {
    xclPerfMonGetTraceCount_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonGetTraceCount_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonGetTraceCount_call";
  }
  protected:
  explicit xclPerfMonGetTraceCount_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotnameFieldNumber = 2,
    kAckFieldNumber = 1,
    kAccelFieldNumber = 3,
  };
  // optional string slotname = 2;
  bool has_slotname() const;
  private:
  bool _internal_has_slotname() const;
  public:
  void clear_slotname();
  const std::string& slotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slotname();
  PROTOBUF_NODISCARD std::string* release_slotname();
  void set_allocated_slotname(std::string* slotname);
  private:
  const std::string& _internal_slotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotname(const std::string& value);
  std::string* _internal_mutable_slotname();
  public:

  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // optional bool accel = 3;
  bool has_accel() const;
  private:
  bool _internal_has_accel() const;
  public:
  void clear_accel();
  bool accel() const;
  void set_accel(bool value);
  private:
  bool _internal_accel() const;
  void _internal_set_accel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonGetTraceCount_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slotname_;
    bool ack_;
    bool accel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonGetTraceCount_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonGetTraceCount_response) */ {
 public:
  inline xclPerfMonGetTraceCount_response() : xclPerfMonGetTraceCount_response(nullptr) {}
  ~xclPerfMonGetTraceCount_response() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonGetTraceCount_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonGetTraceCount_response(const xclPerfMonGetTraceCount_response& from);
  xclPerfMonGetTraceCount_response(xclPerfMonGetTraceCount_response&& from) noexcept
    : xclPerfMonGetTraceCount_response() {
    *this = ::std::move(from);
  }

  inline xclPerfMonGetTraceCount_response& operator=(const xclPerfMonGetTraceCount_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonGetTraceCount_response& operator=(xclPerfMonGetTraceCount_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonGetTraceCount_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonGetTraceCount_response* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonGetTraceCount_response*>(
               &_xclPerfMonGetTraceCount_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(xclPerfMonGetTraceCount_response& a, xclPerfMonGetTraceCount_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonGetTraceCount_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonGetTraceCount_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonGetTraceCount_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonGetTraceCount_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonGetTraceCount_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonGetTraceCount_response& from) {
    xclPerfMonGetTraceCount_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonGetTraceCount_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonGetTraceCount_response";
  }
  protected:
  explicit xclPerfMonGetTraceCount_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoOfSamplesFieldNumber = 1,
  };
  // optional uint32 no_of_samples = 1;
  bool has_no_of_samples() const;
  private:
  bool _internal_has_no_of_samples() const;
  public:
  void clear_no_of_samples();
  uint32_t no_of_samples() const;
  void set_no_of_samples(uint32_t value);
  private:
  uint32_t _internal_no_of_samples() const;
  void _internal_set_no_of_samples(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonGetTraceCount_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t no_of_samples_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadTrace_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadTrace_call) */ {
 public:
  inline xclPerfMonReadTrace_call() : xclPerfMonReadTrace_call(nullptr) {}
  ~xclPerfMonReadTrace_call() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadTrace_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadTrace_call(const xclPerfMonReadTrace_call& from);
  xclPerfMonReadTrace_call(xclPerfMonReadTrace_call&& from) noexcept
    : xclPerfMonReadTrace_call() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadTrace_call& operator=(const xclPerfMonReadTrace_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadTrace_call& operator=(xclPerfMonReadTrace_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadTrace_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadTrace_call* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadTrace_call*>(
               &_xclPerfMonReadTrace_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(xclPerfMonReadTrace_call& a, xclPerfMonReadTrace_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadTrace_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadTrace_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadTrace_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadTrace_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadTrace_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadTrace_call& from) {
    xclPerfMonReadTrace_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadTrace_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadTrace_call";
  }
  protected:
  explicit xclPerfMonReadTrace_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotnameFieldNumber = 2,
    kAckFieldNumber = 1,
    kAccelFieldNumber = 3,
  };
  // optional string slotname = 2;
  bool has_slotname() const;
  private:
  bool _internal_has_slotname() const;
  public:
  void clear_slotname();
  const std::string& slotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slotname();
  PROTOBUF_NODISCARD std::string* release_slotname();
  void set_allocated_slotname(std::string* slotname);
  private:
  const std::string& _internal_slotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotname(const std::string& value);
  std::string* _internal_mutable_slotname();
  public:

  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // optional bool accel = 3;
  bool has_accel() const;
  private:
  bool _internal_has_accel() const;
  public:
  void clear_accel();
  bool accel() const;
  void set_accel(bool value);
  private:
  bool _internal_accel() const;
  void _internal_set_accel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadTrace_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slotname_;
    bool ack_;
    bool accel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadTrace_response_events final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadTrace_response.events) */ {
 public:
  inline xclPerfMonReadTrace_response_events() : xclPerfMonReadTrace_response_events(nullptr) {}
  ~xclPerfMonReadTrace_response_events() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadTrace_response_events(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadTrace_response_events(const xclPerfMonReadTrace_response_events& from);
  xclPerfMonReadTrace_response_events(xclPerfMonReadTrace_response_events&& from) noexcept
    : xclPerfMonReadTrace_response_events() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadTrace_response_events& operator=(const xclPerfMonReadTrace_response_events& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadTrace_response_events& operator=(xclPerfMonReadTrace_response_events&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadTrace_response_events& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadTrace_response_events* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadTrace_response_events*>(
               &_xclPerfMonReadTrace_response_events_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(xclPerfMonReadTrace_response_events& a, xclPerfMonReadTrace_response_events& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadTrace_response_events* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadTrace_response_events* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadTrace_response_events* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadTrace_response_events>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadTrace_response_events& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadTrace_response_events& from) {
    xclPerfMonReadTrace_response_events::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadTrace_response_events* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadTrace_response.events";
  }
  protected:
  explicit xclPerfMonReadTrace_response_events(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAwlenFieldNumber = 1,
    kArlenFieldNumber = 2,
    kEventflagsFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kHostTimestampFieldNumber = 5,
    kRdBytesFieldNumber = 6,
    kWrBytesFieldNumber = 7,
  };
  // optional uint32 awlen = 1;
  bool has_awlen() const;
  private:
  bool _internal_has_awlen() const;
  public:
  void clear_awlen();
  uint32_t awlen() const;
  void set_awlen(uint32_t value);
  private:
  uint32_t _internal_awlen() const;
  void _internal_set_awlen(uint32_t value);
  public:

  // optional uint32 arlen = 2;
  bool has_arlen() const;
  private:
  bool _internal_has_arlen() const;
  public:
  void clear_arlen();
  uint32_t arlen() const;
  void set_arlen(uint32_t value);
  private:
  uint32_t _internal_arlen() const;
  void _internal_set_arlen(uint32_t value);
  public:

  // optional uint32 eventflags = 3;
  bool has_eventflags() const;
  private:
  bool _internal_has_eventflags() const;
  public:
  void clear_eventflags();
  uint32_t eventflags() const;
  void set_eventflags(uint32_t value);
  private:
  uint32_t _internal_eventflags() const;
  void _internal_set_eventflags(uint32_t value);
  public:

  // optional uint32 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional uint64 host_timestamp = 5;
  bool has_host_timestamp() const;
  private:
  bool _internal_has_host_timestamp() const;
  public:
  void clear_host_timestamp();
  uint64_t host_timestamp() const;
  void set_host_timestamp(uint64_t value);
  private:
  uint64_t _internal_host_timestamp() const;
  void _internal_set_host_timestamp(uint64_t value);
  public:

  // optional uint32 rd_bytes = 6;
  bool has_rd_bytes() const;
  private:
  bool _internal_has_rd_bytes() const;
  public:
  void clear_rd_bytes();
  uint32_t rd_bytes() const;
  void set_rd_bytes(uint32_t value);
  private:
  uint32_t _internal_rd_bytes() const;
  void _internal_set_rd_bytes(uint32_t value);
  public:

  // optional uint32 wr_bytes = 7;
  bool has_wr_bytes() const;
  private:
  bool _internal_has_wr_bytes() const;
  public:
  void clear_wr_bytes();
  uint32_t wr_bytes() const;
  void set_wr_bytes(uint32_t value);
  private:
  uint32_t _internal_wr_bytes() const;
  void _internal_set_wr_bytes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadTrace_response.events)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t awlen_;
    uint32_t arlen_;
    uint32_t eventflags_;
    uint32_t timestamp_;
    uint64_t host_timestamp_;
    uint32_t rd_bytes_;
    uint32_t wr_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadTrace_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadTrace_response) */ {
 public:
  inline xclPerfMonReadTrace_response() : xclPerfMonReadTrace_response(nullptr) {}
  ~xclPerfMonReadTrace_response() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadTrace_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadTrace_response(const xclPerfMonReadTrace_response& from);
  xclPerfMonReadTrace_response(xclPerfMonReadTrace_response&& from) noexcept
    : xclPerfMonReadTrace_response() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadTrace_response& operator=(const xclPerfMonReadTrace_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadTrace_response& operator=(xclPerfMonReadTrace_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadTrace_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadTrace_response* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadTrace_response*>(
               &_xclPerfMonReadTrace_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(xclPerfMonReadTrace_response& a, xclPerfMonReadTrace_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadTrace_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadTrace_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadTrace_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadTrace_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadTrace_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadTrace_response& from) {
    xclPerfMonReadTrace_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadTrace_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadTrace_response";
  }
  protected:
  explicit xclPerfMonReadTrace_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclPerfMonReadTrace_response_events events;

  // accessors -------------------------------------------------------

  enum : int {
    kOutputDataFieldNumber = 8,
  };
  // repeated .xclPerfMonReadTrace_response.events output_data = 8;
  int output_data_size() const;
  private:
  int _internal_output_data_size() const;
  public:
  void clear_output_data();
  ::xclPerfMonReadTrace_response_events* mutable_output_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_response_events >*
      mutable_output_data();
  private:
  const ::xclPerfMonReadTrace_response_events& _internal_output_data(int index) const;
  ::xclPerfMonReadTrace_response_events* _internal_add_output_data();
  public:
  const ::xclPerfMonReadTrace_response_events& output_data(int index) const;
  ::xclPerfMonReadTrace_response_events* add_output_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_response_events >&
      output_data() const;

  // @@protoc_insertion_point(class_scope:xclPerfMonReadTrace_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_response_events > output_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ddr_mem_msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ddr_mem_msg) */ {
 public:
  inline ddr_mem_msg() : ddr_mem_msg(nullptr) {}
  ~ddr_mem_msg() override;
  explicit PROTOBUF_CONSTEXPR ddr_mem_msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ddr_mem_msg(const ddr_mem_msg& from);
  ddr_mem_msg(ddr_mem_msg&& from) noexcept
    : ddr_mem_msg() {
    *this = ::std::move(from);
  }

  inline ddr_mem_msg& operator=(const ddr_mem_msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ddr_mem_msg& operator=(ddr_mem_msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ddr_mem_msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ddr_mem_msg* internal_default_instance() {
    return reinterpret_cast<const ddr_mem_msg*>(
               &_ddr_mem_msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ddr_mem_msg& a, ddr_mem_msg& b) {
    a.Swap(&b);
  }
  inline void Swap(ddr_mem_msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ddr_mem_msg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ddr_mem_msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ddr_mem_msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ddr_mem_msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ddr_mem_msg& from) {
    ddr_mem_msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ddr_mem_msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ddr_mem_msg";
  }
  protected:
  explicit ddr_mem_msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kStrbDataFieldNumber = 3,
    kSizeFieldNumber = 2,
    kFullsizeFieldNumber = 4,
  };
  // required bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes strb_data = 3;
  bool has_strb_data() const;
  private:
  bool _internal_has_strb_data() const;
  public:
  void clear_strb_data();
  const std::string& strb_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strb_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strb_data();
  PROTOBUF_NODISCARD std::string* release_strb_data();
  void set_allocated_strb_data(std::string* strb_data);
  private:
  const std::string& _internal_strb_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strb_data(const std::string& value);
  std::string* _internal_mutable_strb_data();
  public:

  // optional uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional uint64 fullsize = 4;
  bool has_fullsize() const;
  private:
  bool _internal_has_fullsize() const;
  public:
  void clear_fullsize();
  uint64_t fullsize() const;
  void set_fullsize(uint64_t value);
  private:
  uint64_t _internal_fullsize() const;
  void _internal_set_fullsize(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ddr_mem_msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strb_data_;
    uint64_t size_;
    uint64_t fullsize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclGetDeviceTimestamp_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclGetDeviceTimestamp_call) */ {
 public:
  inline xclGetDeviceTimestamp_call() : xclGetDeviceTimestamp_call(nullptr) {}
  ~xclGetDeviceTimestamp_call() override;
  explicit PROTOBUF_CONSTEXPR xclGetDeviceTimestamp_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclGetDeviceTimestamp_call(const xclGetDeviceTimestamp_call& from);
  xclGetDeviceTimestamp_call(xclGetDeviceTimestamp_call&& from) noexcept
    : xclGetDeviceTimestamp_call() {
    *this = ::std::move(from);
  }

  inline xclGetDeviceTimestamp_call& operator=(const xclGetDeviceTimestamp_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclGetDeviceTimestamp_call& operator=(xclGetDeviceTimestamp_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclGetDeviceTimestamp_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclGetDeviceTimestamp_call* internal_default_instance() {
    return reinterpret_cast<const xclGetDeviceTimestamp_call*>(
               &_xclGetDeviceTimestamp_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(xclGetDeviceTimestamp_call& a, xclGetDeviceTimestamp_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclGetDeviceTimestamp_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclGetDeviceTimestamp_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclGetDeviceTimestamp_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclGetDeviceTimestamp_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclGetDeviceTimestamp_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclGetDeviceTimestamp_call& from) {
    xclGetDeviceTimestamp_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclGetDeviceTimestamp_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclGetDeviceTimestamp_call";
  }
  protected:
  explicit xclGetDeviceTimestamp_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclGetDeviceTimestamp_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclGetDeviceTimestamp_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclGetDeviceTimestamp_response) */ {
 public:
  inline xclGetDeviceTimestamp_response() : xclGetDeviceTimestamp_response(nullptr) {}
  ~xclGetDeviceTimestamp_response() override;
  explicit PROTOBUF_CONSTEXPR xclGetDeviceTimestamp_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclGetDeviceTimestamp_response(const xclGetDeviceTimestamp_response& from);
  xclGetDeviceTimestamp_response(xclGetDeviceTimestamp_response&& from) noexcept
    : xclGetDeviceTimestamp_response() {
    *this = ::std::move(from);
  }

  inline xclGetDeviceTimestamp_response& operator=(const xclGetDeviceTimestamp_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclGetDeviceTimestamp_response& operator=(xclGetDeviceTimestamp_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclGetDeviceTimestamp_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclGetDeviceTimestamp_response* internal_default_instance() {
    return reinterpret_cast<const xclGetDeviceTimestamp_response*>(
               &_xclGetDeviceTimestamp_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(xclGetDeviceTimestamp_response& a, xclGetDeviceTimestamp_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclGetDeviceTimestamp_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclGetDeviceTimestamp_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclGetDeviceTimestamp_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclGetDeviceTimestamp_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclGetDeviceTimestamp_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclGetDeviceTimestamp_response& from) {
    xclGetDeviceTimestamp_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclGetDeviceTimestamp_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclGetDeviceTimestamp_response";
  }
  protected:
  explicit xclGetDeviceTimestamp_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceTimestampFieldNumber = 1,
  };
  // required uint64 device_timestamp = 1;
  bool has_device_timestamp() const;
  private:
  bool _internal_has_device_timestamp() const;
  public:
  void clear_device_timestamp();
  uint64_t device_timestamp() const;
  void set_device_timestamp(uint64_t value);
  private:
  uint64_t _internal_device_timestamp() const;
  void _internal_set_device_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclGetDeviceTimestamp_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t device_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadBusStatus_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadBusStatus_call) */ {
 public:
  inline xclReadBusStatus_call() : xclReadBusStatus_call(nullptr) {}
  ~xclReadBusStatus_call() override;
  explicit PROTOBUF_CONSTEXPR xclReadBusStatus_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadBusStatus_call(const xclReadBusStatus_call& from);
  xclReadBusStatus_call(xclReadBusStatus_call&& from) noexcept
    : xclReadBusStatus_call() {
    *this = ::std::move(from);
  }

  inline xclReadBusStatus_call& operator=(const xclReadBusStatus_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadBusStatus_call& operator=(xclReadBusStatus_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadBusStatus_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadBusStatus_call* internal_default_instance() {
    return reinterpret_cast<const xclReadBusStatus_call*>(
               &_xclReadBusStatus_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(xclReadBusStatus_call& a, xclReadBusStatus_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadBusStatus_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadBusStatus_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadBusStatus_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadBusStatus_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadBusStatus_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadBusStatus_call& from) {
    xclReadBusStatus_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadBusStatus_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadBusStatus_call";
  }
  protected:
  explicit xclReadBusStatus_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotNFieldNumber = 1,
  };
  // optional int32 slot_n = 1;
  bool has_slot_n() const;
  private:
  bool _internal_has_slot_n() const;
  public:
  void clear_slot_n();
  int32_t slot_n() const;
  void set_slot_n(int32_t value);
  private:
  int32_t _internal_slot_n() const;
  void _internal_set_slot_n(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadBusStatus_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t slot_n_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadBusStatus_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadBusStatus_response) */ {
 public:
  inline xclReadBusStatus_response() : xclReadBusStatus_response(nullptr) {}
  ~xclReadBusStatus_response() override;
  explicit PROTOBUF_CONSTEXPR xclReadBusStatus_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadBusStatus_response(const xclReadBusStatus_response& from);
  xclReadBusStatus_response(xclReadBusStatus_response&& from) noexcept
    : xclReadBusStatus_response() {
    *this = ::std::move(from);
  }

  inline xclReadBusStatus_response& operator=(const xclReadBusStatus_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadBusStatus_response& operator=(xclReadBusStatus_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadBusStatus_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadBusStatus_response* internal_default_instance() {
    return reinterpret_cast<const xclReadBusStatus_response*>(
               &_xclReadBusStatus_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(xclReadBusStatus_response& a, xclReadBusStatus_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadBusStatus_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadBusStatus_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadBusStatus_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadBusStatus_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadBusStatus_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadBusStatus_response& from) {
    xclReadBusStatus_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadBusStatus_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadBusStatus_response";
  }
  protected:
  explicit xclReadBusStatus_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUncompleteRdCyclesFieldNumber = 1,
    kUncompleteWrCyclesFieldNumber = 2,
    kIdleBusCyclesFieldNumber = 3,
    kUncompleteRdIdFieldNumber = 4,
    kUncompleteWrIdFieldNumber = 5,
  };
  // optional uint64 uncomplete_rd_cycles = 1;
  bool has_uncomplete_rd_cycles() const;
  private:
  bool _internal_has_uncomplete_rd_cycles() const;
  public:
  void clear_uncomplete_rd_cycles();
  uint64_t uncomplete_rd_cycles() const;
  void set_uncomplete_rd_cycles(uint64_t value);
  private:
  uint64_t _internal_uncomplete_rd_cycles() const;
  void _internal_set_uncomplete_rd_cycles(uint64_t value);
  public:

  // optional uint64 uncomplete_wr_cycles = 2;
  bool has_uncomplete_wr_cycles() const;
  private:
  bool _internal_has_uncomplete_wr_cycles() const;
  public:
  void clear_uncomplete_wr_cycles();
  uint64_t uncomplete_wr_cycles() const;
  void set_uncomplete_wr_cycles(uint64_t value);
  private:
  uint64_t _internal_uncomplete_wr_cycles() const;
  void _internal_set_uncomplete_wr_cycles(uint64_t value);
  public:

  // optional uint64 idle_bus_cycles = 3;
  bool has_idle_bus_cycles() const;
  private:
  bool _internal_has_idle_bus_cycles() const;
  public:
  void clear_idle_bus_cycles();
  uint64_t idle_bus_cycles() const;
  void set_idle_bus_cycles(uint64_t value);
  private:
  uint64_t _internal_idle_bus_cycles() const;
  void _internal_set_idle_bus_cycles(uint64_t value);
  public:

  // optional uint64 uncomplete_rd_id = 4;
  bool has_uncomplete_rd_id() const;
  private:
  bool _internal_has_uncomplete_rd_id() const;
  public:
  void clear_uncomplete_rd_id();
  uint64_t uncomplete_rd_id() const;
  void set_uncomplete_rd_id(uint64_t value);
  private:
  uint64_t _internal_uncomplete_rd_id() const;
  void _internal_set_uncomplete_rd_id(uint64_t value);
  public:

  // optional uint64 uncomplete_wr_id = 5;
  bool has_uncomplete_wr_id() const;
  private:
  bool _internal_has_uncomplete_wr_id() const;
  public:
  void clear_uncomplete_wr_id();
  uint64_t uncomplete_wr_id() const;
  void set_uncomplete_wr_id(uint64_t value);
  private:
  uint64_t _internal_uncomplete_wr_id() const;
  void _internal_set_uncomplete_wr_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadBusStatus_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t uncomplete_rd_cycles_;
    uint64_t uncomplete_wr_cycles_;
    uint64_t idle_bus_cycles_;
    uint64_t uncomplete_rd_id_;
    uint64_t uncomplete_wr_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclGetDebugMessages_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclGetDebugMessages_call) */ {
 public:
  inline xclGetDebugMessages_call() : xclGetDebugMessages_call(nullptr) {}
  ~xclGetDebugMessages_call() override;
  explicit PROTOBUF_CONSTEXPR xclGetDebugMessages_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclGetDebugMessages_call(const xclGetDebugMessages_call& from);
  xclGetDebugMessages_call(xclGetDebugMessages_call&& from) noexcept
    : xclGetDebugMessages_call() {
    *this = ::std::move(from);
  }

  inline xclGetDebugMessages_call& operator=(const xclGetDebugMessages_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclGetDebugMessages_call& operator=(xclGetDebugMessages_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclGetDebugMessages_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclGetDebugMessages_call* internal_default_instance() {
    return reinterpret_cast<const xclGetDebugMessages_call*>(
               &_xclGetDebugMessages_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(xclGetDebugMessages_call& a, xclGetDebugMessages_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclGetDebugMessages_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclGetDebugMessages_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclGetDebugMessages_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclGetDebugMessages_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclGetDebugMessages_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclGetDebugMessages_call& from) {
    xclGetDebugMessages_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclGetDebugMessages_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclGetDebugMessages_call";
  }
  protected:
  explicit xclGetDebugMessages_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
    kForceFieldNumber = 2,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // optional bool force = 2;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclGetDebugMessages_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
    bool force_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclGetDebugMessages_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclGetDebugMessages_response) */ {
 public:
  inline xclGetDebugMessages_response() : xclGetDebugMessages_response(nullptr) {}
  ~xclGetDebugMessages_response() override;
  explicit PROTOBUF_CONSTEXPR xclGetDebugMessages_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclGetDebugMessages_response(const xclGetDebugMessages_response& from);
  xclGetDebugMessages_response(xclGetDebugMessages_response&& from) noexcept
    : xclGetDebugMessages_response() {
    *this = ::std::move(from);
  }

  inline xclGetDebugMessages_response& operator=(const xclGetDebugMessages_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclGetDebugMessages_response& operator=(xclGetDebugMessages_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclGetDebugMessages_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclGetDebugMessages_response* internal_default_instance() {
    return reinterpret_cast<const xclGetDebugMessages_response*>(
               &_xclGetDebugMessages_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(xclGetDebugMessages_response& a, xclGetDebugMessages_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclGetDebugMessages_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclGetDebugMessages_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclGetDebugMessages_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclGetDebugMessages_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclGetDebugMessages_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclGetDebugMessages_response& from) {
    xclGetDebugMessages_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclGetDebugMessages_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclGetDebugMessages_response";
  }
  protected:
  explicit xclGetDebugMessages_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayMsgsFieldNumber = 1,
    kLogMsgsFieldNumber = 2,
    kStopMsgsFieldNumber = 3,
  };
  // optional bytes display_msgs = 1;
  bool has_display_msgs() const;
  private:
  bool _internal_has_display_msgs() const;
  public:
  void clear_display_msgs();
  const std::string& display_msgs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_msgs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_msgs();
  PROTOBUF_NODISCARD std::string* release_display_msgs();
  void set_allocated_display_msgs(std::string* display_msgs);
  private:
  const std::string& _internal_display_msgs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_msgs(const std::string& value);
  std::string* _internal_mutable_display_msgs();
  public:

  // optional bytes log_msgs = 2;
  bool has_log_msgs() const;
  private:
  bool _internal_has_log_msgs() const;
  public:
  void clear_log_msgs();
  const std::string& log_msgs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log_msgs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log_msgs();
  PROTOBUF_NODISCARD std::string* release_log_msgs();
  void set_allocated_log_msgs(std::string* log_msgs);
  private:
  const std::string& _internal_log_msgs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_msgs(const std::string& value);
  std::string* _internal_mutable_log_msgs();
  public:

  // optional bytes stop_msgs = 3;
  bool has_stop_msgs() const;
  private:
  bool _internal_has_stop_msgs() const;
  public:
  void clear_stop_msgs();
  const std::string& stop_msgs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_msgs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_msgs();
  PROTOBUF_NODISCARD std::string* release_stop_msgs();
  void set_allocated_stop_msgs(std::string* stop_msgs);
  private:
  const std::string& _internal_stop_msgs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_msgs(const std::string& value);
  std::string* _internal_mutable_stop_msgs();
  public:

  // @@protoc_insertion_point(class_scope:xclGetDebugMessages_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_msgs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclImportBO_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclImportBO_call) */ {
 public:
  inline xclImportBO_call() : xclImportBO_call(nullptr) {}
  ~xclImportBO_call() override;
  explicit PROTOBUF_CONSTEXPR xclImportBO_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclImportBO_call(const xclImportBO_call& from);
  xclImportBO_call(xclImportBO_call&& from) noexcept
    : xclImportBO_call() {
    *this = ::std::move(from);
  }

  inline xclImportBO_call& operator=(const xclImportBO_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclImportBO_call& operator=(xclImportBO_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclImportBO_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclImportBO_call* internal_default_instance() {
    return reinterpret_cast<const xclImportBO_call*>(
               &_xclImportBO_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(xclImportBO_call& a, xclImportBO_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclImportBO_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclImportBO_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclImportBO_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclImportBO_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclImportBO_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclImportBO_call& from) {
    xclImportBO_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclImportBO_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclImportBO_call";
  }
  protected:
  explicit xclImportBO_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstFilenameFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // optional string dst_filename = 1;
  bool has_dst_filename() const;
  private:
  bool _internal_has_dst_filename() const;
  public:
  void clear_dst_filename();
  const std::string& dst_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_filename();
  PROTOBUF_NODISCARD std::string* release_dst_filename();
  void set_allocated_dst_filename(std::string* dst_filename);
  private:
  const std::string& _internal_dst_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_filename(const std::string& value);
  std::string* _internal_mutable_dst_filename();
  public:

  // optional uint64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // optional uint64 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclImportBO_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_filename_;
    uint64_t offset_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclImportBO_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclImportBO_response) */ {
 public:
  inline xclImportBO_response() : xclImportBO_response(nullptr) {}
  ~xclImportBO_response() override;
  explicit PROTOBUF_CONSTEXPR xclImportBO_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclImportBO_response(const xclImportBO_response& from);
  xclImportBO_response(xclImportBO_response&& from) noexcept
    : xclImportBO_response() {
    *this = ::std::move(from);
  }

  inline xclImportBO_response& operator=(const xclImportBO_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclImportBO_response& operator=(xclImportBO_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclImportBO_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclImportBO_response* internal_default_instance() {
    return reinterpret_cast<const xclImportBO_response*>(
               &_xclImportBO_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(xclImportBO_response& a, xclImportBO_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclImportBO_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclImportBO_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclImportBO_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclImportBO_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclImportBO_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclImportBO_response& from) {
    xclImportBO_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclImportBO_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclImportBO_response";
  }
  protected:
  explicit xclImportBO_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclImportBO_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCopyBO_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCopyBO_call) */ {
 public:
  inline xclCopyBO_call() : xclCopyBO_call(nullptr) {}
  ~xclCopyBO_call() override;
  explicit PROTOBUF_CONSTEXPR xclCopyBO_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCopyBO_call(const xclCopyBO_call& from);
  xclCopyBO_call(xclCopyBO_call&& from) noexcept
    : xclCopyBO_call() {
    *this = ::std::move(from);
  }

  inline xclCopyBO_call& operator=(const xclCopyBO_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCopyBO_call& operator=(xclCopyBO_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCopyBO_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCopyBO_call* internal_default_instance() {
    return reinterpret_cast<const xclCopyBO_call*>(
               &_xclCopyBO_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(xclCopyBO_call& a, xclCopyBO_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCopyBO_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCopyBO_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCopyBO_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCopyBO_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCopyBO_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCopyBO_call& from) {
    xclCopyBO_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCopyBO_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCopyBO_call";
  }
  protected:
  explicit xclCopyBO_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstFilenameFieldNumber = 2,
    kSrcHandleFieldNumber = 1,
    kSizeFieldNumber = 3,
    kSrcOffsetFieldNumber = 4,
    kDstOffsetFieldNumber = 5,
  };
  // optional string dst_filename = 2;
  bool has_dst_filename() const;
  private:
  bool _internal_has_dst_filename() const;
  public:
  void clear_dst_filename();
  const std::string& dst_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_filename();
  PROTOBUF_NODISCARD std::string* release_dst_filename();
  void set_allocated_dst_filename(std::string* dst_filename);
  private:
  const std::string& _internal_dst_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_filename(const std::string& value);
  std::string* _internal_mutable_dst_filename();
  public:

  // optional uint64 src_handle = 1;
  bool has_src_handle() const;
  private:
  bool _internal_has_src_handle() const;
  public:
  void clear_src_handle();
  uint64_t src_handle() const;
  void set_src_handle(uint64_t value);
  private:
  uint64_t _internal_src_handle() const;
  void _internal_set_src_handle(uint64_t value);
  public:

  // optional uint64 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional uint64 src_offset = 4;
  bool has_src_offset() const;
  private:
  bool _internal_has_src_offset() const;
  public:
  void clear_src_offset();
  uint64_t src_offset() const;
  void set_src_offset(uint64_t value);
  private:
  uint64_t _internal_src_offset() const;
  void _internal_set_src_offset(uint64_t value);
  public:

  // optional uint64 dst_offset = 5;
  bool has_dst_offset() const;
  private:
  bool _internal_has_dst_offset() const;
  public:
  void clear_dst_offset();
  uint64_t dst_offset() const;
  void set_dst_offset(uint64_t value);
  private:
  uint64_t _internal_dst_offset() const;
  void _internal_set_dst_offset(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCopyBO_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_filename_;
    uint64_t src_handle_;
    uint64_t size_;
    uint64_t src_offset_;
    uint64_t dst_offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCopyBO_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCopyBO_response) */ {
 public:
  inline xclCopyBO_response() : xclCopyBO_response(nullptr) {}
  ~xclCopyBO_response() override;
  explicit PROTOBUF_CONSTEXPR xclCopyBO_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCopyBO_response(const xclCopyBO_response& from);
  xclCopyBO_response(xclCopyBO_response&& from) noexcept
    : xclCopyBO_response() {
    *this = ::std::move(from);
  }

  inline xclCopyBO_response& operator=(const xclCopyBO_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCopyBO_response& operator=(xclCopyBO_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCopyBO_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCopyBO_response* internal_default_instance() {
    return reinterpret_cast<const xclCopyBO_response*>(
               &_xclCopyBO_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(xclCopyBO_response& a, xclCopyBO_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCopyBO_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCopyBO_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCopyBO_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCopyBO_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCopyBO_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCopyBO_response& from) {
    xclCopyBO_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCopyBO_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCopyBO_response";
  }
  protected:
  explicit xclCopyBO_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclCopyBO_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCreateQueue_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCreateQueue_call) */ {
 public:
  inline xclCreateQueue_call() : xclCreateQueue_call(nullptr) {}
  ~xclCreateQueue_call() override;
  explicit PROTOBUF_CONSTEXPR xclCreateQueue_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCreateQueue_call(const xclCreateQueue_call& from);
  xclCreateQueue_call(xclCreateQueue_call&& from) noexcept
    : xclCreateQueue_call() {
    *this = ::std::move(from);
  }

  inline xclCreateQueue_call& operator=(const xclCreateQueue_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCreateQueue_call& operator=(xclCreateQueue_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCreateQueue_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCreateQueue_call* internal_default_instance() {
    return reinterpret_cast<const xclCreateQueue_call*>(
               &_xclCreateQueue_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(xclCreateQueue_call& a, xclCreateQueue_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCreateQueue_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCreateQueue_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCreateQueue_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCreateQueue_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCreateQueue_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCreateQueue_call& from) {
    xclCreateQueue_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCreateQueue_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCreateQueue_call";
  }
  protected:
  explicit xclCreateQueue_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWriteFieldNumber = 1,
    kTypeFieldNumber = 2,
    kStateFieldNumber = 3,
    kRouteFieldNumber = 4,
    kFlowFieldNumber = 5,
    kQsizeFieldNumber = 6,
    kDescSizeFieldNumber = 7,
    kFlagsFieldNumber = 8,
  };
  // optional bool write = 1;
  bool has_write() const;
  private:
  bool _internal_has_write() const;
  public:
  void clear_write();
  bool write() const;
  void set_write(bool value);
  private:
  bool _internal_write() const;
  void _internal_set_write(bool value);
  public:

  // optional uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  uint32_t state() const;
  void set_state(uint32_t value);
  private:
  uint32_t _internal_state() const;
  void _internal_set_state(uint32_t value);
  public:

  // optional uint32 route = 4;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  uint32_t route() const;
  void set_route(uint32_t value);
  private:
  uint32_t _internal_route() const;
  void _internal_set_route(uint32_t value);
  public:

  // optional uint64 flow = 5;
  bool has_flow() const;
  private:
  bool _internal_has_flow() const;
  public:
  void clear_flow();
  uint64_t flow() const;
  void set_flow(uint64_t value);
  private:
  uint64_t _internal_flow() const;
  void _internal_set_flow(uint64_t value);
  public:

  // optional uint32 qsize = 6;
  bool has_qsize() const;
  private:
  bool _internal_has_qsize() const;
  public:
  void clear_qsize();
  uint32_t qsize() const;
  void set_qsize(uint32_t value);
  private:
  uint32_t _internal_qsize() const;
  void _internal_set_qsize(uint32_t value);
  public:

  // optional uint32 desc_size = 7;
  bool has_desc_size() const;
  private:
  bool _internal_has_desc_size() const;
  public:
  void clear_desc_size();
  uint32_t desc_size() const;
  void set_desc_size(uint32_t value);
  private:
  uint32_t _internal_desc_size() const;
  void _internal_set_desc_size(uint32_t value);
  public:

  // optional uint64 flags = 8;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint64_t flags() const;
  void set_flags(uint64_t value);
  private:
  uint64_t _internal_flags() const;
  void _internal_set_flags(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCreateQueue_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool write_;
    uint32_t type_;
    uint32_t state_;
    uint32_t route_;
    uint64_t flow_;
    uint32_t qsize_;
    uint32_t desc_size_;
    uint64_t flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclCreateQueue_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclCreateQueue_response) */ {
 public:
  inline xclCreateQueue_response() : xclCreateQueue_response(nullptr) {}
  ~xclCreateQueue_response() override;
  explicit PROTOBUF_CONSTEXPR xclCreateQueue_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclCreateQueue_response(const xclCreateQueue_response& from);
  xclCreateQueue_response(xclCreateQueue_response&& from) noexcept
    : xclCreateQueue_response() {
    *this = ::std::move(from);
  }

  inline xclCreateQueue_response& operator=(const xclCreateQueue_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclCreateQueue_response& operator=(xclCreateQueue_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclCreateQueue_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclCreateQueue_response* internal_default_instance() {
    return reinterpret_cast<const xclCreateQueue_response*>(
               &_xclCreateQueue_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(xclCreateQueue_response& a, xclCreateQueue_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclCreateQueue_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclCreateQueue_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclCreateQueue_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclCreateQueue_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclCreateQueue_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclCreateQueue_response& from) {
    xclCreateQueue_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclCreateQueue_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclCreateQueue_response";
  }
  protected:
  explicit xclCreateQueue_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQHandleFieldNumber = 1,
  };
  // optional uint64 q_handle = 1;
  bool has_q_handle() const;
  private:
  bool _internal_has_q_handle() const;
  public:
  void clear_q_handle();
  uint64_t q_handle() const;
  void set_q_handle(uint64_t value);
  private:
  uint64_t _internal_q_handle() const;
  void _internal_set_q_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclCreateQueue_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t q_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteQueue_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteQueue_call) */ {
 public:
  inline xclWriteQueue_call() : xclWriteQueue_call(nullptr) {}
  ~xclWriteQueue_call() override;
  explicit PROTOBUF_CONSTEXPR xclWriteQueue_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteQueue_call(const xclWriteQueue_call& from);
  xclWriteQueue_call(xclWriteQueue_call&& from) noexcept
    : xclWriteQueue_call() {
    *this = ::std::move(from);
  }

  inline xclWriteQueue_call& operator=(const xclWriteQueue_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteQueue_call& operator=(xclWriteQueue_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteQueue_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteQueue_call* internal_default_instance() {
    return reinterpret_cast<const xclWriteQueue_call*>(
               &_xclWriteQueue_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(xclWriteQueue_call& a, xclWriteQueue_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteQueue_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteQueue_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteQueue_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteQueue_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteQueue_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteQueue_call& from) {
    xclWriteQueue_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteQueue_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteQueue_call";
  }
  protected:
  explicit xclWriteQueue_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 2,
    kQHandleFieldNumber = 1,
    kSizeFieldNumber = 3,
    kReqFieldNumber = 4,
    kNonblockingFieldNumber = 5,
    kEotFieldNumber = 6,
  };
  // optional bytes src = 2;
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // optional uint64 q_handle = 1;
  bool has_q_handle() const;
  private:
  bool _internal_has_q_handle() const;
  public:
  void clear_q_handle();
  uint64_t q_handle() const;
  void set_q_handle(uint64_t value);
  private:
  uint64_t _internal_q_handle() const;
  void _internal_set_q_handle(uint64_t value);
  public:

  // optional uint64 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional uint64 req = 4;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  uint64_t req() const;
  void set_req(uint64_t value);
  private:
  uint64_t _internal_req() const;
  void _internal_set_req(uint64_t value);
  public:

  // optional bool nonblocking = 5;
  bool has_nonblocking() const;
  private:
  bool _internal_has_nonblocking() const;
  public:
  void clear_nonblocking();
  bool nonblocking() const;
  void set_nonblocking(bool value);
  private:
  bool _internal_nonblocking() const;
  void _internal_set_nonblocking(bool value);
  public:

  // optional bool eot = 6;
  bool has_eot() const;
  private:
  bool _internal_has_eot() const;
  public:
  void clear_eot();
  bool eot() const;
  void set_eot(bool value);
  private:
  bool _internal_eot() const;
  void _internal_set_eot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteQueue_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    uint64_t q_handle_;
    uint64_t size_;
    uint64_t req_;
    bool nonblocking_;
    bool eot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclWriteQueue_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclWriteQueue_response) */ {
 public:
  inline xclWriteQueue_response() : xclWriteQueue_response(nullptr) {}
  ~xclWriteQueue_response() override;
  explicit PROTOBUF_CONSTEXPR xclWriteQueue_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclWriteQueue_response(const xclWriteQueue_response& from);
  xclWriteQueue_response(xclWriteQueue_response&& from) noexcept
    : xclWriteQueue_response() {
    *this = ::std::move(from);
  }

  inline xclWriteQueue_response& operator=(const xclWriteQueue_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclWriteQueue_response& operator=(xclWriteQueue_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclWriteQueue_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclWriteQueue_response* internal_default_instance() {
    return reinterpret_cast<const xclWriteQueue_response*>(
               &_xclWriteQueue_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(xclWriteQueue_response& a, xclWriteQueue_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclWriteQueue_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclWriteQueue_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclWriteQueue_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclWriteQueue_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclWriteQueue_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclWriteQueue_response& from) {
    xclWriteQueue_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclWriteQueue_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclWriteQueue_response";
  }
  protected:
  explicit xclWriteQueue_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWrittenSizeFieldNumber = 1,
  };
  // optional uint64 written_size = 1;
  bool has_written_size() const;
  private:
  bool _internal_has_written_size() const;
  public:
  void clear_written_size();
  uint64_t written_size() const;
  void set_written_size(uint64_t value);
  private:
  uint64_t _internal_written_size() const;
  void _internal_set_written_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclWriteQueue_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t written_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadQueue_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadQueue_call) */ {
 public:
  inline xclReadQueue_call() : xclReadQueue_call(nullptr) {}
  ~xclReadQueue_call() override;
  explicit PROTOBUF_CONSTEXPR xclReadQueue_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadQueue_call(const xclReadQueue_call& from);
  xclReadQueue_call(xclReadQueue_call&& from) noexcept
    : xclReadQueue_call() {
    *this = ::std::move(from);
  }

  inline xclReadQueue_call& operator=(const xclReadQueue_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadQueue_call& operator=(xclReadQueue_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadQueue_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadQueue_call* internal_default_instance() {
    return reinterpret_cast<const xclReadQueue_call*>(
               &_xclReadQueue_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(xclReadQueue_call& a, xclReadQueue_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadQueue_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadQueue_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadQueue_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadQueue_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadQueue_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadQueue_call& from) {
    xclReadQueue_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadQueue_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadQueue_call";
  }
  protected:
  explicit xclReadQueue_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 2,
    kQHandleFieldNumber = 1,
    kSizeFieldNumber = 3,
    kReqFieldNumber = 4,
    kNonblockingFieldNumber = 5,
    kEotFieldNumber = 6,
  };
  // optional bytes dest = 2;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const std::string& dest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // optional uint64 q_handle = 1;
  bool has_q_handle() const;
  private:
  bool _internal_has_q_handle() const;
  public:
  void clear_q_handle();
  uint64_t q_handle() const;
  void set_q_handle(uint64_t value);
  private:
  uint64_t _internal_q_handle() const;
  void _internal_set_q_handle(uint64_t value);
  public:

  // optional uint64 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional uint64 req = 4;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  uint64_t req() const;
  void set_req(uint64_t value);
  private:
  uint64_t _internal_req() const;
  void _internal_set_req(uint64_t value);
  public:

  // optional bool nonblocking = 5;
  bool has_nonblocking() const;
  private:
  bool _internal_has_nonblocking() const;
  public:
  void clear_nonblocking();
  bool nonblocking() const;
  void set_nonblocking(bool value);
  private:
  bool _internal_nonblocking() const;
  void _internal_set_nonblocking(bool value);
  public:

  // optional bool eot = 6;
  bool has_eot() const;
  private:
  bool _internal_has_eot() const;
  public:
  void clear_eot();
  bool eot() const;
  void set_eot(bool value);
  private:
  bool _internal_eot() const;
  void _internal_set_eot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadQueue_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
    uint64_t q_handle_;
    uint64_t size_;
    uint64_t req_;
    bool nonblocking_;
    bool eot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclReadQueue_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclReadQueue_response) */ {
 public:
  inline xclReadQueue_response() : xclReadQueue_response(nullptr) {}
  ~xclReadQueue_response() override;
  explicit PROTOBUF_CONSTEXPR xclReadQueue_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclReadQueue_response(const xclReadQueue_response& from);
  xclReadQueue_response(xclReadQueue_response&& from) noexcept
    : xclReadQueue_response() {
    *this = ::std::move(from);
  }

  inline xclReadQueue_response& operator=(const xclReadQueue_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclReadQueue_response& operator=(xclReadQueue_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclReadQueue_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclReadQueue_response* internal_default_instance() {
    return reinterpret_cast<const xclReadQueue_response*>(
               &_xclReadQueue_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(xclReadQueue_response& a, xclReadQueue_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclReadQueue_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclReadQueue_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclReadQueue_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclReadQueue_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclReadQueue_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclReadQueue_response& from) {
    xclReadQueue_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclReadQueue_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclReadQueue_response";
  }
  protected:
  explicit xclReadQueue_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // optional bytes dest = 1;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const std::string& dest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // optional uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclReadQueue_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPollCompletion_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPollCompletion_call) */ {
 public:
  inline xclPollCompletion_call() : xclPollCompletion_call(nullptr) {}
  ~xclPollCompletion_call() override;
  explicit PROTOBUF_CONSTEXPR xclPollCompletion_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPollCompletion_call(const xclPollCompletion_call& from);
  xclPollCompletion_call(xclPollCompletion_call&& from) noexcept
    : xclPollCompletion_call() {
    *this = ::std::move(from);
  }

  inline xclPollCompletion_call& operator=(const xclPollCompletion_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPollCompletion_call& operator=(xclPollCompletion_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPollCompletion_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPollCompletion_call* internal_default_instance() {
    return reinterpret_cast<const xclPollCompletion_call*>(
               &_xclPollCompletion_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(xclPollCompletion_call& a, xclPollCompletion_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPollCompletion_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPollCompletion_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPollCompletion_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPollCompletion_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPollCompletion_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPollCompletion_call& from) {
    xclPollCompletion_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPollCompletion_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPollCompletion_call";
  }
  protected:
  explicit xclPollCompletion_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // optional uint64 req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  uint64_t req() const;
  void set_req(uint64_t value);
  private:
  uint64_t _internal_req() const;
  void _internal_set_req(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPollCompletion_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t req_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPollCompletion_response_request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPollCompletion_response.request) */ {
 public:
  inline xclPollCompletion_response_request() : xclPollCompletion_response_request(nullptr) {}
  ~xclPollCompletion_response_request() override;
  explicit PROTOBUF_CONSTEXPR xclPollCompletion_response_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPollCompletion_response_request(const xclPollCompletion_response_request& from);
  xclPollCompletion_response_request(xclPollCompletion_response_request&& from) noexcept
    : xclPollCompletion_response_request() {
    *this = ::std::move(from);
  }

  inline xclPollCompletion_response_request& operator=(const xclPollCompletion_response_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPollCompletion_response_request& operator=(xclPollCompletion_response_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPollCompletion_response_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPollCompletion_response_request* internal_default_instance() {
    return reinterpret_cast<const xclPollCompletion_response_request*>(
               &_xclPollCompletion_response_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(xclPollCompletion_response_request& a, xclPollCompletion_response_request& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPollCompletion_response_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPollCompletion_response_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPollCompletion_response_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPollCompletion_response_request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPollCompletion_response_request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPollCompletion_response_request& from) {
    xclPollCompletion_response_request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPollCompletion_response_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPollCompletion_response.request";
  }
  protected:
  explicit xclPollCompletion_response_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // optional bytes dest = 1;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const std::string& dest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // optional uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPollCompletion_response.request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPollCompletion_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPollCompletion_response) */ {
 public:
  inline xclPollCompletion_response() : xclPollCompletion_response(nullptr) {}
  ~xclPollCompletion_response() override;
  explicit PROTOBUF_CONSTEXPR xclPollCompletion_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPollCompletion_response(const xclPollCompletion_response& from);
  xclPollCompletion_response(xclPollCompletion_response&& from) noexcept
    : xclPollCompletion_response() {
    *this = ::std::move(from);
  }

  inline xclPollCompletion_response& operator=(const xclPollCompletion_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPollCompletion_response& operator=(xclPollCompletion_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPollCompletion_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPollCompletion_response* internal_default_instance() {
    return reinterpret_cast<const xclPollCompletion_response*>(
               &_xclPollCompletion_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(xclPollCompletion_response& a, xclPollCompletion_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPollCompletion_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPollCompletion_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPollCompletion_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPollCompletion_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPollCompletion_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPollCompletion_response& from) {
    xclPollCompletion_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPollCompletion_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPollCompletion_response";
  }
  protected:
  explicit xclPollCompletion_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclPollCompletion_response_request request;

  // accessors -------------------------------------------------------

  enum : int {
    kFullrequestFieldNumber = 3,
  };
  // repeated .xclPollCompletion_response.request fullrequest = 3;
  int fullrequest_size() const;
  private:
  int _internal_fullrequest_size() const;
  public:
  void clear_fullrequest();
  ::xclPollCompletion_response_request* mutable_fullrequest(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPollCompletion_response_request >*
      mutable_fullrequest();
  private:
  const ::xclPollCompletion_response_request& _internal_fullrequest(int index) const;
  ::xclPollCompletion_response_request* _internal_add_fullrequest();
  public:
  const ::xclPollCompletion_response_request& fullrequest(int index) const;
  ::xclPollCompletion_response_request* add_fullrequest();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPollCompletion_response_request >&
      fullrequest() const;

  // @@protoc_insertion_point(class_scope:xclPollCompletion_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPollCompletion_response_request > fullrequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclDestroyQueue_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclDestroyQueue_call) */ {
 public:
  inline xclDestroyQueue_call() : xclDestroyQueue_call(nullptr) {}
  ~xclDestroyQueue_call() override;
  explicit PROTOBUF_CONSTEXPR xclDestroyQueue_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclDestroyQueue_call(const xclDestroyQueue_call& from);
  xclDestroyQueue_call(xclDestroyQueue_call&& from) noexcept
    : xclDestroyQueue_call() {
    *this = ::std::move(from);
  }

  inline xclDestroyQueue_call& operator=(const xclDestroyQueue_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclDestroyQueue_call& operator=(xclDestroyQueue_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclDestroyQueue_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclDestroyQueue_call* internal_default_instance() {
    return reinterpret_cast<const xclDestroyQueue_call*>(
               &_xclDestroyQueue_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(xclDestroyQueue_call& a, xclDestroyQueue_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclDestroyQueue_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclDestroyQueue_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclDestroyQueue_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclDestroyQueue_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclDestroyQueue_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclDestroyQueue_call& from) {
    xclDestroyQueue_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclDestroyQueue_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclDestroyQueue_call";
  }
  protected:
  explicit xclDestroyQueue_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQHandleFieldNumber = 1,
  };
  // optional uint64 q_handle = 1;
  bool has_q_handle() const;
  private:
  bool _internal_has_q_handle() const;
  public:
  void clear_q_handle();
  uint64_t q_handle() const;
  void set_q_handle(uint64_t value);
  private:
  uint64_t _internal_q_handle() const;
  void _internal_set_q_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclDestroyQueue_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t q_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclDestroyQueue_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclDestroyQueue_response) */ {
 public:
  inline xclDestroyQueue_response() : xclDestroyQueue_response(nullptr) {}
  ~xclDestroyQueue_response() override;
  explicit PROTOBUF_CONSTEXPR xclDestroyQueue_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclDestroyQueue_response(const xclDestroyQueue_response& from);
  xclDestroyQueue_response(xclDestroyQueue_response&& from) noexcept
    : xclDestroyQueue_response() {
    *this = ::std::move(from);
  }

  inline xclDestroyQueue_response& operator=(const xclDestroyQueue_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclDestroyQueue_response& operator=(xclDestroyQueue_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclDestroyQueue_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclDestroyQueue_response* internal_default_instance() {
    return reinterpret_cast<const xclDestroyQueue_response*>(
               &_xclDestroyQueue_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(xclDestroyQueue_response& a, xclDestroyQueue_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclDestroyQueue_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclDestroyQueue_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclDestroyQueue_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclDestroyQueue_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclDestroyQueue_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclDestroyQueue_response& from) {
    xclDestroyQueue_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclDestroyQueue_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclDestroyQueue_response";
  }
  protected:
  explicit xclDestroyQueue_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclDestroyQueue_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSetupInstance_call_argflowpair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSetupInstance_call.argflowpair) */ {
 public:
  inline xclSetupInstance_call_argflowpair() : xclSetupInstance_call_argflowpair(nullptr) {}
  ~xclSetupInstance_call_argflowpair() override;
  explicit PROTOBUF_CONSTEXPR xclSetupInstance_call_argflowpair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSetupInstance_call_argflowpair(const xclSetupInstance_call_argflowpair& from);
  xclSetupInstance_call_argflowpair(xclSetupInstance_call_argflowpair&& from) noexcept
    : xclSetupInstance_call_argflowpair() {
    *this = ::std::move(from);
  }

  inline xclSetupInstance_call_argflowpair& operator=(const xclSetupInstance_call_argflowpair& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSetupInstance_call_argflowpair& operator=(xclSetupInstance_call_argflowpair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSetupInstance_call_argflowpair& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSetupInstance_call_argflowpair* internal_default_instance() {
    return reinterpret_cast<const xclSetupInstance_call_argflowpair*>(
               &_xclSetupInstance_call_argflowpair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(xclSetupInstance_call_argflowpair& a, xclSetupInstance_call_argflowpair& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSetupInstance_call_argflowpair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSetupInstance_call_argflowpair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSetupInstance_call_argflowpair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSetupInstance_call_argflowpair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSetupInstance_call_argflowpair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSetupInstance_call_argflowpair& from) {
    xclSetupInstance_call_argflowpair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSetupInstance_call_argflowpair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSetupInstance_call.argflowpair";
  }
  protected:
  explicit xclSetupInstance_call_argflowpair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 4,
    kArgFieldNumber = 2,
    kFlowFieldNumber = 3,
  };
  // optional string tag = 4;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional uint64 arg = 2;
  bool has_arg() const;
  private:
  bool _internal_has_arg() const;
  public:
  void clear_arg();
  uint64_t arg() const;
  void set_arg(uint64_t value);
  private:
  uint64_t _internal_arg() const;
  void _internal_set_arg(uint64_t value);
  public:

  // optional uint64 flow = 3;
  bool has_flow() const;
  private:
  bool _internal_has_flow() const;
  public:
  void clear_flow();
  uint64_t flow() const;
  void set_flow(uint64_t value);
  private:
  uint64_t _internal_flow() const;
  void _internal_set_flow(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclSetupInstance_call.argflowpair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    uint64_t arg_;
    uint64_t flow_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSetupInstance_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSetupInstance_call) */ {
 public:
  inline xclSetupInstance_call() : xclSetupInstance_call(nullptr) {}
  ~xclSetupInstance_call() override;
  explicit PROTOBUF_CONSTEXPR xclSetupInstance_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSetupInstance_call(const xclSetupInstance_call& from);
  xclSetupInstance_call(xclSetupInstance_call&& from) noexcept
    : xclSetupInstance_call() {
    *this = ::std::move(from);
  }

  inline xclSetupInstance_call& operator=(const xclSetupInstance_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSetupInstance_call& operator=(xclSetupInstance_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSetupInstance_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSetupInstance_call* internal_default_instance() {
    return reinterpret_cast<const xclSetupInstance_call*>(
               &_xclSetupInstance_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(xclSetupInstance_call& a, xclSetupInstance_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSetupInstance_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSetupInstance_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSetupInstance_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSetupInstance_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSetupInstance_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSetupInstance_call& from) {
    xclSetupInstance_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSetupInstance_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSetupInstance_call";
  }
  protected:
  explicit xclSetupInstance_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclSetupInstance_call_argflowpair argflowpair;

  // accessors -------------------------------------------------------

  enum : int {
    kSetupFieldNumber = 5,
    kRouteFieldNumber = 1,
  };
  // repeated .xclSetupInstance_call.argflowpair setup = 5;
  int setup_size() const;
  private:
  int _internal_setup_size() const;
  public:
  void clear_setup();
  ::xclSetupInstance_call_argflowpair* mutable_setup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetupInstance_call_argflowpair >*
      mutable_setup();
  private:
  const ::xclSetupInstance_call_argflowpair& _internal_setup(int index) const;
  ::xclSetupInstance_call_argflowpair* _internal_add_setup();
  public:
  const ::xclSetupInstance_call_argflowpair& setup(int index) const;
  ::xclSetupInstance_call_argflowpair* add_setup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetupInstance_call_argflowpair >&
      setup() const;

  // optional uint64 route = 1;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  uint64_t route() const;
  void set_route(uint64_t value);
  private:
  uint64_t _internal_route() const;
  void _internal_set_route(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclSetupInstance_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetupInstance_call_argflowpair > setup_;
    uint64_t route_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSetupInstance_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSetupInstance_response) */ {
 public:
  inline xclSetupInstance_response() : xclSetupInstance_response(nullptr) {}
  ~xclSetupInstance_response() override;
  explicit PROTOBUF_CONSTEXPR xclSetupInstance_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSetupInstance_response(const xclSetupInstance_response& from);
  xclSetupInstance_response(xclSetupInstance_response&& from) noexcept
    : xclSetupInstance_response() {
    *this = ::std::move(from);
  }

  inline xclSetupInstance_response& operator=(const xclSetupInstance_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSetupInstance_response& operator=(xclSetupInstance_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSetupInstance_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSetupInstance_response* internal_default_instance() {
    return reinterpret_cast<const xclSetupInstance_response*>(
               &_xclSetupInstance_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(xclSetupInstance_response& a, xclSetupInstance_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSetupInstance_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSetupInstance_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSetupInstance_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSetupInstance_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSetupInstance_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSetupInstance_response& from) {
    xclSetupInstance_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSetupInstance_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSetupInstance_response";
  }
  protected:
  explicit xclSetupInstance_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclSetupInstance_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadCounters_Streaming_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadCounters_Streaming_call) */ {
 public:
  inline xclPerfMonReadCounters_Streaming_call() : xclPerfMonReadCounters_Streaming_call(nullptr) {}
  ~xclPerfMonReadCounters_Streaming_call() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadCounters_Streaming_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadCounters_Streaming_call(const xclPerfMonReadCounters_Streaming_call& from);
  xclPerfMonReadCounters_Streaming_call(xclPerfMonReadCounters_Streaming_call&& from) noexcept
    : xclPerfMonReadCounters_Streaming_call() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadCounters_Streaming_call& operator=(const xclPerfMonReadCounters_Streaming_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadCounters_Streaming_call& operator=(xclPerfMonReadCounters_Streaming_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadCounters_Streaming_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadCounters_Streaming_call* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadCounters_Streaming_call*>(
               &_xclPerfMonReadCounters_Streaming_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(xclPerfMonReadCounters_Streaming_call& a, xclPerfMonReadCounters_Streaming_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadCounters_Streaming_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadCounters_Streaming_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadCounters_Streaming_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadCounters_Streaming_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadCounters_Streaming_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadCounters_Streaming_call& from) {
    xclPerfMonReadCounters_Streaming_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadCounters_Streaming_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadCounters_Streaming_call";
  }
  protected:
  explicit xclPerfMonReadCounters_Streaming_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotnameFieldNumber = 1,
  };
  // required string slotname = 1;
  bool has_slotname() const;
  private:
  bool _internal_has_slotname() const;
  public:
  void clear_slotname();
  const std::string& slotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slotname();
  PROTOBUF_NODISCARD std::string* release_slotname();
  void set_allocated_slotname(std::string* slotname);
  private:
  const std::string& _internal_slotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotname(const std::string& value);
  std::string* _internal_mutable_slotname();
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadCounters_Streaming_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slotname_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadCounters_Streaming_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadCounters_Streaming_response) */ {
 public:
  inline xclPerfMonReadCounters_Streaming_response() : xclPerfMonReadCounters_Streaming_response(nullptr) {}
  ~xclPerfMonReadCounters_Streaming_response() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadCounters_Streaming_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadCounters_Streaming_response(const xclPerfMonReadCounters_Streaming_response& from);
  xclPerfMonReadCounters_Streaming_response(xclPerfMonReadCounters_Streaming_response&& from) noexcept
    : xclPerfMonReadCounters_Streaming_response() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadCounters_Streaming_response& operator=(const xclPerfMonReadCounters_Streaming_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadCounters_Streaming_response& operator=(xclPerfMonReadCounters_Streaming_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadCounters_Streaming_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadCounters_Streaming_response* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadCounters_Streaming_response*>(
               &_xclPerfMonReadCounters_Streaming_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(xclPerfMonReadCounters_Streaming_response& a, xclPerfMonReadCounters_Streaming_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadCounters_Streaming_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadCounters_Streaming_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadCounters_Streaming_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadCounters_Streaming_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadCounters_Streaming_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadCounters_Streaming_response& from) {
    xclPerfMonReadCounters_Streaming_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadCounters_Streaming_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadCounters_Streaming_response";
  }
  protected:
  explicit xclPerfMonReadCounters_Streaming_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrNumTranxFieldNumber = 7,
    kStrDataBytesFieldNumber = 8,
    kStrBusyCyclesFieldNumber = 9,
    kStrStallCyclesFieldNumber = 10,
    kStrStarveCyclesFieldNumber = 11,
  };
  // optional uint64 str_num_tranx = 7;
  bool has_str_num_tranx() const;
  private:
  bool _internal_has_str_num_tranx() const;
  public:
  void clear_str_num_tranx();
  uint64_t str_num_tranx() const;
  void set_str_num_tranx(uint64_t value);
  private:
  uint64_t _internal_str_num_tranx() const;
  void _internal_set_str_num_tranx(uint64_t value);
  public:

  // optional uint64 str_data_bytes = 8;
  bool has_str_data_bytes() const;
  private:
  bool _internal_has_str_data_bytes() const;
  public:
  void clear_str_data_bytes();
  uint64_t str_data_bytes() const;
  void set_str_data_bytes(uint64_t value);
  private:
  uint64_t _internal_str_data_bytes() const;
  void _internal_set_str_data_bytes(uint64_t value);
  public:

  // optional uint64 str_busy_cycles = 9;
  bool has_str_busy_cycles() const;
  private:
  bool _internal_has_str_busy_cycles() const;
  public:
  void clear_str_busy_cycles();
  uint64_t str_busy_cycles() const;
  void set_str_busy_cycles(uint64_t value);
  private:
  uint64_t _internal_str_busy_cycles() const;
  void _internal_set_str_busy_cycles(uint64_t value);
  public:

  // optional uint64 str_stall_cycles = 10;
  bool has_str_stall_cycles() const;
  private:
  bool _internal_has_str_stall_cycles() const;
  public:
  void clear_str_stall_cycles();
  uint64_t str_stall_cycles() const;
  void set_str_stall_cycles(uint64_t value);
  private:
  uint64_t _internal_str_stall_cycles() const;
  void _internal_set_str_stall_cycles(uint64_t value);
  public:

  // optional uint64 str_starve_cycles = 11;
  bool has_str_starve_cycles() const;
  private:
  bool _internal_has_str_starve_cycles() const;
  public:
  void clear_str_starve_cycles();
  uint64_t str_starve_cycles() const;
  void set_str_starve_cycles(uint64_t value);
  private:
  uint64_t _internal_str_starve_cycles() const;
  void _internal_set_str_starve_cycles(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadCounters_Streaming_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t str_num_tranx_;
    uint64_t str_data_bytes_;
    uint64_t str_busy_cycles_;
    uint64_t str_stall_cycles_;
    uint64_t str_starve_cycles_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadTrace_Streaming_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadTrace_Streaming_call) */ {
 public:
  inline xclPerfMonReadTrace_Streaming_call() : xclPerfMonReadTrace_Streaming_call(nullptr) {}
  ~xclPerfMonReadTrace_Streaming_call() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadTrace_Streaming_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadTrace_Streaming_call(const xclPerfMonReadTrace_Streaming_call& from);
  xclPerfMonReadTrace_Streaming_call(xclPerfMonReadTrace_Streaming_call&& from) noexcept
    : xclPerfMonReadTrace_Streaming_call() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadTrace_Streaming_call& operator=(const xclPerfMonReadTrace_Streaming_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadTrace_Streaming_call& operator=(xclPerfMonReadTrace_Streaming_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadTrace_Streaming_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadTrace_Streaming_call* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadTrace_Streaming_call*>(
               &_xclPerfMonReadTrace_Streaming_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(xclPerfMonReadTrace_Streaming_call& a, xclPerfMonReadTrace_Streaming_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadTrace_Streaming_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadTrace_Streaming_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadTrace_Streaming_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadTrace_Streaming_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadTrace_Streaming_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadTrace_Streaming_call& from) {
    xclPerfMonReadTrace_Streaming_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadTrace_Streaming_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadTrace_Streaming_call";
  }
  protected:
  explicit xclPerfMonReadTrace_Streaming_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotnameFieldNumber = 2,
    kAckFieldNumber = 1,
  };
  // optional string slotname = 2;
  bool has_slotname() const;
  private:
  bool _internal_has_slotname() const;
  public:
  void clear_slotname();
  const std::string& slotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slotname();
  PROTOBUF_NODISCARD std::string* release_slotname();
  void set_allocated_slotname(std::string* slotname);
  private:
  const std::string& _internal_slotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotname(const std::string& value);
  std::string* _internal_mutable_slotname();
  public:

  // optional bool ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadTrace_Streaming_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slotname_;
    bool ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadTrace_Streaming_response_events final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadTrace_Streaming_response.events) */ {
 public:
  inline xclPerfMonReadTrace_Streaming_response_events() : xclPerfMonReadTrace_Streaming_response_events(nullptr) {}
  ~xclPerfMonReadTrace_Streaming_response_events() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadTrace_Streaming_response_events(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadTrace_Streaming_response_events(const xclPerfMonReadTrace_Streaming_response_events& from);
  xclPerfMonReadTrace_Streaming_response_events(xclPerfMonReadTrace_Streaming_response_events&& from) noexcept
    : xclPerfMonReadTrace_Streaming_response_events() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadTrace_Streaming_response_events& operator=(const xclPerfMonReadTrace_Streaming_response_events& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadTrace_Streaming_response_events& operator=(xclPerfMonReadTrace_Streaming_response_events&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadTrace_Streaming_response_events& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadTrace_Streaming_response_events* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadTrace_Streaming_response_events*>(
               &_xclPerfMonReadTrace_Streaming_response_events_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(xclPerfMonReadTrace_Streaming_response_events& a, xclPerfMonReadTrace_Streaming_response_events& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadTrace_Streaming_response_events* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadTrace_Streaming_response_events* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadTrace_Streaming_response_events* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadTrace_Streaming_response_events>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadTrace_Streaming_response_events& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadTrace_Streaming_response_events& from) {
    xclPerfMonReadTrace_Streaming_response_events::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadTrace_Streaming_response_events* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadTrace_Streaming_response.events";
  }
  protected:
  explicit xclPerfMonReadTrace_Streaming_response_events(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventflagsFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kHostTimestampFieldNumber = 5,
  };
  // optional uint32 eventflags = 3;
  bool has_eventflags() const;
  private:
  bool _internal_has_eventflags() const;
  public:
  void clear_eventflags();
  uint32_t eventflags() const;
  void set_eventflags(uint32_t value);
  private:
  uint32_t _internal_eventflags() const;
  void _internal_set_eventflags(uint32_t value);
  public:

  // optional uint32 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional uint64 host_timestamp = 5;
  bool has_host_timestamp() const;
  private:
  bool _internal_has_host_timestamp() const;
  public:
  void clear_host_timestamp();
  uint64_t host_timestamp() const;
  void set_host_timestamp(uint64_t value);
  private:
  uint64_t _internal_host_timestamp() const;
  void _internal_set_host_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPerfMonReadTrace_Streaming_response.events)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t eventflags_;
    uint32_t timestamp_;
    uint64_t host_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPerfMonReadTrace_Streaming_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPerfMonReadTrace_Streaming_response) */ {
 public:
  inline xclPerfMonReadTrace_Streaming_response() : xclPerfMonReadTrace_Streaming_response(nullptr) {}
  ~xclPerfMonReadTrace_Streaming_response() override;
  explicit PROTOBUF_CONSTEXPR xclPerfMonReadTrace_Streaming_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPerfMonReadTrace_Streaming_response(const xclPerfMonReadTrace_Streaming_response& from);
  xclPerfMonReadTrace_Streaming_response(xclPerfMonReadTrace_Streaming_response&& from) noexcept
    : xclPerfMonReadTrace_Streaming_response() {
    *this = ::std::move(from);
  }

  inline xclPerfMonReadTrace_Streaming_response& operator=(const xclPerfMonReadTrace_Streaming_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPerfMonReadTrace_Streaming_response& operator=(xclPerfMonReadTrace_Streaming_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPerfMonReadTrace_Streaming_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPerfMonReadTrace_Streaming_response* internal_default_instance() {
    return reinterpret_cast<const xclPerfMonReadTrace_Streaming_response*>(
               &_xclPerfMonReadTrace_Streaming_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(xclPerfMonReadTrace_Streaming_response& a, xclPerfMonReadTrace_Streaming_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPerfMonReadTrace_Streaming_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPerfMonReadTrace_Streaming_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPerfMonReadTrace_Streaming_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPerfMonReadTrace_Streaming_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPerfMonReadTrace_Streaming_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPerfMonReadTrace_Streaming_response& from) {
    xclPerfMonReadTrace_Streaming_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPerfMonReadTrace_Streaming_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPerfMonReadTrace_Streaming_response";
  }
  protected:
  explicit xclPerfMonReadTrace_Streaming_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclPerfMonReadTrace_Streaming_response_events events;

  // accessors -------------------------------------------------------

  enum : int {
    kOutputDataFieldNumber = 8,
  };
  // repeated .xclPerfMonReadTrace_Streaming_response.events output_data = 8;
  int output_data_size() const;
  private:
  int _internal_output_data_size() const;
  public:
  void clear_output_data();
  ::xclPerfMonReadTrace_Streaming_response_events* mutable_output_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_Streaming_response_events >*
      mutable_output_data();
  private:
  const ::xclPerfMonReadTrace_Streaming_response_events& _internal_output_data(int index) const;
  ::xclPerfMonReadTrace_Streaming_response_events* _internal_add_output_data();
  public:
  const ::xclPerfMonReadTrace_Streaming_response_events& output_data(int index) const;
  ::xclPerfMonReadTrace_Streaming_response_events* add_output_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_Streaming_response_events >&
      output_data() const;

  // @@protoc_insertion_point(class_scope:xclPerfMonReadTrace_Streaming_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_Streaming_response_events > output_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSlaveReadReq_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSlaveReadReq_call) */ {
 public:
  inline xclSlaveReadReq_call() : xclSlaveReadReq_call(nullptr) {}
  ~xclSlaveReadReq_call() override;
  explicit PROTOBUF_CONSTEXPR xclSlaveReadReq_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSlaveReadReq_call(const xclSlaveReadReq_call& from);
  xclSlaveReadReq_call(xclSlaveReadReq_call&& from) noexcept
    : xclSlaveReadReq_call() {
    *this = ::std::move(from);
  }

  inline xclSlaveReadReq_call& operator=(const xclSlaveReadReq_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSlaveReadReq_call& operator=(xclSlaveReadReq_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSlaveReadReq_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSlaveReadReq_call* internal_default_instance() {
    return reinterpret_cast<const xclSlaveReadReq_call*>(
               &_xclSlaveReadReq_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(xclSlaveReadReq_call& a, xclSlaveReadReq_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSlaveReadReq_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSlaveReadReq_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSlaveReadReq_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSlaveReadReq_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSlaveReadReq_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSlaveReadReq_call& from) {
    xclSlaveReadReq_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSlaveReadReq_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSlaveReadReq_call";
  }
  protected:
  explicit xclSlaveReadReq_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required uint64 addr = 1;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // required uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclSlaveReadReq_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t addr_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSlaveReadReq_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSlaveReadReq_response) */ {
 public:
  inline xclSlaveReadReq_response() : xclSlaveReadReq_response(nullptr) {}
  ~xclSlaveReadReq_response() override;
  explicit PROTOBUF_CONSTEXPR xclSlaveReadReq_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSlaveReadReq_response(const xclSlaveReadReq_response& from);
  xclSlaveReadReq_response(xclSlaveReadReq_response&& from) noexcept
    : xclSlaveReadReq_response() {
    *this = ::std::move(from);
  }

  inline xclSlaveReadReq_response& operator=(const xclSlaveReadReq_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSlaveReadReq_response& operator=(xclSlaveReadReq_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSlaveReadReq_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSlaveReadReq_response* internal_default_instance() {
    return reinterpret_cast<const xclSlaveReadReq_response*>(
               &_xclSlaveReadReq_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(xclSlaveReadReq_response& a, xclSlaveReadReq_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSlaveReadReq_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSlaveReadReq_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSlaveReadReq_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSlaveReadReq_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSlaveReadReq_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSlaveReadReq_response& from) {
    xclSlaveReadReq_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSlaveReadReq_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSlaveReadReq_response";
  }
  protected:
  explicit xclSlaveReadReq_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kValidFieldNumber = 1,
  };
  // required bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclSlaveReadReq_response)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSlaveWriteReq_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSlaveWriteReq_call) */ {
 public:
  inline xclSlaveWriteReq_call() : xclSlaveWriteReq_call(nullptr) {}
  ~xclSlaveWriteReq_call() override;
  explicit PROTOBUF_CONSTEXPR xclSlaveWriteReq_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSlaveWriteReq_call(const xclSlaveWriteReq_call& from);
  xclSlaveWriteReq_call(xclSlaveWriteReq_call&& from) noexcept
    : xclSlaveWriteReq_call() {
    *this = ::std::move(from);
  }

  inline xclSlaveWriteReq_call& operator=(const xclSlaveWriteReq_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSlaveWriteReq_call& operator=(xclSlaveWriteReq_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSlaveWriteReq_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSlaveWriteReq_call* internal_default_instance() {
    return reinterpret_cast<const xclSlaveWriteReq_call*>(
               &_xclSlaveWriteReq_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(xclSlaveWriteReq_call& a, xclSlaveWriteReq_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSlaveWriteReq_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSlaveWriteReq_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSlaveWriteReq_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSlaveWriteReq_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSlaveWriteReq_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSlaveWriteReq_call& from) {
    xclSlaveWriteReq_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSlaveWriteReq_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSlaveWriteReq_call";
  }
  protected:
  explicit xclSlaveWriteReq_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kAddrFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required uint64 addr = 1;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  uint64_t addr() const;
  void set_addr(uint64_t value);
  private:
  uint64_t _internal_addr() const;
  void _internal_set_addr(uint64_t value);
  public:

  // required uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclSlaveWriteReq_call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t addr_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclSlaveWriteReq_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclSlaveWriteReq_response) */ {
 public:
  inline xclSlaveWriteReq_response() : xclSlaveWriteReq_response(nullptr) {}
  ~xclSlaveWriteReq_response() override;
  explicit PROTOBUF_CONSTEXPR xclSlaveWriteReq_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclSlaveWriteReq_response(const xclSlaveWriteReq_response& from);
  xclSlaveWriteReq_response(xclSlaveWriteReq_response&& from) noexcept
    : xclSlaveWriteReq_response() {
    *this = ::std::move(from);
  }

  inline xclSlaveWriteReq_response& operator=(const xclSlaveWriteReq_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclSlaveWriteReq_response& operator=(xclSlaveWriteReq_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclSlaveWriteReq_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclSlaveWriteReq_response* internal_default_instance() {
    return reinterpret_cast<const xclSlaveWriteReq_response*>(
               &_xclSlaveWriteReq_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(xclSlaveWriteReq_response& a, xclSlaveWriteReq_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclSlaveWriteReq_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclSlaveWriteReq_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclSlaveWriteReq_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclSlaveWriteReq_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclSlaveWriteReq_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclSlaveWriteReq_response& from) {
    xclSlaveWriteReq_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclSlaveWriteReq_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclSlaveWriteReq_response";
  }
  protected:
  explicit xclSlaveWriteReq_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclSlaveWriteReq_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclInterruptOccured_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclInterruptOccured_call) */ {
 public:
  inline xclInterruptOccured_call() : xclInterruptOccured_call(nullptr) {}
  ~xclInterruptOccured_call() override;
  explicit PROTOBUF_CONSTEXPR xclInterruptOccured_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclInterruptOccured_call(const xclInterruptOccured_call& from);
  xclInterruptOccured_call(xclInterruptOccured_call&& from) noexcept
    : xclInterruptOccured_call() {
    *this = ::std::move(from);
  }

  inline xclInterruptOccured_call& operator=(const xclInterruptOccured_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclInterruptOccured_call& operator=(xclInterruptOccured_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclInterruptOccured_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclInterruptOccured_call* internal_default_instance() {
    return reinterpret_cast<const xclInterruptOccured_call*>(
               &_xclInterruptOccured_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(xclInterruptOccured_call& a, xclInterruptOccured_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclInterruptOccured_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclInterruptOccured_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclInterruptOccured_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclInterruptOccured_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclInterruptOccured_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclInterruptOccured_call& from) {
    xclInterruptOccured_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclInterruptOccured_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclInterruptOccured_call";
  }
  protected:
  explicit xclInterruptOccured_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterruptLineFieldNumber = 1,
  };
  // required uint32 interrupt_line = 1;
  bool has_interrupt_line() const;
  private:
  bool _internal_has_interrupt_line() const;
  public:
  void clear_interrupt_line();
  uint32_t interrupt_line() const;
  void set_interrupt_line(uint32_t value);
  private:
  uint32_t _internal_interrupt_line() const;
  void _internal_set_interrupt_line(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclInterruptOccured_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t interrupt_line_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclInterruptOccured_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclInterruptOccured_response) */ {
 public:
  inline xclInterruptOccured_response() : xclInterruptOccured_response(nullptr) {}
  ~xclInterruptOccured_response() override;
  explicit PROTOBUF_CONSTEXPR xclInterruptOccured_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclInterruptOccured_response(const xclInterruptOccured_response& from);
  xclInterruptOccured_response(xclInterruptOccured_response&& from) noexcept
    : xclInterruptOccured_response() {
    *this = ::std::move(from);
  }

  inline xclInterruptOccured_response& operator=(const xclInterruptOccured_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclInterruptOccured_response& operator=(xclInterruptOccured_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclInterruptOccured_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclInterruptOccured_response* internal_default_instance() {
    return reinterpret_cast<const xclInterruptOccured_response*>(
               &_xclInterruptOccured_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(xclInterruptOccured_response& a, xclInterruptOccured_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclInterruptOccured_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclInterruptOccured_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclInterruptOccured_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclInterruptOccured_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclInterruptOccured_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclInterruptOccured_response& from) {
    xclInterruptOccured_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclInterruptOccured_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclInterruptOccured_response";
  }
  protected:
  explicit xclInterruptOccured_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // required bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclInterruptOccured_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool valid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPfBarAddrmap_call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPfBarAddrmap_call) */ {
 public:
  inline xclPfBarAddrmap_call() : xclPfBarAddrmap_call(nullptr) {}
  ~xclPfBarAddrmap_call() override;
  explicit PROTOBUF_CONSTEXPR xclPfBarAddrmap_call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPfBarAddrmap_call(const xclPfBarAddrmap_call& from);
  xclPfBarAddrmap_call(xclPfBarAddrmap_call&& from) noexcept
    : xclPfBarAddrmap_call() {
    *this = ::std::move(from);
  }

  inline xclPfBarAddrmap_call& operator=(const xclPfBarAddrmap_call& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPfBarAddrmap_call& operator=(xclPfBarAddrmap_call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPfBarAddrmap_call& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPfBarAddrmap_call* internal_default_instance() {
    return reinterpret_cast<const xclPfBarAddrmap_call*>(
               &_xclPfBarAddrmap_call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(xclPfBarAddrmap_call& a, xclPfBarAddrmap_call& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPfBarAddrmap_call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPfBarAddrmap_call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPfBarAddrmap_call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPfBarAddrmap_call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPfBarAddrmap_call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPfBarAddrmap_call& from) {
    xclPfBarAddrmap_call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPfBarAddrmap_call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPfBarAddrmap_call";
  }
  protected:
  explicit xclPfBarAddrmap_call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // optional bool req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  bool req() const;
  void set_req(bool value);
  private:
  bool _internal_req() const;
  void _internal_set_req(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xclPfBarAddrmap_call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool req_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPfBarAddrmap_response_PfBarmaps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPfBarAddrmap_response.PfBarmaps) */ {
 public:
  inline xclPfBarAddrmap_response_PfBarmaps() : xclPfBarAddrmap_response_PfBarmaps(nullptr) {}
  ~xclPfBarAddrmap_response_PfBarmaps() override;
  explicit PROTOBUF_CONSTEXPR xclPfBarAddrmap_response_PfBarmaps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPfBarAddrmap_response_PfBarmaps(const xclPfBarAddrmap_response_PfBarmaps& from);
  xclPfBarAddrmap_response_PfBarmaps(xclPfBarAddrmap_response_PfBarmaps&& from) noexcept
    : xclPfBarAddrmap_response_PfBarmaps() {
    *this = ::std::move(from);
  }

  inline xclPfBarAddrmap_response_PfBarmaps& operator=(const xclPfBarAddrmap_response_PfBarmaps& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPfBarAddrmap_response_PfBarmaps& operator=(xclPfBarAddrmap_response_PfBarmaps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPfBarAddrmap_response_PfBarmaps& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPfBarAddrmap_response_PfBarmaps* internal_default_instance() {
    return reinterpret_cast<const xclPfBarAddrmap_response_PfBarmaps*>(
               &_xclPfBarAddrmap_response_PfBarmaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(xclPfBarAddrmap_response_PfBarmaps& a, xclPfBarAddrmap_response_PfBarmaps& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPfBarAddrmap_response_PfBarmaps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPfBarAddrmap_response_PfBarmaps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPfBarAddrmap_response_PfBarmaps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPfBarAddrmap_response_PfBarmaps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPfBarAddrmap_response_PfBarmaps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPfBarAddrmap_response_PfBarmaps& from) {
    xclPfBarAddrmap_response_PfBarmaps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPfBarAddrmap_response_PfBarmaps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPfBarAddrmap_response.PfBarmaps";
  }
  protected:
  explicit xclPfBarAddrmap_response_PfBarmaps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPfIdFieldNumber = 1,
    kBarIdFieldNumber = 2,
    kRemapAddrFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  // required uint64 pf_id = 1;
  bool has_pf_id() const;
  private:
  bool _internal_has_pf_id() const;
  public:
  void clear_pf_id();
  uint64_t pf_id() const;
  void set_pf_id(uint64_t value);
  private:
  uint64_t _internal_pf_id() const;
  void _internal_set_pf_id(uint64_t value);
  public:

  // required uint64 bar_id = 2;
  bool has_bar_id() const;
  private:
  bool _internal_has_bar_id() const;
  public:
  void clear_bar_id();
  uint64_t bar_id() const;
  void set_bar_id(uint64_t value);
  private:
  uint64_t _internal_bar_id() const;
  void _internal_set_bar_id(uint64_t value);
  public:

  // required uint64 remap_addr = 3;
  bool has_remap_addr() const;
  private:
  bool _internal_has_remap_addr() const;
  public:
  void clear_remap_addr();
  uint64_t remap_addr() const;
  void set_remap_addr(uint64_t value);
  private:
  uint64_t _internal_remap_addr() const;
  void _internal_set_remap_addr(uint64_t value);
  public:

  // required uint64 size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xclPfBarAddrmap_response.PfBarmaps)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t pf_id_;
    uint64_t bar_id_;
    uint64_t remap_addr_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class xclPfBarAddrmap_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xclPfBarAddrmap_response) */ {
 public:
  inline xclPfBarAddrmap_response() : xclPfBarAddrmap_response(nullptr) {}
  ~xclPfBarAddrmap_response() override;
  explicit PROTOBUF_CONSTEXPR xclPfBarAddrmap_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  xclPfBarAddrmap_response(const xclPfBarAddrmap_response& from);
  xclPfBarAddrmap_response(xclPfBarAddrmap_response&& from) noexcept
    : xclPfBarAddrmap_response() {
    *this = ::std::move(from);
  }

  inline xclPfBarAddrmap_response& operator=(const xclPfBarAddrmap_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline xclPfBarAddrmap_response& operator=(xclPfBarAddrmap_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const xclPfBarAddrmap_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const xclPfBarAddrmap_response* internal_default_instance() {
    return reinterpret_cast<const xclPfBarAddrmap_response*>(
               &_xclPfBarAddrmap_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(xclPfBarAddrmap_response& a, xclPfBarAddrmap_response& b) {
    a.Swap(&b);
  }
  inline void Swap(xclPfBarAddrmap_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(xclPfBarAddrmap_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  xclPfBarAddrmap_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<xclPfBarAddrmap_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const xclPfBarAddrmap_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const xclPfBarAddrmap_response& from) {
    xclPfBarAddrmap_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(xclPfBarAddrmap_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xclPfBarAddrmap_response";
  }
  protected:
  explicit xclPfBarAddrmap_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef xclPfBarAddrmap_response_PfBarmaps PfBarmaps;

  // accessors -------------------------------------------------------

  enum : int {
    kPfbarMapFieldNumber = 1,
  };
  // repeated .xclPfBarAddrmap_response.PfBarmaps pfbar_map = 1;
  int pfbar_map_size() const;
  private:
  int _internal_pfbar_map_size() const;
  public:
  void clear_pfbar_map();
  ::xclPfBarAddrmap_response_PfBarmaps* mutable_pfbar_map(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPfBarAddrmap_response_PfBarmaps >*
      mutable_pfbar_map();
  private:
  const ::xclPfBarAddrmap_response_PfBarmaps& _internal_pfbar_map(int index) const;
  ::xclPfBarAddrmap_response_PfBarmaps* _internal_add_pfbar_map();
  public:
  const ::xclPfBarAddrmap_response_PfBarmaps& pfbar_map(int index) const;
  ::xclPfBarAddrmap_response_PfBarmaps* add_pfbar_map();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPfBarAddrmap_response_PfBarmaps >&
      pfbar_map() const;

  // @@protoc_insertion_point(class_scope:xclPfBarAddrmap_response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPfBarAddrmap_response_PfBarmaps > pfbar_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rpc_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// call_packet_info

// required fixed64 size = 1;
inline bool call_packet_info::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool call_packet_info::has_size() const {
  return _internal_has_size();
}
inline void call_packet_info::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t call_packet_info::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t call_packet_info::size() const {
  // @@protoc_insertion_point(field_get:call_packet_info.size)
  return _internal_size();
}
inline void call_packet_info::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void call_packet_info::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:call_packet_info.size)
}

// optional fixed32 xcl_api = 2;
inline bool call_packet_info::_internal_has_xcl_api() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool call_packet_info::has_xcl_api() const {
  return _internal_has_xcl_api();
}
inline void call_packet_info::clear_xcl_api() {
  _impl_.xcl_api_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t call_packet_info::_internal_xcl_api() const {
  return _impl_.xcl_api_;
}
inline uint32_t call_packet_info::xcl_api() const {
  // @@protoc_insertion_point(field_get:call_packet_info.xcl_api)
  return _internal_xcl_api();
}
inline void call_packet_info::_internal_set_xcl_api(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xcl_api_ = value;
}
inline void call_packet_info::set_xcl_api(uint32_t value) {
  _internal_set_xcl_api(value);
  // @@protoc_insertion_point(field_set:call_packet_info.xcl_api)
}

// -------------------------------------------------------------------

// response_packet_info

// required fixed64 size = 1;
inline bool response_packet_info::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool response_packet_info::has_size() const {
  return _internal_has_size();
}
inline void response_packet_info::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t response_packet_info::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t response_packet_info::size() const {
  // @@protoc_insertion_point(field_get:response_packet_info.size)
  return _internal_size();
}
inline void response_packet_info::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void response_packet_info::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:response_packet_info.size)
}

// optional fixed32 xcl_api = 2;
inline bool response_packet_info::_internal_has_xcl_api() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool response_packet_info::has_xcl_api() const {
  return _internal_has_xcl_api();
}
inline void response_packet_info::clear_xcl_api() {
  _impl_.xcl_api_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t response_packet_info::_internal_xcl_api() const {
  return _impl_.xcl_api_;
}
inline uint32_t response_packet_info::xcl_api() const {
  // @@protoc_insertion_point(field_get:response_packet_info.xcl_api)
  return _internal_xcl_api();
}
inline void response_packet_info::_internal_set_xcl_api(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xcl_api_ = value;
}
inline void response_packet_info::set_xcl_api(uint32_t value) {
  _internal_set_xcl_api(value);
  // @@protoc_insertion_point(field_set:response_packet_info.xcl_api)
}

// -------------------------------------------------------------------

// xclSetEnvironment_call_namevaluepair

// optional string name = 1;
inline bool xclSetEnvironment_call_namevaluepair::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSetEnvironment_call_namevaluepair::has_name() const {
  return _internal_has_name();
}
inline void xclSetEnvironment_call_namevaluepair::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclSetEnvironment_call_namevaluepair::name() const {
  // @@protoc_insertion_point(field_get:xclSetEnvironment_call.namevaluepair.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclSetEnvironment_call_namevaluepair::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclSetEnvironment_call.namevaluepair.name)
}
inline std::string* xclSetEnvironment_call_namevaluepair::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:xclSetEnvironment_call.namevaluepair.name)
  return _s;
}
inline const std::string& xclSetEnvironment_call_namevaluepair::_internal_name() const {
  return _impl_.name_.Get();
}
inline void xclSetEnvironment_call_namevaluepair::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* xclSetEnvironment_call_namevaluepair::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* xclSetEnvironment_call_namevaluepair::release_name() {
  // @@protoc_insertion_point(field_release:xclSetEnvironment_call.namevaluepair.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclSetEnvironment_call_namevaluepair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclSetEnvironment_call.namevaluepair.name)
}

// optional string value = 2;
inline bool xclSetEnvironment_call_namevaluepair::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclSetEnvironment_call_namevaluepair::has_value() const {
  return _internal_has_value();
}
inline void xclSetEnvironment_call_namevaluepair::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& xclSetEnvironment_call_namevaluepair::value() const {
  // @@protoc_insertion_point(field_get:xclSetEnvironment_call.namevaluepair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclSetEnvironment_call_namevaluepair::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclSetEnvironment_call.namevaluepair.value)
}
inline std::string* xclSetEnvironment_call_namevaluepair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:xclSetEnvironment_call.namevaluepair.value)
  return _s;
}
inline const std::string& xclSetEnvironment_call_namevaluepair::_internal_value() const {
  return _impl_.value_.Get();
}
inline void xclSetEnvironment_call_namevaluepair::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* xclSetEnvironment_call_namevaluepair::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* xclSetEnvironment_call_namevaluepair::release_value() {
  // @@protoc_insertion_point(field_release:xclSetEnvironment_call.namevaluepair.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclSetEnvironment_call_namevaluepair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclSetEnvironment_call.namevaluepair.value)
}

// -------------------------------------------------------------------

// xclSetEnvironment_call

// repeated .xclSetEnvironment_call.namevaluepair environment = 3;
inline int xclSetEnvironment_call::_internal_environment_size() const {
  return _impl_.environment_.size();
}
inline int xclSetEnvironment_call::environment_size() const {
  return _internal_environment_size();
}
inline void xclSetEnvironment_call::clear_environment() {
  _impl_.environment_.Clear();
}
inline ::xclSetEnvironment_call_namevaluepair* xclSetEnvironment_call::mutable_environment(int index) {
  // @@protoc_insertion_point(field_mutable:xclSetEnvironment_call.environment)
  return _impl_.environment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetEnvironment_call_namevaluepair >*
xclSetEnvironment_call::mutable_environment() {
  // @@protoc_insertion_point(field_mutable_list:xclSetEnvironment_call.environment)
  return &_impl_.environment_;
}
inline const ::xclSetEnvironment_call_namevaluepair& xclSetEnvironment_call::_internal_environment(int index) const {
  return _impl_.environment_.Get(index);
}
inline const ::xclSetEnvironment_call_namevaluepair& xclSetEnvironment_call::environment(int index) const {
  // @@protoc_insertion_point(field_get:xclSetEnvironment_call.environment)
  return _internal_environment(index);
}
inline ::xclSetEnvironment_call_namevaluepair* xclSetEnvironment_call::_internal_add_environment() {
  return _impl_.environment_.Add();
}
inline ::xclSetEnvironment_call_namevaluepair* xclSetEnvironment_call::add_environment() {
  ::xclSetEnvironment_call_namevaluepair* _add = _internal_add_environment();
  // @@protoc_insertion_point(field_add:xclSetEnvironment_call.environment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetEnvironment_call_namevaluepair >&
xclSetEnvironment_call::environment() const {
  // @@protoc_insertion_point(field_list:xclSetEnvironment_call.environment)
  return _impl_.environment_;
}

// -------------------------------------------------------------------

// xclSetEnvironment_response

// optional bool ack = 1;
inline bool xclSetEnvironment_response::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSetEnvironment_response::has_ack() const {
  return _internal_has_ack();
}
inline void xclSetEnvironment_response::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclSetEnvironment_response::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclSetEnvironment_response::ack() const {
  // @@protoc_insertion_point(field_get:xclSetEnvironment_response.ack)
  return _internal_ack();
}
inline void xclSetEnvironment_response::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclSetEnvironment_response::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclSetEnvironment_response.ack)
}

// -------------------------------------------------------------------

// xclLoadBitstream_call_ddrbank

// optional uint64 size = 7;
inline bool xclLoadBitstream_call_ddrbank::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclLoadBitstream_call_ddrbank::has_size() const {
  return _internal_has_size();
}
inline void xclLoadBitstream_call_ddrbank::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclLoadBitstream_call_ddrbank::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclLoadBitstream_call_ddrbank::size() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.ddrbank.size)
  return _internal_size();
}
inline void xclLoadBitstream_call_ddrbank::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void xclLoadBitstream_call_ddrbank::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.ddrbank.size)
}

// -------------------------------------------------------------------

// xclLoadBitstream_call

// required bytes xmlfile = 1;
inline bool xclLoadBitstream_call::_internal_has_xmlfile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclLoadBitstream_call::has_xmlfile() const {
  return _internal_has_xmlfile();
}
inline void xclLoadBitstream_call::clear_xmlfile() {
  _impl_.xmlfile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclLoadBitstream_call::xmlfile() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.xmlfile)
  return _internal_xmlfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclLoadBitstream_call::set_xmlfile(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.xmlfile_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.xmlfile)
}
inline std::string* xclLoadBitstream_call::mutable_xmlfile() {
  std::string* _s = _internal_mutable_xmlfile();
  // @@protoc_insertion_point(field_mutable:xclLoadBitstream_call.xmlfile)
  return _s;
}
inline const std::string& xclLoadBitstream_call::_internal_xmlfile() const {
  return _impl_.xmlfile_.Get();
}
inline void xclLoadBitstream_call::_internal_set_xmlfile(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xmlfile_.Set(value, GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::_internal_mutable_xmlfile() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.xmlfile_.Mutable(GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::release_xmlfile() {
  // @@protoc_insertion_point(field_release:xclLoadBitstream_call.xmlfile)
  if (!_internal_has_xmlfile()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.xmlfile_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xmlfile_.IsDefault()) {
    _impl_.xmlfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclLoadBitstream_call::set_allocated_xmlfile(std::string* xmlfile) {
  if (xmlfile != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.xmlfile_.SetAllocated(xmlfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xmlfile_.IsDefault()) {
    _impl_.xmlfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclLoadBitstream_call.xmlfile)
}

// required bytes dlopenfilename = 2;
inline bool xclLoadBitstream_call::_internal_has_dlopenfilename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclLoadBitstream_call::has_dlopenfilename() const {
  return _internal_has_dlopenfilename();
}
inline void xclLoadBitstream_call::clear_dlopenfilename() {
  _impl_.dlopenfilename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& xclLoadBitstream_call::dlopenfilename() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.dlopenfilename)
  return _internal_dlopenfilename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclLoadBitstream_call::set_dlopenfilename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.dlopenfilename_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.dlopenfilename)
}
inline std::string* xclLoadBitstream_call::mutable_dlopenfilename() {
  std::string* _s = _internal_mutable_dlopenfilename();
  // @@protoc_insertion_point(field_mutable:xclLoadBitstream_call.dlopenfilename)
  return _s;
}
inline const std::string& xclLoadBitstream_call::_internal_dlopenfilename() const {
  return _impl_.dlopenfilename_.Get();
}
inline void xclLoadBitstream_call::_internal_set_dlopenfilename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dlopenfilename_.Set(value, GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::_internal_mutable_dlopenfilename() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dlopenfilename_.Mutable(GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::release_dlopenfilename() {
  // @@protoc_insertion_point(field_release:xclLoadBitstream_call.dlopenfilename)
  if (!_internal_has_dlopenfilename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.dlopenfilename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dlopenfilename_.IsDefault()) {
    _impl_.dlopenfilename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclLoadBitstream_call::set_allocated_dlopenfilename(std::string* dlopenfilename) {
  if (dlopenfilename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dlopenfilename_.SetAllocated(dlopenfilename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dlopenfilename_.IsDefault()) {
    _impl_.dlopenfilename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclLoadBitstream_call.dlopenfilename)
}

// required bytes devicename = 3;
inline bool xclLoadBitstream_call::_internal_has_devicename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclLoadBitstream_call::has_devicename() const {
  return _internal_has_devicename();
}
inline void xclLoadBitstream_call::clear_devicename() {
  _impl_.devicename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& xclLoadBitstream_call::devicename() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.devicename)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclLoadBitstream_call::set_devicename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.devicename_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.devicename)
}
inline std::string* xclLoadBitstream_call::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:xclLoadBitstream_call.devicename)
  return _s;
}
inline const std::string& xclLoadBitstream_call::_internal_devicename() const {
  return _impl_.devicename_.Get();
}
inline void xclLoadBitstream_call::_internal_set_devicename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.devicename_.Set(value, GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::_internal_mutable_devicename() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.devicename_.Mutable(GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::release_devicename() {
  // @@protoc_insertion_point(field_release:xclLoadBitstream_call.devicename)
  if (!_internal_has_devicename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.devicename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclLoadBitstream_call::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.devicename_.SetAllocated(devicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclLoadBitstream_call.devicename)
}

// required bytes devicedirectory = 4;
inline bool xclLoadBitstream_call::_internal_has_devicedirectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclLoadBitstream_call::has_devicedirectory() const {
  return _internal_has_devicedirectory();
}
inline void xclLoadBitstream_call::clear_devicedirectory() {
  _impl_.devicedirectory_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& xclLoadBitstream_call::devicedirectory() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.devicedirectory)
  return _internal_devicedirectory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclLoadBitstream_call::set_devicedirectory(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.devicedirectory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.devicedirectory)
}
inline std::string* xclLoadBitstream_call::mutable_devicedirectory() {
  std::string* _s = _internal_mutable_devicedirectory();
  // @@protoc_insertion_point(field_mutable:xclLoadBitstream_call.devicedirectory)
  return _s;
}
inline const std::string& xclLoadBitstream_call::_internal_devicedirectory() const {
  return _impl_.devicedirectory_.Get();
}
inline void xclLoadBitstream_call::_internal_set_devicedirectory(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.devicedirectory_.Set(value, GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::_internal_mutable_devicedirectory() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.devicedirectory_.Mutable(GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::release_devicedirectory() {
  // @@protoc_insertion_point(field_release:xclLoadBitstream_call.devicedirectory)
  if (!_internal_has_devicedirectory()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.devicedirectory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicedirectory_.IsDefault()) {
    _impl_.devicedirectory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclLoadBitstream_call::set_allocated_devicedirectory(std::string* devicedirectory) {
  if (devicedirectory != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.devicedirectory_.SetAllocated(devicedirectory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicedirectory_.IsDefault()) {
    _impl_.devicedirectory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclLoadBitstream_call.devicedirectory)
}

// required bytes binarydirectory = 5;
inline bool xclLoadBitstream_call::_internal_has_binarydirectory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclLoadBitstream_call::has_binarydirectory() const {
  return _internal_has_binarydirectory();
}
inline void xclLoadBitstream_call::clear_binarydirectory() {
  _impl_.binarydirectory_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& xclLoadBitstream_call::binarydirectory() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.binarydirectory)
  return _internal_binarydirectory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclLoadBitstream_call::set_binarydirectory(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.binarydirectory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.binarydirectory)
}
inline std::string* xclLoadBitstream_call::mutable_binarydirectory() {
  std::string* _s = _internal_mutable_binarydirectory();
  // @@protoc_insertion_point(field_mutable:xclLoadBitstream_call.binarydirectory)
  return _s;
}
inline const std::string& xclLoadBitstream_call::_internal_binarydirectory() const {
  return _impl_.binarydirectory_.Get();
}
inline void xclLoadBitstream_call::_internal_set_binarydirectory(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.binarydirectory_.Set(value, GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::_internal_mutable_binarydirectory() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.binarydirectory_.Mutable(GetArenaForAllocation());
}
inline std::string* xclLoadBitstream_call::release_binarydirectory() {
  // @@protoc_insertion_point(field_release:xclLoadBitstream_call.binarydirectory)
  if (!_internal_has_binarydirectory()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.binarydirectory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binarydirectory_.IsDefault()) {
    _impl_.binarydirectory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclLoadBitstream_call::set_allocated_binarydirectory(std::string* binarydirectory) {
  if (binarydirectory != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.binarydirectory_.SetAllocated(binarydirectory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.binarydirectory_.IsDefault()) {
    _impl_.binarydirectory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclLoadBitstream_call.binarydirectory)
}

// required bool verbose = 6;
inline bool xclLoadBitstream_call::_internal_has_verbose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclLoadBitstream_call::has_verbose() const {
  return _internal_has_verbose();
}
inline void xclLoadBitstream_call::clear_verbose() {
  _impl_.verbose_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool xclLoadBitstream_call::_internal_verbose() const {
  return _impl_.verbose_;
}
inline bool xclLoadBitstream_call::verbose() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.verbose)
  return _internal_verbose();
}
inline void xclLoadBitstream_call::_internal_set_verbose(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.verbose_ = value;
}
inline void xclLoadBitstream_call::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:xclLoadBitstream_call.verbose)
}

// repeated .xclLoadBitstream_call.ddrbank ddrbanks = 8;
inline int xclLoadBitstream_call::_internal_ddrbanks_size() const {
  return _impl_.ddrbanks_.size();
}
inline int xclLoadBitstream_call::ddrbanks_size() const {
  return _internal_ddrbanks_size();
}
inline void xclLoadBitstream_call::clear_ddrbanks() {
  _impl_.ddrbanks_.Clear();
}
inline ::xclLoadBitstream_call_ddrbank* xclLoadBitstream_call::mutable_ddrbanks(int index) {
  // @@protoc_insertion_point(field_mutable:xclLoadBitstream_call.ddrbanks)
  return _impl_.ddrbanks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclLoadBitstream_call_ddrbank >*
xclLoadBitstream_call::mutable_ddrbanks() {
  // @@protoc_insertion_point(field_mutable_list:xclLoadBitstream_call.ddrbanks)
  return &_impl_.ddrbanks_;
}
inline const ::xclLoadBitstream_call_ddrbank& xclLoadBitstream_call::_internal_ddrbanks(int index) const {
  return _impl_.ddrbanks_.Get(index);
}
inline const ::xclLoadBitstream_call_ddrbank& xclLoadBitstream_call::ddrbanks(int index) const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_call.ddrbanks)
  return _internal_ddrbanks(index);
}
inline ::xclLoadBitstream_call_ddrbank* xclLoadBitstream_call::_internal_add_ddrbanks() {
  return _impl_.ddrbanks_.Add();
}
inline ::xclLoadBitstream_call_ddrbank* xclLoadBitstream_call::add_ddrbanks() {
  ::xclLoadBitstream_call_ddrbank* _add = _internal_add_ddrbanks();
  // @@protoc_insertion_point(field_add:xclLoadBitstream_call.ddrbanks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclLoadBitstream_call_ddrbank >&
xclLoadBitstream_call::ddrbanks() const {
  // @@protoc_insertion_point(field_list:xclLoadBitstream_call.ddrbanks)
  return _impl_.ddrbanks_;
}

// -------------------------------------------------------------------

// xclLoadBitstream_response

// required bool ack = 1;
inline bool xclLoadBitstream_response::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclLoadBitstream_response::has_ack() const {
  return _internal_has_ack();
}
inline void xclLoadBitstream_response::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclLoadBitstream_response::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclLoadBitstream_response::ack() const {
  // @@protoc_insertion_point(field_get:xclLoadBitstream_response.ack)
  return _internal_ack();
}
inline void xclLoadBitstream_response::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclLoadBitstream_response::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclLoadBitstream_response.ack)
}

// -------------------------------------------------------------------

// xclAllocDeviceBuffer_call

// required uint64 ddraddress = 1;
inline bool xclAllocDeviceBuffer_call::_internal_has_ddraddress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclAllocDeviceBuffer_call::has_ddraddress() const {
  return _internal_has_ddraddress();
}
inline void xclAllocDeviceBuffer_call::clear_ddraddress() {
  _impl_.ddraddress_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclAllocDeviceBuffer_call::_internal_ddraddress() const {
  return _impl_.ddraddress_;
}
inline uint64_t xclAllocDeviceBuffer_call::ddraddress() const {
  // @@protoc_insertion_point(field_get:xclAllocDeviceBuffer_call.ddraddress)
  return _internal_ddraddress();
}
inline void xclAllocDeviceBuffer_call::_internal_set_ddraddress(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ddraddress_ = value;
}
inline void xclAllocDeviceBuffer_call::set_ddraddress(uint64_t value) {
  _internal_set_ddraddress(value);
  // @@protoc_insertion_point(field_set:xclAllocDeviceBuffer_call.ddraddress)
}

// required uint64 size = 2;
inline bool xclAllocDeviceBuffer_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclAllocDeviceBuffer_call::has_size() const {
  return _internal_has_size();
}
inline void xclAllocDeviceBuffer_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclAllocDeviceBuffer_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclAllocDeviceBuffer_call::size() const {
  // @@protoc_insertion_point(field_get:xclAllocDeviceBuffer_call.size)
  return _internal_size();
}
inline void xclAllocDeviceBuffer_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void xclAllocDeviceBuffer_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclAllocDeviceBuffer_call.size)
}

// optional bool peertopeer = 3;
inline bool xclAllocDeviceBuffer_call::_internal_has_peertopeer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclAllocDeviceBuffer_call::has_peertopeer() const {
  return _internal_has_peertopeer();
}
inline void xclAllocDeviceBuffer_call::clear_peertopeer() {
  _impl_.peertopeer_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool xclAllocDeviceBuffer_call::_internal_peertopeer() const {
  return _impl_.peertopeer_;
}
inline bool xclAllocDeviceBuffer_call::peertopeer() const {
  // @@protoc_insertion_point(field_get:xclAllocDeviceBuffer_call.peertopeer)
  return _internal_peertopeer();
}
inline void xclAllocDeviceBuffer_call::_internal_set_peertopeer(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.peertopeer_ = value;
}
inline void xclAllocDeviceBuffer_call::set_peertopeer(bool value) {
  _internal_set_peertopeer(value);
  // @@protoc_insertion_point(field_set:xclAllocDeviceBuffer_call.peertopeer)
}

// -------------------------------------------------------------------

// xclAllocDeviceBuffer_response

// required bool ack = 1;
inline bool xclAllocDeviceBuffer_response::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclAllocDeviceBuffer_response::has_ack() const {
  return _internal_has_ack();
}
inline void xclAllocDeviceBuffer_response::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclAllocDeviceBuffer_response::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclAllocDeviceBuffer_response::ack() const {
  // @@protoc_insertion_point(field_get:xclAllocDeviceBuffer_response.ack)
  return _internal_ack();
}
inline void xclAllocDeviceBuffer_response::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ack_ = value;
}
inline void xclAllocDeviceBuffer_response::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclAllocDeviceBuffer_response.ack)
}

// optional string filename = 2;
inline bool xclAllocDeviceBuffer_response::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclAllocDeviceBuffer_response::has_filename() const {
  return _internal_has_filename();
}
inline void xclAllocDeviceBuffer_response::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclAllocDeviceBuffer_response::filename() const {
  // @@protoc_insertion_point(field_get:xclAllocDeviceBuffer_response.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclAllocDeviceBuffer_response::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclAllocDeviceBuffer_response.filename)
}
inline std::string* xclAllocDeviceBuffer_response::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:xclAllocDeviceBuffer_response.filename)
  return _s;
}
inline const std::string& xclAllocDeviceBuffer_response::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void xclAllocDeviceBuffer_response::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* xclAllocDeviceBuffer_response::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* xclAllocDeviceBuffer_response::release_filename() {
  // @@protoc_insertion_point(field_release:xclAllocDeviceBuffer_response.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclAllocDeviceBuffer_response::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclAllocDeviceBuffer_response.filename)
}

// -------------------------------------------------------------------

// xclFreeDeviceBuffer_call

// required uint64 ddraddress = 1;
inline bool xclFreeDeviceBuffer_call::_internal_has_ddraddress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclFreeDeviceBuffer_call::has_ddraddress() const {
  return _internal_has_ddraddress();
}
inline void xclFreeDeviceBuffer_call::clear_ddraddress() {
  _impl_.ddraddress_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclFreeDeviceBuffer_call::_internal_ddraddress() const {
  return _impl_.ddraddress_;
}
inline uint64_t xclFreeDeviceBuffer_call::ddraddress() const {
  // @@protoc_insertion_point(field_get:xclFreeDeviceBuffer_call.ddraddress)
  return _internal_ddraddress();
}
inline void xclFreeDeviceBuffer_call::_internal_set_ddraddress(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ddraddress_ = value;
}
inline void xclFreeDeviceBuffer_call::set_ddraddress(uint64_t value) {
  _internal_set_ddraddress(value);
  // @@protoc_insertion_point(field_set:xclFreeDeviceBuffer_call.ddraddress)
}

// -------------------------------------------------------------------

// xclFreeDeviceBuffer_response

// required bool ack = 1;
inline bool xclFreeDeviceBuffer_response::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclFreeDeviceBuffer_response::has_ack() const {
  return _internal_has_ack();
}
inline void xclFreeDeviceBuffer_response::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclFreeDeviceBuffer_response::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclFreeDeviceBuffer_response::ack() const {
  // @@protoc_insertion_point(field_get:xclFreeDeviceBuffer_response.ack)
  return _internal_ack();
}
inline void xclFreeDeviceBuffer_response::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclFreeDeviceBuffer_response::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclFreeDeviceBuffer_response.ack)
}

// -------------------------------------------------------------------

// xclClose_call

// optional bytes xclDeviceHandle = 2;
inline bool xclClose_call::_internal_has_xcldevicehandle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclClose_call::has_xcldevicehandle() const {
  return _internal_has_xcldevicehandle();
}
inline void xclClose_call::clear_xcldevicehandle() {
  _impl_.xcldevicehandle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclClose_call::xcldevicehandle() const {
  // @@protoc_insertion_point(field_get:xclClose_call.xclDeviceHandle)
  return _internal_xcldevicehandle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclClose_call::set_xcldevicehandle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.xcldevicehandle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclClose_call.xclDeviceHandle)
}
inline std::string* xclClose_call::mutable_xcldevicehandle() {
  std::string* _s = _internal_mutable_xcldevicehandle();
  // @@protoc_insertion_point(field_mutable:xclClose_call.xclDeviceHandle)
  return _s;
}
inline const std::string& xclClose_call::_internal_xcldevicehandle() const {
  return _impl_.xcldevicehandle_.Get();
}
inline void xclClose_call::_internal_set_xcldevicehandle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xcldevicehandle_.Set(value, GetArenaForAllocation());
}
inline std::string* xclClose_call::_internal_mutable_xcldevicehandle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.xcldevicehandle_.Mutable(GetArenaForAllocation());
}
inline std::string* xclClose_call::release_xcldevicehandle() {
  // @@protoc_insertion_point(field_release:xclClose_call.xclDeviceHandle)
  if (!_internal_has_xcldevicehandle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.xcldevicehandle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xcldevicehandle_.IsDefault()) {
    _impl_.xcldevicehandle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclClose_call::set_allocated_xcldevicehandle(std::string* xcldevicehandle) {
  if (xcldevicehandle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.xcldevicehandle_.SetAllocated(xcldevicehandle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xcldevicehandle_.IsDefault()) {
    _impl_.xcldevicehandle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclClose_call.xclDeviceHandle)
}

// optional bool closeall = 3;
inline bool xclClose_call::_internal_has_closeall() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclClose_call::has_closeall() const {
  return _internal_has_closeall();
}
inline void xclClose_call::clear_closeall() {
  _impl_.closeall_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclClose_call::_internal_closeall() const {
  return _impl_.closeall_;
}
inline bool xclClose_call::closeall() const {
  // @@protoc_insertion_point(field_get:xclClose_call.closeall)
  return _internal_closeall();
}
inline void xclClose_call::_internal_set_closeall(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.closeall_ = value;
}
inline void xclClose_call::set_closeall(bool value) {
  _internal_set_closeall(value);
  // @@protoc_insertion_point(field_set:xclClose_call.closeall)
}

// -------------------------------------------------------------------

// xclClose_response

// required bool valid = 1;
inline bool xclClose_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclClose_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclClose_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclClose_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclClose_response::valid() const {
  // @@protoc_insertion_point(field_get:xclClose_response.valid)
  return _internal_valid();
}
inline void xclClose_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valid_ = value;
}
inline void xclClose_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclClose_response.valid)
}

// -------------------------------------------------------------------

// xclCopyBufferHost2Device_call

// required bytes xclDeviceHandle = 2;
inline bool xclCopyBufferHost2Device_call::_internal_has_xcldevicehandle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_call::has_xcldevicehandle() const {
  return _internal_has_xcldevicehandle();
}
inline void xclCopyBufferHost2Device_call::clear_xcldevicehandle() {
  _impl_.xcldevicehandle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclCopyBufferHost2Device_call::xcldevicehandle() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_call.xclDeviceHandle)
  return _internal_xcldevicehandle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclCopyBufferHost2Device_call::set_xcldevicehandle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.xcldevicehandle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_call.xclDeviceHandle)
}
inline std::string* xclCopyBufferHost2Device_call::mutable_xcldevicehandle() {
  std::string* _s = _internal_mutable_xcldevicehandle();
  // @@protoc_insertion_point(field_mutable:xclCopyBufferHost2Device_call.xclDeviceHandle)
  return _s;
}
inline const std::string& xclCopyBufferHost2Device_call::_internal_xcldevicehandle() const {
  return _impl_.xcldevicehandle_.Get();
}
inline void xclCopyBufferHost2Device_call::_internal_set_xcldevicehandle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xcldevicehandle_.Set(value, GetArenaForAllocation());
}
inline std::string* xclCopyBufferHost2Device_call::_internal_mutable_xcldevicehandle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.xcldevicehandle_.Mutable(GetArenaForAllocation());
}
inline std::string* xclCopyBufferHost2Device_call::release_xcldevicehandle() {
  // @@protoc_insertion_point(field_release:xclCopyBufferHost2Device_call.xclDeviceHandle)
  if (!_internal_has_xcldevicehandle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.xcldevicehandle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xcldevicehandle_.IsDefault()) {
    _impl_.xcldevicehandle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclCopyBufferHost2Device_call::set_allocated_xcldevicehandle(std::string* xcldevicehandle) {
  if (xcldevicehandle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.xcldevicehandle_.SetAllocated(xcldevicehandle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xcldevicehandle_.IsDefault()) {
    _impl_.xcldevicehandle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclCopyBufferHost2Device_call.xclDeviceHandle)
}

// required uint64 dest = 3;
inline bool xclCopyBufferHost2Device_call::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_call::has_dest() const {
  return _internal_has_dest();
}
inline void xclCopyBufferHost2Device_call::clear_dest() {
  _impl_.dest_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclCopyBufferHost2Device_call::_internal_dest() const {
  return _impl_.dest_;
}
inline uint64_t xclCopyBufferHost2Device_call::dest() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_call.dest)
  return _internal_dest();
}
inline void xclCopyBufferHost2Device_call::_internal_set_dest(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dest_ = value;
}
inline void xclCopyBufferHost2Device_call::set_dest(uint64_t value) {
  _internal_set_dest(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_call.dest)
}

// required bytes src = 4;
inline bool xclCopyBufferHost2Device_call::_internal_has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_call::has_src() const {
  return _internal_has_src();
}
inline void xclCopyBufferHost2Device_call::clear_src() {
  _impl_.src_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& xclCopyBufferHost2Device_call::src() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_call.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclCopyBufferHost2Device_call::set_src(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.src_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_call.src)
}
inline std::string* xclCopyBufferHost2Device_call::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:xclCopyBufferHost2Device_call.src)
  return _s;
}
inline const std::string& xclCopyBufferHost2Device_call::_internal_src() const {
  return _impl_.src_.Get();
}
inline void xclCopyBufferHost2Device_call::_internal_set_src(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* xclCopyBufferHost2Device_call::_internal_mutable_src() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* xclCopyBufferHost2Device_call::release_src() {
  // @@protoc_insertion_point(field_release:xclCopyBufferHost2Device_call.src)
  if (!_internal_has_src()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.src_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclCopyBufferHost2Device_call::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclCopyBufferHost2Device_call.src)
}

// required uint64 size = 5;
inline bool xclCopyBufferHost2Device_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_call::has_size() const {
  return _internal_has_size();
}
inline void xclCopyBufferHost2Device_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclCopyBufferHost2Device_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclCopyBufferHost2Device_call::size() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_call.size)
  return _internal_size();
}
inline void xclCopyBufferHost2Device_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_ = value;
}
inline void xclCopyBufferHost2Device_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_call.size)
}

// required uint64 seek = 6;
inline bool xclCopyBufferHost2Device_call::_internal_has_seek() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_call::has_seek() const {
  return _internal_has_seek();
}
inline void xclCopyBufferHost2Device_call::clear_seek() {
  _impl_.seek_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclCopyBufferHost2Device_call::_internal_seek() const {
  return _impl_.seek_;
}
inline uint64_t xclCopyBufferHost2Device_call::seek() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_call.seek)
  return _internal_seek();
}
inline void xclCopyBufferHost2Device_call::_internal_set_seek(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.seek_ = value;
}
inline void xclCopyBufferHost2Device_call::set_seek(uint64_t value) {
  _internal_set_seek(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_call.seek)
}

// optional uint32 space = 7;
inline bool xclCopyBufferHost2Device_call::_internal_has_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_call::has_space() const {
  return _internal_has_space();
}
inline void xclCopyBufferHost2Device_call::clear_space() {
  _impl_.space_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t xclCopyBufferHost2Device_call::_internal_space() const {
  return _impl_.space_;
}
inline uint32_t xclCopyBufferHost2Device_call::space() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_call.space)
  return _internal_space();
}
inline void xclCopyBufferHost2Device_call::_internal_set_space(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.space_ = value;
}
inline void xclCopyBufferHost2Device_call::set_space(uint32_t value) {
  _internal_set_space(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_call.space)
}

// -------------------------------------------------------------------

// xclCopyBufferHost2Device_response

// required uint64 size = 1;
inline bool xclCopyBufferHost2Device_response::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCopyBufferHost2Device_response::has_size() const {
  return _internal_has_size();
}
inline void xclCopyBufferHost2Device_response::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclCopyBufferHost2Device_response::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclCopyBufferHost2Device_response::size() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferHost2Device_response.size)
  return _internal_size();
}
inline void xclCopyBufferHost2Device_response::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void xclCopyBufferHost2Device_response::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferHost2Device_response.size)
}

// -------------------------------------------------------------------

// xclCopyBufferDevice2Host_call

// required bytes xclDeviceHandle = 2;
inline bool xclCopyBufferDevice2Host_call::_internal_has_xcldevicehandle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_call::has_xcldevicehandle() const {
  return _internal_has_xcldevicehandle();
}
inline void xclCopyBufferDevice2Host_call::clear_xcldevicehandle() {
  _impl_.xcldevicehandle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclCopyBufferDevice2Host_call::xcldevicehandle() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_call.xclDeviceHandle)
  return _internal_xcldevicehandle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclCopyBufferDevice2Host_call::set_xcldevicehandle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.xcldevicehandle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_call.xclDeviceHandle)
}
inline std::string* xclCopyBufferDevice2Host_call::mutable_xcldevicehandle() {
  std::string* _s = _internal_mutable_xcldevicehandle();
  // @@protoc_insertion_point(field_mutable:xclCopyBufferDevice2Host_call.xclDeviceHandle)
  return _s;
}
inline const std::string& xclCopyBufferDevice2Host_call::_internal_xcldevicehandle() const {
  return _impl_.xcldevicehandle_.Get();
}
inline void xclCopyBufferDevice2Host_call::_internal_set_xcldevicehandle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xcldevicehandle_.Set(value, GetArenaForAllocation());
}
inline std::string* xclCopyBufferDevice2Host_call::_internal_mutable_xcldevicehandle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.xcldevicehandle_.Mutable(GetArenaForAllocation());
}
inline std::string* xclCopyBufferDevice2Host_call::release_xcldevicehandle() {
  // @@protoc_insertion_point(field_release:xclCopyBufferDevice2Host_call.xclDeviceHandle)
  if (!_internal_has_xcldevicehandle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.xcldevicehandle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xcldevicehandle_.IsDefault()) {
    _impl_.xcldevicehandle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclCopyBufferDevice2Host_call::set_allocated_xcldevicehandle(std::string* xcldevicehandle) {
  if (xcldevicehandle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.xcldevicehandle_.SetAllocated(xcldevicehandle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.xcldevicehandle_.IsDefault()) {
    _impl_.xcldevicehandle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclCopyBufferDevice2Host_call.xclDeviceHandle)
}

// required bytes dest = 3;
inline bool xclCopyBufferDevice2Host_call::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_call::has_dest() const {
  return _internal_has_dest();
}
inline void xclCopyBufferDevice2Host_call::clear_dest() {
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& xclCopyBufferDevice2Host_call::dest() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_call.dest)
  return _internal_dest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclCopyBufferDevice2Host_call::set_dest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.dest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_call.dest)
}
inline std::string* xclCopyBufferDevice2Host_call::mutable_dest() {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:xclCopyBufferDevice2Host_call.dest)
  return _s;
}
inline const std::string& xclCopyBufferDevice2Host_call::_internal_dest() const {
  return _impl_.dest_.Get();
}
inline void xclCopyBufferDevice2Host_call::_internal_set_dest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dest_.Set(value, GetArenaForAllocation());
}
inline std::string* xclCopyBufferDevice2Host_call::_internal_mutable_dest() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dest_.Mutable(GetArenaForAllocation());
}
inline std::string* xclCopyBufferDevice2Host_call::release_dest() {
  // @@protoc_insertion_point(field_release:xclCopyBufferDevice2Host_call.dest)
  if (!_internal_has_dest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.dest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclCopyBufferDevice2Host_call::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dest_.SetAllocated(dest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclCopyBufferDevice2Host_call.dest)
}

// required uint64 src = 4;
inline bool xclCopyBufferDevice2Host_call::_internal_has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_call::has_src() const {
  return _internal_has_src();
}
inline void xclCopyBufferDevice2Host_call::clear_src() {
  _impl_.src_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclCopyBufferDevice2Host_call::_internal_src() const {
  return _impl_.src_;
}
inline uint64_t xclCopyBufferDevice2Host_call::src() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_call.src)
  return _internal_src();
}
inline void xclCopyBufferDevice2Host_call::_internal_set_src(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.src_ = value;
}
inline void xclCopyBufferDevice2Host_call::set_src(uint64_t value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_call.src)
}

// required uint64 size = 5;
inline bool xclCopyBufferDevice2Host_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_call::has_size() const {
  return _internal_has_size();
}
inline void xclCopyBufferDevice2Host_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclCopyBufferDevice2Host_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclCopyBufferDevice2Host_call::size() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_call.size)
  return _internal_size();
}
inline void xclCopyBufferDevice2Host_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_ = value;
}
inline void xclCopyBufferDevice2Host_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_call.size)
}

// required uint64 skip = 6;
inline bool xclCopyBufferDevice2Host_call::_internal_has_skip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_call::has_skip() const {
  return _internal_has_skip();
}
inline void xclCopyBufferDevice2Host_call::clear_skip() {
  _impl_.skip_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclCopyBufferDevice2Host_call::_internal_skip() const {
  return _impl_.skip_;
}
inline uint64_t xclCopyBufferDevice2Host_call::skip() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_call.skip)
  return _internal_skip();
}
inline void xclCopyBufferDevice2Host_call::_internal_set_skip(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.skip_ = value;
}
inline void xclCopyBufferDevice2Host_call::set_skip(uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_call.skip)
}

// optional uint32 space = 7;
inline bool xclCopyBufferDevice2Host_call::_internal_has_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_call::has_space() const {
  return _internal_has_space();
}
inline void xclCopyBufferDevice2Host_call::clear_space() {
  _impl_.space_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t xclCopyBufferDevice2Host_call::_internal_space() const {
  return _impl_.space_;
}
inline uint32_t xclCopyBufferDevice2Host_call::space() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_call.space)
  return _internal_space();
}
inline void xclCopyBufferDevice2Host_call::_internal_set_space(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.space_ = value;
}
inline void xclCopyBufferDevice2Host_call::set_space(uint32_t value) {
  _internal_set_space(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_call.space)
}

// -------------------------------------------------------------------

// xclCopyBufferDevice2Host_response

// required uint64 size = 1;
inline bool xclCopyBufferDevice2Host_response::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_response::has_size() const {
  return _internal_has_size();
}
inline void xclCopyBufferDevice2Host_response::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclCopyBufferDevice2Host_response::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclCopyBufferDevice2Host_response::size() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_response.size)
  return _internal_size();
}
inline void xclCopyBufferDevice2Host_response::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void xclCopyBufferDevice2Host_response::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_response.size)
}

// required bytes dest = 2;
inline bool xclCopyBufferDevice2Host_response::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCopyBufferDevice2Host_response::has_dest() const {
  return _internal_has_dest();
}
inline void xclCopyBufferDevice2Host_response::clear_dest() {
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclCopyBufferDevice2Host_response::dest() const {
  // @@protoc_insertion_point(field_get:xclCopyBufferDevice2Host_response.dest)
  return _internal_dest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclCopyBufferDevice2Host_response::set_dest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclCopyBufferDevice2Host_response.dest)
}
inline std::string* xclCopyBufferDevice2Host_response::mutable_dest() {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:xclCopyBufferDevice2Host_response.dest)
  return _s;
}
inline const std::string& xclCopyBufferDevice2Host_response::_internal_dest() const {
  return _impl_.dest_.Get();
}
inline void xclCopyBufferDevice2Host_response::_internal_set_dest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dest_.Set(value, GetArenaForAllocation());
}
inline std::string* xclCopyBufferDevice2Host_response::_internal_mutable_dest() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dest_.Mutable(GetArenaForAllocation());
}
inline std::string* xclCopyBufferDevice2Host_response::release_dest() {
  // @@protoc_insertion_point(field_release:xclCopyBufferDevice2Host_response.dest)
  if (!_internal_has_dest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclCopyBufferDevice2Host_response::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dest_.SetAllocated(dest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclCopyBufferDevice2Host_response.dest)
}

// -------------------------------------------------------------------

// xclWriteAddrSpaceDeviceRam_call

// required uint64 addr = 2;
inline bool xclWriteAddrSpaceDeviceRam_call::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclWriteAddrSpaceDeviceRam_call::has_addr() const {
  return _internal_has_addr();
}
inline void xclWriteAddrSpaceDeviceRam_call::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclWriteAddrSpaceDeviceRam_call::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclWriteAddrSpaceDeviceRam_call::addr() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrSpaceDeviceRam_call.addr)
  return _internal_addr();
}
inline void xclWriteAddrSpaceDeviceRam_call::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.addr_ = value;
}
inline void xclWriteAddrSpaceDeviceRam_call::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrSpaceDeviceRam_call.addr)
}

// required uint32 size = 3;
inline bool xclWriteAddrSpaceDeviceRam_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclWriteAddrSpaceDeviceRam_call::has_size() const {
  return _internal_has_size();
}
inline void xclWriteAddrSpaceDeviceRam_call::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclWriteAddrSpaceDeviceRam_call::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclWriteAddrSpaceDeviceRam_call::size() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrSpaceDeviceRam_call.size)
  return _internal_size();
}
inline void xclWriteAddrSpaceDeviceRam_call::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclWriteAddrSpaceDeviceRam_call::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrSpaceDeviceRam_call.size)
}

// required bytes data = 4;
inline bool xclWriteAddrSpaceDeviceRam_call::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteAddrSpaceDeviceRam_call::has_data() const {
  return _internal_has_data();
}
inline void xclWriteAddrSpaceDeviceRam_call::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclWriteAddrSpaceDeviceRam_call::data() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrSpaceDeviceRam_call.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclWriteAddrSpaceDeviceRam_call::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclWriteAddrSpaceDeviceRam_call.data)
}
inline std::string* xclWriteAddrSpaceDeviceRam_call::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclWriteAddrSpaceDeviceRam_call.data)
  return _s;
}
inline const std::string& xclWriteAddrSpaceDeviceRam_call::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclWriteAddrSpaceDeviceRam_call::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclWriteAddrSpaceDeviceRam_call::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclWriteAddrSpaceDeviceRam_call::release_data() {
  // @@protoc_insertion_point(field_release:xclWriteAddrSpaceDeviceRam_call.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclWriteAddrSpaceDeviceRam_call::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclWriteAddrSpaceDeviceRam_call.data)
}

// optional uint32 PF_ID = 5;
inline bool xclWriteAddrSpaceDeviceRam_call::_internal_has_pf_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclWriteAddrSpaceDeviceRam_call::has_pf_id() const {
  return _internal_has_pf_id();
}
inline void xclWriteAddrSpaceDeviceRam_call::clear_pf_id() {
  _impl_.pf_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclWriteAddrSpaceDeviceRam_call::_internal_pf_id() const {
  return _impl_.pf_id_;
}
inline uint32_t xclWriteAddrSpaceDeviceRam_call::pf_id() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrSpaceDeviceRam_call.PF_ID)
  return _internal_pf_id();
}
inline void xclWriteAddrSpaceDeviceRam_call::_internal_set_pf_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pf_id_ = value;
}
inline void xclWriteAddrSpaceDeviceRam_call::set_pf_id(uint32_t value) {
  _internal_set_pf_id(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrSpaceDeviceRam_call.PF_ID)
}

// optional uint32 BAR_ID = 6;
inline bool xclWriteAddrSpaceDeviceRam_call::_internal_has_bar_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclWriteAddrSpaceDeviceRam_call::has_bar_id() const {
  return _internal_has_bar_id();
}
inline void xclWriteAddrSpaceDeviceRam_call::clear_bar_id() {
  _impl_.bar_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t xclWriteAddrSpaceDeviceRam_call::_internal_bar_id() const {
  return _impl_.bar_id_;
}
inline uint32_t xclWriteAddrSpaceDeviceRam_call::bar_id() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrSpaceDeviceRam_call.BAR_ID)
  return _internal_bar_id();
}
inline void xclWriteAddrSpaceDeviceRam_call::_internal_set_bar_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bar_id_ = value;
}
inline void xclWriteAddrSpaceDeviceRam_call::set_bar_id(uint32_t value) {
  _internal_set_bar_id(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrSpaceDeviceRam_call.BAR_ID)
}

// -------------------------------------------------------------------

// xclWriteAddrSpaceDeviceRam_response

// required bool valid = 1;
inline bool xclWriteAddrSpaceDeviceRam_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteAddrSpaceDeviceRam_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclWriteAddrSpaceDeviceRam_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclWriteAddrSpaceDeviceRam_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclWriteAddrSpaceDeviceRam_response::valid() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrSpaceDeviceRam_response.valid)
  return _internal_valid();
}
inline void xclWriteAddrSpaceDeviceRam_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valid_ = value;
}
inline void xclWriteAddrSpaceDeviceRam_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrSpaceDeviceRam_response.valid)
}

// -------------------------------------------------------------------

// xclWriteAddrKernelCtrl_call_kernelInfo

// optional uint64 addr = 1;
inline bool xclWriteAddrKernelCtrl_call_kernelInfo::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call_kernelInfo::has_addr() const {
  return _internal_has_addr();
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclWriteAddrKernelCtrl_call_kernelInfo::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclWriteAddrKernelCtrl_call_kernelInfo::addr() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.kernelInfo.addr)
  return _internal_addr();
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.addr_ = value;
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.kernelInfo.addr)
}

// optional uint32 size = 2;
inline bool xclWriteAddrKernelCtrl_call_kernelInfo::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call_kernelInfo::has_size() const {
  return _internal_has_size();
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclWriteAddrKernelCtrl_call_kernelInfo::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclWriteAddrKernelCtrl_call_kernelInfo::size() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.kernelInfo.size)
  return _internal_size();
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.kernelInfo.size)
}

// optional string name = 3;
inline bool xclWriteAddrKernelCtrl_call_kernelInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call_kernelInfo::has_name() const {
  return _internal_has_name();
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclWriteAddrKernelCtrl_call_kernelInfo::name() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.kernelInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclWriteAddrKernelCtrl_call_kernelInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.kernelInfo.name)
}
inline std::string* xclWriteAddrKernelCtrl_call_kernelInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:xclWriteAddrKernelCtrl_call.kernelInfo.name)
  return _s;
}
inline const std::string& xclWriteAddrKernelCtrl_call_kernelInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* xclWriteAddrKernelCtrl_call_kernelInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* xclWriteAddrKernelCtrl_call_kernelInfo::release_name() {
  // @@protoc_insertion_point(field_release:xclWriteAddrKernelCtrl_call.kernelInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclWriteAddrKernelCtrl_call_kernelInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclWriteAddrKernelCtrl_call.kernelInfo.name)
}

// -------------------------------------------------------------------

// xclWriteAddrKernelCtrl_call

// required uint64 addr = 2;
inline bool xclWriteAddrKernelCtrl_call::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call::has_addr() const {
  return _internal_has_addr();
}
inline void xclWriteAddrKernelCtrl_call::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclWriteAddrKernelCtrl_call::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclWriteAddrKernelCtrl_call::addr() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.addr)
  return _internal_addr();
}
inline void xclWriteAddrKernelCtrl_call::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.addr_ = value;
}
inline void xclWriteAddrKernelCtrl_call::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.addr)
}

// required uint32 size = 3;
inline bool xclWriteAddrKernelCtrl_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call::has_size() const {
  return _internal_has_size();
}
inline void xclWriteAddrKernelCtrl_call::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclWriteAddrKernelCtrl_call::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclWriteAddrKernelCtrl_call::size() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.size)
  return _internal_size();
}
inline void xclWriteAddrKernelCtrl_call::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclWriteAddrKernelCtrl_call::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.size)
}

// required bytes data = 4;
inline bool xclWriteAddrKernelCtrl_call::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call::has_data() const {
  return _internal_has_data();
}
inline void xclWriteAddrKernelCtrl_call::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclWriteAddrKernelCtrl_call::data() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclWriteAddrKernelCtrl_call::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.data)
}
inline std::string* xclWriteAddrKernelCtrl_call::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclWriteAddrKernelCtrl_call.data)
  return _s;
}
inline const std::string& xclWriteAddrKernelCtrl_call::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclWriteAddrKernelCtrl_call::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclWriteAddrKernelCtrl_call::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclWriteAddrKernelCtrl_call::release_data() {
  // @@protoc_insertion_point(field_release:xclWriteAddrKernelCtrl_call.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclWriteAddrKernelCtrl_call::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclWriteAddrKernelCtrl_call.data)
}

// repeated .xclWriteAddrKernelCtrl_call.kernelInfo kernel_info = 5;
inline int xclWriteAddrKernelCtrl_call::_internal_kernel_info_size() const {
  return _impl_.kernel_info_.size();
}
inline int xclWriteAddrKernelCtrl_call::kernel_info_size() const {
  return _internal_kernel_info_size();
}
inline void xclWriteAddrKernelCtrl_call::clear_kernel_info() {
  _impl_.kernel_info_.Clear();
}
inline ::xclWriteAddrKernelCtrl_call_kernelInfo* xclWriteAddrKernelCtrl_call::mutable_kernel_info(int index) {
  // @@protoc_insertion_point(field_mutable:xclWriteAddrKernelCtrl_call.kernel_info)
  return _impl_.kernel_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclWriteAddrKernelCtrl_call_kernelInfo >*
xclWriteAddrKernelCtrl_call::mutable_kernel_info() {
  // @@protoc_insertion_point(field_mutable_list:xclWriteAddrKernelCtrl_call.kernel_info)
  return &_impl_.kernel_info_;
}
inline const ::xclWriteAddrKernelCtrl_call_kernelInfo& xclWriteAddrKernelCtrl_call::_internal_kernel_info(int index) const {
  return _impl_.kernel_info_.Get(index);
}
inline const ::xclWriteAddrKernelCtrl_call_kernelInfo& xclWriteAddrKernelCtrl_call::kernel_info(int index) const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.kernel_info)
  return _internal_kernel_info(index);
}
inline ::xclWriteAddrKernelCtrl_call_kernelInfo* xclWriteAddrKernelCtrl_call::_internal_add_kernel_info() {
  return _impl_.kernel_info_.Add();
}
inline ::xclWriteAddrKernelCtrl_call_kernelInfo* xclWriteAddrKernelCtrl_call::add_kernel_info() {
  ::xclWriteAddrKernelCtrl_call_kernelInfo* _add = _internal_add_kernel_info();
  // @@protoc_insertion_point(field_add:xclWriteAddrKernelCtrl_call.kernel_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclWriteAddrKernelCtrl_call_kernelInfo >&
xclWriteAddrKernelCtrl_call::kernel_info() const {
  // @@protoc_insertion_point(field_list:xclWriteAddrKernelCtrl_call.kernel_info)
  return _impl_.kernel_info_;
}

// optional uint32 PF_ID = 6;
inline bool xclWriteAddrKernelCtrl_call::_internal_has_pf_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call::has_pf_id() const {
  return _internal_has_pf_id();
}
inline void xclWriteAddrKernelCtrl_call::clear_pf_id() {
  _impl_.pf_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclWriteAddrKernelCtrl_call::_internal_pf_id() const {
  return _impl_.pf_id_;
}
inline uint32_t xclWriteAddrKernelCtrl_call::pf_id() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.PF_ID)
  return _internal_pf_id();
}
inline void xclWriteAddrKernelCtrl_call::_internal_set_pf_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pf_id_ = value;
}
inline void xclWriteAddrKernelCtrl_call::set_pf_id(uint32_t value) {
  _internal_set_pf_id(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.PF_ID)
}

// optional uint32 BAR_ID = 7;
inline bool xclWriteAddrKernelCtrl_call::_internal_has_bar_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_call::has_bar_id() const {
  return _internal_has_bar_id();
}
inline void xclWriteAddrKernelCtrl_call::clear_bar_id() {
  _impl_.bar_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t xclWriteAddrKernelCtrl_call::_internal_bar_id() const {
  return _impl_.bar_id_;
}
inline uint32_t xclWriteAddrKernelCtrl_call::bar_id() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_call.BAR_ID)
  return _internal_bar_id();
}
inline void xclWriteAddrKernelCtrl_call::_internal_set_bar_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bar_id_ = value;
}
inline void xclWriteAddrKernelCtrl_call::set_bar_id(uint32_t value) {
  _internal_set_bar_id(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_call.BAR_ID)
}

// -------------------------------------------------------------------

// xclWriteAddrKernelCtrl_response

// required bool valid = 1;
inline bool xclWriteAddrKernelCtrl_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteAddrKernelCtrl_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclWriteAddrKernelCtrl_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclWriteAddrKernelCtrl_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclWriteAddrKernelCtrl_response::valid() const {
  // @@protoc_insertion_point(field_get:xclWriteAddrKernelCtrl_response.valid)
  return _internal_valid();
}
inline void xclWriteAddrKernelCtrl_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valid_ = value;
}
inline void xclWriteAddrKernelCtrl_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclWriteAddrKernelCtrl_response.valid)
}

// -------------------------------------------------------------------

// xclReadAddrSpaceDeviceRam_call

// required uint64 addr = 2;
inline bool xclReadAddrSpaceDeviceRam_call::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_call::has_addr() const {
  return _internal_has_addr();
}
inline void xclReadAddrSpaceDeviceRam_call::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclReadAddrSpaceDeviceRam_call::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclReadAddrSpaceDeviceRam_call::addr() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_call.addr)
  return _internal_addr();
}
inline void xclReadAddrSpaceDeviceRam_call::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.addr_ = value;
}
inline void xclReadAddrSpaceDeviceRam_call::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_call.addr)
}

// required uint32 size = 3;
inline bool xclReadAddrSpaceDeviceRam_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_call::has_size() const {
  return _internal_has_size();
}
inline void xclReadAddrSpaceDeviceRam_call::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclReadAddrSpaceDeviceRam_call::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclReadAddrSpaceDeviceRam_call::size() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_call.size)
  return _internal_size();
}
inline void xclReadAddrSpaceDeviceRam_call::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclReadAddrSpaceDeviceRam_call::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_call.size)
}

// optional bytes data = 4;
inline bool xclReadAddrSpaceDeviceRam_call::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_call::has_data() const {
  return _internal_has_data();
}
inline void xclReadAddrSpaceDeviceRam_call::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclReadAddrSpaceDeviceRam_call::data() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_call.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclReadAddrSpaceDeviceRam_call::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_call.data)
}
inline std::string* xclReadAddrSpaceDeviceRam_call::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclReadAddrSpaceDeviceRam_call.data)
  return _s;
}
inline const std::string& xclReadAddrSpaceDeviceRam_call::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclReadAddrSpaceDeviceRam_call::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclReadAddrSpaceDeviceRam_call::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclReadAddrSpaceDeviceRam_call::release_data() {
  // @@protoc_insertion_point(field_release:xclReadAddrSpaceDeviceRam_call.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclReadAddrSpaceDeviceRam_call::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclReadAddrSpaceDeviceRam_call.data)
}

// optional uint32 PF_ID = 5;
inline bool xclReadAddrSpaceDeviceRam_call::_internal_has_pf_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_call::has_pf_id() const {
  return _internal_has_pf_id();
}
inline void xclReadAddrSpaceDeviceRam_call::clear_pf_id() {
  _impl_.pf_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclReadAddrSpaceDeviceRam_call::_internal_pf_id() const {
  return _impl_.pf_id_;
}
inline uint32_t xclReadAddrSpaceDeviceRam_call::pf_id() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_call.PF_ID)
  return _internal_pf_id();
}
inline void xclReadAddrSpaceDeviceRam_call::_internal_set_pf_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pf_id_ = value;
}
inline void xclReadAddrSpaceDeviceRam_call::set_pf_id(uint32_t value) {
  _internal_set_pf_id(value);
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_call.PF_ID)
}

// optional uint32 BAR_ID = 6;
inline bool xclReadAddrSpaceDeviceRam_call::_internal_has_bar_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_call::has_bar_id() const {
  return _internal_has_bar_id();
}
inline void xclReadAddrSpaceDeviceRam_call::clear_bar_id() {
  _impl_.bar_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t xclReadAddrSpaceDeviceRam_call::_internal_bar_id() const {
  return _impl_.bar_id_;
}
inline uint32_t xclReadAddrSpaceDeviceRam_call::bar_id() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_call.BAR_ID)
  return _internal_bar_id();
}
inline void xclReadAddrSpaceDeviceRam_call::_internal_set_bar_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bar_id_ = value;
}
inline void xclReadAddrSpaceDeviceRam_call::set_bar_id(uint32_t value) {
  _internal_set_bar_id(value);
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_call.BAR_ID)
}

// -------------------------------------------------------------------

// xclReadAddrSpaceDeviceRam_response

// required bool valid = 1;
inline bool xclReadAddrSpaceDeviceRam_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclReadAddrSpaceDeviceRam_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclReadAddrSpaceDeviceRam_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclReadAddrSpaceDeviceRam_response::valid() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_response.valid)
  return _internal_valid();
}
inline void xclReadAddrSpaceDeviceRam_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.valid_ = value;
}
inline void xclReadAddrSpaceDeviceRam_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_response.valid)
}

// optional bytes data = 2;
inline bool xclReadAddrSpaceDeviceRam_response::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadAddrSpaceDeviceRam_response::has_data() const {
  return _internal_has_data();
}
inline void xclReadAddrSpaceDeviceRam_response::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclReadAddrSpaceDeviceRam_response::data() const {
  // @@protoc_insertion_point(field_get:xclReadAddrSpaceDeviceRam_response.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclReadAddrSpaceDeviceRam_response::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclReadAddrSpaceDeviceRam_response.data)
}
inline std::string* xclReadAddrSpaceDeviceRam_response::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclReadAddrSpaceDeviceRam_response.data)
  return _s;
}
inline const std::string& xclReadAddrSpaceDeviceRam_response::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclReadAddrSpaceDeviceRam_response::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclReadAddrSpaceDeviceRam_response::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclReadAddrSpaceDeviceRam_response::release_data() {
  // @@protoc_insertion_point(field_release:xclReadAddrSpaceDeviceRam_response.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclReadAddrSpaceDeviceRam_response::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclReadAddrSpaceDeviceRam_response.data)
}

// -------------------------------------------------------------------

// xclReadAddrKernelCtrl_call

// required uint64 addr = 2;
inline bool xclReadAddrKernelCtrl_call::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_call::has_addr() const {
  return _internal_has_addr();
}
inline void xclReadAddrKernelCtrl_call::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclReadAddrKernelCtrl_call::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclReadAddrKernelCtrl_call::addr() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_call.addr)
  return _internal_addr();
}
inline void xclReadAddrKernelCtrl_call::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.addr_ = value;
}
inline void xclReadAddrKernelCtrl_call::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_call.addr)
}

// required uint32 size = 3;
inline bool xclReadAddrKernelCtrl_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_call::has_size() const {
  return _internal_has_size();
}
inline void xclReadAddrKernelCtrl_call::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclReadAddrKernelCtrl_call::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclReadAddrKernelCtrl_call::size() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_call.size)
  return _internal_size();
}
inline void xclReadAddrKernelCtrl_call::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclReadAddrKernelCtrl_call::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_call.size)
}

// optional bytes data = 4;
inline bool xclReadAddrKernelCtrl_call::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_call::has_data() const {
  return _internal_has_data();
}
inline void xclReadAddrKernelCtrl_call::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclReadAddrKernelCtrl_call::data() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_call.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclReadAddrKernelCtrl_call::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_call.data)
}
inline std::string* xclReadAddrKernelCtrl_call::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclReadAddrKernelCtrl_call.data)
  return _s;
}
inline const std::string& xclReadAddrKernelCtrl_call::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclReadAddrKernelCtrl_call::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclReadAddrKernelCtrl_call::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclReadAddrKernelCtrl_call::release_data() {
  // @@protoc_insertion_point(field_release:xclReadAddrKernelCtrl_call.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclReadAddrKernelCtrl_call::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclReadAddrKernelCtrl_call.data)
}

// optional uint32 PF_ID = 5;
inline bool xclReadAddrKernelCtrl_call::_internal_has_pf_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_call::has_pf_id() const {
  return _internal_has_pf_id();
}
inline void xclReadAddrKernelCtrl_call::clear_pf_id() {
  _impl_.pf_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclReadAddrKernelCtrl_call::_internal_pf_id() const {
  return _impl_.pf_id_;
}
inline uint32_t xclReadAddrKernelCtrl_call::pf_id() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_call.PF_ID)
  return _internal_pf_id();
}
inline void xclReadAddrKernelCtrl_call::_internal_set_pf_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pf_id_ = value;
}
inline void xclReadAddrKernelCtrl_call::set_pf_id(uint32_t value) {
  _internal_set_pf_id(value);
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_call.PF_ID)
}

// optional uint32 BAR_ID = 6;
inline bool xclReadAddrKernelCtrl_call::_internal_has_bar_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_call::has_bar_id() const {
  return _internal_has_bar_id();
}
inline void xclReadAddrKernelCtrl_call::clear_bar_id() {
  _impl_.bar_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t xclReadAddrKernelCtrl_call::_internal_bar_id() const {
  return _impl_.bar_id_;
}
inline uint32_t xclReadAddrKernelCtrl_call::bar_id() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_call.BAR_ID)
  return _internal_bar_id();
}
inline void xclReadAddrKernelCtrl_call::_internal_set_bar_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bar_id_ = value;
}
inline void xclReadAddrKernelCtrl_call::set_bar_id(uint32_t value) {
  _internal_set_bar_id(value);
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_call.BAR_ID)
}

// -------------------------------------------------------------------

// xclReadAddrKernelCtrl_response

// required bool valid = 1;
inline bool xclReadAddrKernelCtrl_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclReadAddrKernelCtrl_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclReadAddrKernelCtrl_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclReadAddrKernelCtrl_response::valid() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_response.valid)
  return _internal_valid();
}
inline void xclReadAddrKernelCtrl_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.valid_ = value;
}
inline void xclReadAddrKernelCtrl_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_response.valid)
}

// optional bytes data = 2;
inline bool xclReadAddrKernelCtrl_response::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadAddrKernelCtrl_response::has_data() const {
  return _internal_has_data();
}
inline void xclReadAddrKernelCtrl_response::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclReadAddrKernelCtrl_response::data() const {
  // @@protoc_insertion_point(field_get:xclReadAddrKernelCtrl_response.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclReadAddrKernelCtrl_response::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclReadAddrKernelCtrl_response.data)
}
inline std::string* xclReadAddrKernelCtrl_response::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclReadAddrKernelCtrl_response.data)
  return _s;
}
inline const std::string& xclReadAddrKernelCtrl_response::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclReadAddrKernelCtrl_response::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclReadAddrKernelCtrl_response::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclReadAddrKernelCtrl_response::release_data() {
  // @@protoc_insertion_point(field_release:xclReadAddrKernelCtrl_response.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclReadAddrKernelCtrl_response::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclReadAddrKernelCtrl_response.data)
}

// -------------------------------------------------------------------

// xclPerfMonReadCounters_call

// required string slotname = 1;
inline bool xclPerfMonReadCounters_call::_internal_has_slotname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_call::has_slotname() const {
  return _internal_has_slotname();
}
inline void xclPerfMonReadCounters_call::clear_slotname() {
  _impl_.slotname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclPerfMonReadCounters_call::slotname() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_call.slotname)
  return _internal_slotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclPerfMonReadCounters_call::set_slotname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.slotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_call.slotname)
}
inline std::string* xclPerfMonReadCounters_call::mutable_slotname() {
  std::string* _s = _internal_mutable_slotname();
  // @@protoc_insertion_point(field_mutable:xclPerfMonReadCounters_call.slotname)
  return _s;
}
inline const std::string& xclPerfMonReadCounters_call::_internal_slotname() const {
  return _impl_.slotname_.Get();
}
inline void xclPerfMonReadCounters_call::_internal_set_slotname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slotname_.Set(value, GetArenaForAllocation());
}
inline std::string* xclPerfMonReadCounters_call::_internal_mutable_slotname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.slotname_.Mutable(GetArenaForAllocation());
}
inline std::string* xclPerfMonReadCounters_call::release_slotname() {
  // @@protoc_insertion_point(field_release:xclPerfMonReadCounters_call.slotname)
  if (!_internal_has_slotname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.slotname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclPerfMonReadCounters_call::set_allocated_slotname(std::string* slotname) {
  if (slotname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.slotname_.SetAllocated(slotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclPerfMonReadCounters_call.slotname)
}

// optional bool accel = 2;
inline bool xclPerfMonReadCounters_call::_internal_has_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_call::has_accel() const {
  return _internal_has_accel();
}
inline void xclPerfMonReadCounters_call::clear_accel() {
  _impl_.accel_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclPerfMonReadCounters_call::_internal_accel() const {
  return _impl_.accel_;
}
inline bool xclPerfMonReadCounters_call::accel() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_call.accel)
  return _internal_accel();
}
inline void xclPerfMonReadCounters_call::_internal_set_accel(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.accel_ = value;
}
inline void xclPerfMonReadCounters_call::set_accel(bool value) {
  _internal_set_accel(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_call.accel)
}

// -------------------------------------------------------------------

// xclPerfMonReadCounters_response

// optional uint32 wr_byte_count = 1;
inline bool xclPerfMonReadCounters_response::_internal_has_wr_byte_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_response::has_wr_byte_count() const {
  return _internal_has_wr_byte_count();
}
inline void xclPerfMonReadCounters_response::clear_wr_byte_count() {
  _impl_.wr_byte_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t xclPerfMonReadCounters_response::_internal_wr_byte_count() const {
  return _impl_.wr_byte_count_;
}
inline uint32_t xclPerfMonReadCounters_response::wr_byte_count() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_response.wr_byte_count)
  return _internal_wr_byte_count();
}
inline void xclPerfMonReadCounters_response::_internal_set_wr_byte_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.wr_byte_count_ = value;
}
inline void xclPerfMonReadCounters_response::set_wr_byte_count(uint32_t value) {
  _internal_set_wr_byte_count(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_response.wr_byte_count)
}

// optional uint32 wr_trans_count = 2;
inline bool xclPerfMonReadCounters_response::_internal_has_wr_trans_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_response::has_wr_trans_count() const {
  return _internal_has_wr_trans_count();
}
inline void xclPerfMonReadCounters_response::clear_wr_trans_count() {
  _impl_.wr_trans_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t xclPerfMonReadCounters_response::_internal_wr_trans_count() const {
  return _impl_.wr_trans_count_;
}
inline uint32_t xclPerfMonReadCounters_response::wr_trans_count() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_response.wr_trans_count)
  return _internal_wr_trans_count();
}
inline void xclPerfMonReadCounters_response::_internal_set_wr_trans_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wr_trans_count_ = value;
}
inline void xclPerfMonReadCounters_response::set_wr_trans_count(uint32_t value) {
  _internal_set_wr_trans_count(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_response.wr_trans_count)
}

// optional uint32 total_wr_latency = 3;
inline bool xclPerfMonReadCounters_response::_internal_has_total_wr_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_response::has_total_wr_latency() const {
  return _internal_has_total_wr_latency();
}
inline void xclPerfMonReadCounters_response::clear_total_wr_latency() {
  _impl_.total_wr_latency_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclPerfMonReadCounters_response::_internal_total_wr_latency() const {
  return _impl_.total_wr_latency_;
}
inline uint32_t xclPerfMonReadCounters_response::total_wr_latency() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_response.total_wr_latency)
  return _internal_total_wr_latency();
}
inline void xclPerfMonReadCounters_response::_internal_set_total_wr_latency(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_wr_latency_ = value;
}
inline void xclPerfMonReadCounters_response::set_total_wr_latency(uint32_t value) {
  _internal_set_total_wr_latency(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_response.total_wr_latency)
}

// optional uint32 rd_byte_count = 4;
inline bool xclPerfMonReadCounters_response::_internal_has_rd_byte_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_response::has_rd_byte_count() const {
  return _internal_has_rd_byte_count();
}
inline void xclPerfMonReadCounters_response::clear_rd_byte_count() {
  _impl_.rd_byte_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclPerfMonReadCounters_response::_internal_rd_byte_count() const {
  return _impl_.rd_byte_count_;
}
inline uint32_t xclPerfMonReadCounters_response::rd_byte_count() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_response.rd_byte_count)
  return _internal_rd_byte_count();
}
inline void xclPerfMonReadCounters_response::_internal_set_rd_byte_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rd_byte_count_ = value;
}
inline void xclPerfMonReadCounters_response::set_rd_byte_count(uint32_t value) {
  _internal_set_rd_byte_count(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_response.rd_byte_count)
}

// optional uint32 rd_trans_count = 5;
inline bool xclPerfMonReadCounters_response::_internal_has_rd_trans_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_response::has_rd_trans_count() const {
  return _internal_has_rd_trans_count();
}
inline void xclPerfMonReadCounters_response::clear_rd_trans_count() {
  _impl_.rd_trans_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t xclPerfMonReadCounters_response::_internal_rd_trans_count() const {
  return _impl_.rd_trans_count_;
}
inline uint32_t xclPerfMonReadCounters_response::rd_trans_count() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_response.rd_trans_count)
  return _internal_rd_trans_count();
}
inline void xclPerfMonReadCounters_response::_internal_set_rd_trans_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rd_trans_count_ = value;
}
inline void xclPerfMonReadCounters_response::set_rd_trans_count(uint32_t value) {
  _internal_set_rd_trans_count(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_response.rd_trans_count)
}

// optional uint32 total_rd_latency = 6;
inline bool xclPerfMonReadCounters_response::_internal_has_total_rd_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_response::has_total_rd_latency() const {
  return _internal_has_total_rd_latency();
}
inline void xclPerfMonReadCounters_response::clear_total_rd_latency() {
  _impl_.total_rd_latency_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t xclPerfMonReadCounters_response::_internal_total_rd_latency() const {
  return _impl_.total_rd_latency_;
}
inline uint32_t xclPerfMonReadCounters_response::total_rd_latency() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_response.total_rd_latency)
  return _internal_total_rd_latency();
}
inline void xclPerfMonReadCounters_response::_internal_set_total_rd_latency(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.total_rd_latency_ = value;
}
inline void xclPerfMonReadCounters_response::set_total_rd_latency(uint32_t value) {
  _internal_set_total_rd_latency(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_response.total_rd_latency)
}

// -------------------------------------------------------------------

// xclPerfMonGetTraceCount_call

// optional bool ack = 1;
inline bool xclPerfMonGetTraceCount_call::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonGetTraceCount_call::has_ack() const {
  return _internal_has_ack();
}
inline void xclPerfMonGetTraceCount_call::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclPerfMonGetTraceCount_call::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclPerfMonGetTraceCount_call::ack() const {
  // @@protoc_insertion_point(field_get:xclPerfMonGetTraceCount_call.ack)
  return _internal_ack();
}
inline void xclPerfMonGetTraceCount_call::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ack_ = value;
}
inline void xclPerfMonGetTraceCount_call::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclPerfMonGetTraceCount_call.ack)
}

// optional string slotname = 2;
inline bool xclPerfMonGetTraceCount_call::_internal_has_slotname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonGetTraceCount_call::has_slotname() const {
  return _internal_has_slotname();
}
inline void xclPerfMonGetTraceCount_call::clear_slotname() {
  _impl_.slotname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclPerfMonGetTraceCount_call::slotname() const {
  // @@protoc_insertion_point(field_get:xclPerfMonGetTraceCount_call.slotname)
  return _internal_slotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclPerfMonGetTraceCount_call::set_slotname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.slotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclPerfMonGetTraceCount_call.slotname)
}
inline std::string* xclPerfMonGetTraceCount_call::mutable_slotname() {
  std::string* _s = _internal_mutable_slotname();
  // @@protoc_insertion_point(field_mutable:xclPerfMonGetTraceCount_call.slotname)
  return _s;
}
inline const std::string& xclPerfMonGetTraceCount_call::_internal_slotname() const {
  return _impl_.slotname_.Get();
}
inline void xclPerfMonGetTraceCount_call::_internal_set_slotname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slotname_.Set(value, GetArenaForAllocation());
}
inline std::string* xclPerfMonGetTraceCount_call::_internal_mutable_slotname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.slotname_.Mutable(GetArenaForAllocation());
}
inline std::string* xclPerfMonGetTraceCount_call::release_slotname() {
  // @@protoc_insertion_point(field_release:xclPerfMonGetTraceCount_call.slotname)
  if (!_internal_has_slotname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.slotname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclPerfMonGetTraceCount_call::set_allocated_slotname(std::string* slotname) {
  if (slotname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.slotname_.SetAllocated(slotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclPerfMonGetTraceCount_call.slotname)
}

// optional bool accel = 3;
inline bool xclPerfMonGetTraceCount_call::_internal_has_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPerfMonGetTraceCount_call::has_accel() const {
  return _internal_has_accel();
}
inline void xclPerfMonGetTraceCount_call::clear_accel() {
  _impl_.accel_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool xclPerfMonGetTraceCount_call::_internal_accel() const {
  return _impl_.accel_;
}
inline bool xclPerfMonGetTraceCount_call::accel() const {
  // @@protoc_insertion_point(field_get:xclPerfMonGetTraceCount_call.accel)
  return _internal_accel();
}
inline void xclPerfMonGetTraceCount_call::_internal_set_accel(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.accel_ = value;
}
inline void xclPerfMonGetTraceCount_call::set_accel(bool value) {
  _internal_set_accel(value);
  // @@protoc_insertion_point(field_set:xclPerfMonGetTraceCount_call.accel)
}

// -------------------------------------------------------------------

// xclPerfMonGetTraceCount_response

// optional uint32 no_of_samples = 1;
inline bool xclPerfMonGetTraceCount_response::_internal_has_no_of_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonGetTraceCount_response::has_no_of_samples() const {
  return _internal_has_no_of_samples();
}
inline void xclPerfMonGetTraceCount_response::clear_no_of_samples() {
  _impl_.no_of_samples_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t xclPerfMonGetTraceCount_response::_internal_no_of_samples() const {
  return _impl_.no_of_samples_;
}
inline uint32_t xclPerfMonGetTraceCount_response::no_of_samples() const {
  // @@protoc_insertion_point(field_get:xclPerfMonGetTraceCount_response.no_of_samples)
  return _internal_no_of_samples();
}
inline void xclPerfMonGetTraceCount_response::_internal_set_no_of_samples(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.no_of_samples_ = value;
}
inline void xclPerfMonGetTraceCount_response::set_no_of_samples(uint32_t value) {
  _internal_set_no_of_samples(value);
  // @@protoc_insertion_point(field_set:xclPerfMonGetTraceCount_response.no_of_samples)
}

// -------------------------------------------------------------------

// xclPerfMonReadTrace_call

// optional bool ack = 1;
inline bool xclPerfMonReadTrace_call::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_call::has_ack() const {
  return _internal_has_ack();
}
inline void xclPerfMonReadTrace_call::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclPerfMonReadTrace_call::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclPerfMonReadTrace_call::ack() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_call.ack)
  return _internal_ack();
}
inline void xclPerfMonReadTrace_call::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ack_ = value;
}
inline void xclPerfMonReadTrace_call::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_call.ack)
}

// optional string slotname = 2;
inline bool xclPerfMonReadTrace_call::_internal_has_slotname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_call::has_slotname() const {
  return _internal_has_slotname();
}
inline void xclPerfMonReadTrace_call::clear_slotname() {
  _impl_.slotname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclPerfMonReadTrace_call::slotname() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_call.slotname)
  return _internal_slotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclPerfMonReadTrace_call::set_slotname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.slotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_call.slotname)
}
inline std::string* xclPerfMonReadTrace_call::mutable_slotname() {
  std::string* _s = _internal_mutable_slotname();
  // @@protoc_insertion_point(field_mutable:xclPerfMonReadTrace_call.slotname)
  return _s;
}
inline const std::string& xclPerfMonReadTrace_call::_internal_slotname() const {
  return _impl_.slotname_.Get();
}
inline void xclPerfMonReadTrace_call::_internal_set_slotname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slotname_.Set(value, GetArenaForAllocation());
}
inline std::string* xclPerfMonReadTrace_call::_internal_mutable_slotname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.slotname_.Mutable(GetArenaForAllocation());
}
inline std::string* xclPerfMonReadTrace_call::release_slotname() {
  // @@protoc_insertion_point(field_release:xclPerfMonReadTrace_call.slotname)
  if (!_internal_has_slotname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.slotname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclPerfMonReadTrace_call::set_allocated_slotname(std::string* slotname) {
  if (slotname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.slotname_.SetAllocated(slotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclPerfMonReadTrace_call.slotname)
}

// optional bool accel = 3;
inline bool xclPerfMonReadTrace_call::_internal_has_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_call::has_accel() const {
  return _internal_has_accel();
}
inline void xclPerfMonReadTrace_call::clear_accel() {
  _impl_.accel_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool xclPerfMonReadTrace_call::_internal_accel() const {
  return _impl_.accel_;
}
inline bool xclPerfMonReadTrace_call::accel() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_call.accel)
  return _internal_accel();
}
inline void xclPerfMonReadTrace_call::_internal_set_accel(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.accel_ = value;
}
inline void xclPerfMonReadTrace_call::set_accel(bool value) {
  _internal_set_accel(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_call.accel)
}

// -------------------------------------------------------------------

// xclPerfMonReadTrace_response_events

// optional uint32 awlen = 1;
inline bool xclPerfMonReadTrace_response_events::_internal_has_awlen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_awlen() const {
  return _internal_has_awlen();
}
inline void xclPerfMonReadTrace_response_events::clear_awlen() {
  _impl_.awlen_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t xclPerfMonReadTrace_response_events::_internal_awlen() const {
  return _impl_.awlen_;
}
inline uint32_t xclPerfMonReadTrace_response_events::awlen() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.awlen)
  return _internal_awlen();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_awlen(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.awlen_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_awlen(uint32_t value) {
  _internal_set_awlen(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.awlen)
}

// optional uint32 arlen = 2;
inline bool xclPerfMonReadTrace_response_events::_internal_has_arlen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_arlen() const {
  return _internal_has_arlen();
}
inline void xclPerfMonReadTrace_response_events::clear_arlen() {
  _impl_.arlen_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t xclPerfMonReadTrace_response_events::_internal_arlen() const {
  return _impl_.arlen_;
}
inline uint32_t xclPerfMonReadTrace_response_events::arlen() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.arlen)
  return _internal_arlen();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_arlen(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.arlen_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_arlen(uint32_t value) {
  _internal_set_arlen(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.arlen)
}

// optional uint32 eventflags = 3;
inline bool xclPerfMonReadTrace_response_events::_internal_has_eventflags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_eventflags() const {
  return _internal_has_eventflags();
}
inline void xclPerfMonReadTrace_response_events::clear_eventflags() {
  _impl_.eventflags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclPerfMonReadTrace_response_events::_internal_eventflags() const {
  return _impl_.eventflags_;
}
inline uint32_t xclPerfMonReadTrace_response_events::eventflags() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.eventflags)
  return _internal_eventflags();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_eventflags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.eventflags_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_eventflags(uint32_t value) {
  _internal_set_eventflags(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.eventflags)
}

// optional uint32 timestamp = 4;
inline bool xclPerfMonReadTrace_response_events::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void xclPerfMonReadTrace_response_events::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclPerfMonReadTrace_response_events::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t xclPerfMonReadTrace_response_events::timestamp() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.timestamp)
  return _internal_timestamp();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.timestamp)
}

// optional uint64 host_timestamp = 5;
inline bool xclPerfMonReadTrace_response_events::_internal_has_host_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_host_timestamp() const {
  return _internal_has_host_timestamp();
}
inline void xclPerfMonReadTrace_response_events::clear_host_timestamp() {
  _impl_.host_timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclPerfMonReadTrace_response_events::_internal_host_timestamp() const {
  return _impl_.host_timestamp_;
}
inline uint64_t xclPerfMonReadTrace_response_events::host_timestamp() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.host_timestamp)
  return _internal_host_timestamp();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_host_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.host_timestamp_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_host_timestamp(uint64_t value) {
  _internal_set_host_timestamp(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.host_timestamp)
}

// optional uint32 rd_bytes = 6;
inline bool xclPerfMonReadTrace_response_events::_internal_has_rd_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_rd_bytes() const {
  return _internal_has_rd_bytes();
}
inline void xclPerfMonReadTrace_response_events::clear_rd_bytes() {
  _impl_.rd_bytes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t xclPerfMonReadTrace_response_events::_internal_rd_bytes() const {
  return _impl_.rd_bytes_;
}
inline uint32_t xclPerfMonReadTrace_response_events::rd_bytes() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.rd_bytes)
  return _internal_rd_bytes();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_rd_bytes(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.rd_bytes_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_rd_bytes(uint32_t value) {
  _internal_set_rd_bytes(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.rd_bytes)
}

// optional uint32 wr_bytes = 7;
inline bool xclPerfMonReadTrace_response_events::_internal_has_wr_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_response_events::has_wr_bytes() const {
  return _internal_has_wr_bytes();
}
inline void xclPerfMonReadTrace_response_events::clear_wr_bytes() {
  _impl_.wr_bytes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t xclPerfMonReadTrace_response_events::_internal_wr_bytes() const {
  return _impl_.wr_bytes_;
}
inline uint32_t xclPerfMonReadTrace_response_events::wr_bytes() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.events.wr_bytes)
  return _internal_wr_bytes();
}
inline void xclPerfMonReadTrace_response_events::_internal_set_wr_bytes(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.wr_bytes_ = value;
}
inline void xclPerfMonReadTrace_response_events::set_wr_bytes(uint32_t value) {
  _internal_set_wr_bytes(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_response.events.wr_bytes)
}

// -------------------------------------------------------------------

// xclPerfMonReadTrace_response

// repeated .xclPerfMonReadTrace_response.events output_data = 8;
inline int xclPerfMonReadTrace_response::_internal_output_data_size() const {
  return _impl_.output_data_.size();
}
inline int xclPerfMonReadTrace_response::output_data_size() const {
  return _internal_output_data_size();
}
inline void xclPerfMonReadTrace_response::clear_output_data() {
  _impl_.output_data_.Clear();
}
inline ::xclPerfMonReadTrace_response_events* xclPerfMonReadTrace_response::mutable_output_data(int index) {
  // @@protoc_insertion_point(field_mutable:xclPerfMonReadTrace_response.output_data)
  return _impl_.output_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_response_events >*
xclPerfMonReadTrace_response::mutable_output_data() {
  // @@protoc_insertion_point(field_mutable_list:xclPerfMonReadTrace_response.output_data)
  return &_impl_.output_data_;
}
inline const ::xclPerfMonReadTrace_response_events& xclPerfMonReadTrace_response::_internal_output_data(int index) const {
  return _impl_.output_data_.Get(index);
}
inline const ::xclPerfMonReadTrace_response_events& xclPerfMonReadTrace_response::output_data(int index) const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_response.output_data)
  return _internal_output_data(index);
}
inline ::xclPerfMonReadTrace_response_events* xclPerfMonReadTrace_response::_internal_add_output_data() {
  return _impl_.output_data_.Add();
}
inline ::xclPerfMonReadTrace_response_events* xclPerfMonReadTrace_response::add_output_data() {
  ::xclPerfMonReadTrace_response_events* _add = _internal_add_output_data();
  // @@protoc_insertion_point(field_add:xclPerfMonReadTrace_response.output_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_response_events >&
xclPerfMonReadTrace_response::output_data() const {
  // @@protoc_insertion_point(field_list:xclPerfMonReadTrace_response.output_data)
  return _impl_.output_data_;
}

// -------------------------------------------------------------------

// ddr_mem_msg

// required bytes data = 1;
inline bool ddr_mem_msg::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ddr_mem_msg::has_data() const {
  return _internal_has_data();
}
inline void ddr_mem_msg::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ddr_mem_msg::data() const {
  // @@protoc_insertion_point(field_get:ddr_mem_msg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ddr_mem_msg::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ddr_mem_msg.data)
}
inline std::string* ddr_mem_msg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ddr_mem_msg.data)
  return _s;
}
inline const std::string& ddr_mem_msg::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ddr_mem_msg::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ddr_mem_msg::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ddr_mem_msg::release_data() {
  // @@protoc_insertion_point(field_release:ddr_mem_msg.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ddr_mem_msg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ddr_mem_msg.data)
}

// optional uint64 size = 2;
inline bool ddr_mem_msg::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ddr_mem_msg::has_size() const {
  return _internal_has_size();
}
inline void ddr_mem_msg::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ddr_mem_msg::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t ddr_mem_msg::size() const {
  // @@protoc_insertion_point(field_get:ddr_mem_msg.size)
  return _internal_size();
}
inline void ddr_mem_msg::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void ddr_mem_msg::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:ddr_mem_msg.size)
}

// optional bytes strb_data = 3;
inline bool ddr_mem_msg::_internal_has_strb_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ddr_mem_msg::has_strb_data() const {
  return _internal_has_strb_data();
}
inline void ddr_mem_msg::clear_strb_data() {
  _impl_.strb_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ddr_mem_msg::strb_data() const {
  // @@protoc_insertion_point(field_get:ddr_mem_msg.strb_data)
  return _internal_strb_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ddr_mem_msg::set_strb_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.strb_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ddr_mem_msg.strb_data)
}
inline std::string* ddr_mem_msg::mutable_strb_data() {
  std::string* _s = _internal_mutable_strb_data();
  // @@protoc_insertion_point(field_mutable:ddr_mem_msg.strb_data)
  return _s;
}
inline const std::string& ddr_mem_msg::_internal_strb_data() const {
  return _impl_.strb_data_.Get();
}
inline void ddr_mem_msg::_internal_set_strb_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.strb_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ddr_mem_msg::_internal_mutable_strb_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.strb_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ddr_mem_msg::release_strb_data() {
  // @@protoc_insertion_point(field_release:ddr_mem_msg.strb_data)
  if (!_internal_has_strb_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.strb_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strb_data_.IsDefault()) {
    _impl_.strb_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ddr_mem_msg::set_allocated_strb_data(std::string* strb_data) {
  if (strb_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.strb_data_.SetAllocated(strb_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strb_data_.IsDefault()) {
    _impl_.strb_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ddr_mem_msg.strb_data)
}

// optional uint64 fullsize = 4;
inline bool ddr_mem_msg::_internal_has_fullsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ddr_mem_msg::has_fullsize() const {
  return _internal_has_fullsize();
}
inline void ddr_mem_msg::clear_fullsize() {
  _impl_.fullsize_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t ddr_mem_msg::_internal_fullsize() const {
  return _impl_.fullsize_;
}
inline uint64_t ddr_mem_msg::fullsize() const {
  // @@protoc_insertion_point(field_get:ddr_mem_msg.fullsize)
  return _internal_fullsize();
}
inline void ddr_mem_msg::_internal_set_fullsize(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fullsize_ = value;
}
inline void ddr_mem_msg::set_fullsize(uint64_t value) {
  _internal_set_fullsize(value);
  // @@protoc_insertion_point(field_set:ddr_mem_msg.fullsize)
}

// -------------------------------------------------------------------

// xclGetDeviceTimestamp_call

// optional bool ack = 1;
inline bool xclGetDeviceTimestamp_call::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclGetDeviceTimestamp_call::has_ack() const {
  return _internal_has_ack();
}
inline void xclGetDeviceTimestamp_call::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclGetDeviceTimestamp_call::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclGetDeviceTimestamp_call::ack() const {
  // @@protoc_insertion_point(field_get:xclGetDeviceTimestamp_call.ack)
  return _internal_ack();
}
inline void xclGetDeviceTimestamp_call::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclGetDeviceTimestamp_call::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclGetDeviceTimestamp_call.ack)
}

// -------------------------------------------------------------------

// xclGetDeviceTimestamp_response

// required uint64 device_timestamp = 1;
inline bool xclGetDeviceTimestamp_response::_internal_has_device_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclGetDeviceTimestamp_response::has_device_timestamp() const {
  return _internal_has_device_timestamp();
}
inline void xclGetDeviceTimestamp_response::clear_device_timestamp() {
  _impl_.device_timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclGetDeviceTimestamp_response::_internal_device_timestamp() const {
  return _impl_.device_timestamp_;
}
inline uint64_t xclGetDeviceTimestamp_response::device_timestamp() const {
  // @@protoc_insertion_point(field_get:xclGetDeviceTimestamp_response.device_timestamp)
  return _internal_device_timestamp();
}
inline void xclGetDeviceTimestamp_response::_internal_set_device_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_timestamp_ = value;
}
inline void xclGetDeviceTimestamp_response::set_device_timestamp(uint64_t value) {
  _internal_set_device_timestamp(value);
  // @@protoc_insertion_point(field_set:xclGetDeviceTimestamp_response.device_timestamp)
}

// -------------------------------------------------------------------

// xclReadBusStatus_call

// optional int32 slot_n = 1;
inline bool xclReadBusStatus_call::_internal_has_slot_n() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadBusStatus_call::has_slot_n() const {
  return _internal_has_slot_n();
}
inline void xclReadBusStatus_call::clear_slot_n() {
  _impl_.slot_n_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t xclReadBusStatus_call::_internal_slot_n() const {
  return _impl_.slot_n_;
}
inline int32_t xclReadBusStatus_call::slot_n() const {
  // @@protoc_insertion_point(field_get:xclReadBusStatus_call.slot_n)
  return _internal_slot_n();
}
inline void xclReadBusStatus_call::_internal_set_slot_n(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slot_n_ = value;
}
inline void xclReadBusStatus_call::set_slot_n(int32_t value) {
  _internal_set_slot_n(value);
  // @@protoc_insertion_point(field_set:xclReadBusStatus_call.slot_n)
}

// -------------------------------------------------------------------

// xclReadBusStatus_response

// optional uint64 uncomplete_rd_cycles = 1;
inline bool xclReadBusStatus_response::_internal_has_uncomplete_rd_cycles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadBusStatus_response::has_uncomplete_rd_cycles() const {
  return _internal_has_uncomplete_rd_cycles();
}
inline void xclReadBusStatus_response::clear_uncomplete_rd_cycles() {
  _impl_.uncomplete_rd_cycles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclReadBusStatus_response::_internal_uncomplete_rd_cycles() const {
  return _impl_.uncomplete_rd_cycles_;
}
inline uint64_t xclReadBusStatus_response::uncomplete_rd_cycles() const {
  // @@protoc_insertion_point(field_get:xclReadBusStatus_response.uncomplete_rd_cycles)
  return _internal_uncomplete_rd_cycles();
}
inline void xclReadBusStatus_response::_internal_set_uncomplete_rd_cycles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uncomplete_rd_cycles_ = value;
}
inline void xclReadBusStatus_response::set_uncomplete_rd_cycles(uint64_t value) {
  _internal_set_uncomplete_rd_cycles(value);
  // @@protoc_insertion_point(field_set:xclReadBusStatus_response.uncomplete_rd_cycles)
}

// optional uint64 uncomplete_wr_cycles = 2;
inline bool xclReadBusStatus_response::_internal_has_uncomplete_wr_cycles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadBusStatus_response::has_uncomplete_wr_cycles() const {
  return _internal_has_uncomplete_wr_cycles();
}
inline void xclReadBusStatus_response::clear_uncomplete_wr_cycles() {
  _impl_.uncomplete_wr_cycles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclReadBusStatus_response::_internal_uncomplete_wr_cycles() const {
  return _impl_.uncomplete_wr_cycles_;
}
inline uint64_t xclReadBusStatus_response::uncomplete_wr_cycles() const {
  // @@protoc_insertion_point(field_get:xclReadBusStatus_response.uncomplete_wr_cycles)
  return _internal_uncomplete_wr_cycles();
}
inline void xclReadBusStatus_response::_internal_set_uncomplete_wr_cycles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uncomplete_wr_cycles_ = value;
}
inline void xclReadBusStatus_response::set_uncomplete_wr_cycles(uint64_t value) {
  _internal_set_uncomplete_wr_cycles(value);
  // @@protoc_insertion_point(field_set:xclReadBusStatus_response.uncomplete_wr_cycles)
}

// optional uint64 idle_bus_cycles = 3;
inline bool xclReadBusStatus_response::_internal_has_idle_bus_cycles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclReadBusStatus_response::has_idle_bus_cycles() const {
  return _internal_has_idle_bus_cycles();
}
inline void xclReadBusStatus_response::clear_idle_bus_cycles() {
  _impl_.idle_bus_cycles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclReadBusStatus_response::_internal_idle_bus_cycles() const {
  return _impl_.idle_bus_cycles_;
}
inline uint64_t xclReadBusStatus_response::idle_bus_cycles() const {
  // @@protoc_insertion_point(field_get:xclReadBusStatus_response.idle_bus_cycles)
  return _internal_idle_bus_cycles();
}
inline void xclReadBusStatus_response::_internal_set_idle_bus_cycles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.idle_bus_cycles_ = value;
}
inline void xclReadBusStatus_response::set_idle_bus_cycles(uint64_t value) {
  _internal_set_idle_bus_cycles(value);
  // @@protoc_insertion_point(field_set:xclReadBusStatus_response.idle_bus_cycles)
}

// optional uint64 uncomplete_rd_id = 4;
inline bool xclReadBusStatus_response::_internal_has_uncomplete_rd_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclReadBusStatus_response::has_uncomplete_rd_id() const {
  return _internal_has_uncomplete_rd_id();
}
inline void xclReadBusStatus_response::clear_uncomplete_rd_id() {
  _impl_.uncomplete_rd_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclReadBusStatus_response::_internal_uncomplete_rd_id() const {
  return _impl_.uncomplete_rd_id_;
}
inline uint64_t xclReadBusStatus_response::uncomplete_rd_id() const {
  // @@protoc_insertion_point(field_get:xclReadBusStatus_response.uncomplete_rd_id)
  return _internal_uncomplete_rd_id();
}
inline void xclReadBusStatus_response::_internal_set_uncomplete_rd_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.uncomplete_rd_id_ = value;
}
inline void xclReadBusStatus_response::set_uncomplete_rd_id(uint64_t value) {
  _internal_set_uncomplete_rd_id(value);
  // @@protoc_insertion_point(field_set:xclReadBusStatus_response.uncomplete_rd_id)
}

// optional uint64 uncomplete_wr_id = 5;
inline bool xclReadBusStatus_response::_internal_has_uncomplete_wr_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclReadBusStatus_response::has_uncomplete_wr_id() const {
  return _internal_has_uncomplete_wr_id();
}
inline void xclReadBusStatus_response::clear_uncomplete_wr_id() {
  _impl_.uncomplete_wr_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclReadBusStatus_response::_internal_uncomplete_wr_id() const {
  return _impl_.uncomplete_wr_id_;
}
inline uint64_t xclReadBusStatus_response::uncomplete_wr_id() const {
  // @@protoc_insertion_point(field_get:xclReadBusStatus_response.uncomplete_wr_id)
  return _internal_uncomplete_wr_id();
}
inline void xclReadBusStatus_response::_internal_set_uncomplete_wr_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.uncomplete_wr_id_ = value;
}
inline void xclReadBusStatus_response::set_uncomplete_wr_id(uint64_t value) {
  _internal_set_uncomplete_wr_id(value);
  // @@protoc_insertion_point(field_set:xclReadBusStatus_response.uncomplete_wr_id)
}

// -------------------------------------------------------------------

// xclGetDebugMessages_call

// optional bool ack = 1;
inline bool xclGetDebugMessages_call::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclGetDebugMessages_call::has_ack() const {
  return _internal_has_ack();
}
inline void xclGetDebugMessages_call::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclGetDebugMessages_call::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclGetDebugMessages_call::ack() const {
  // @@protoc_insertion_point(field_get:xclGetDebugMessages_call.ack)
  return _internal_ack();
}
inline void xclGetDebugMessages_call::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclGetDebugMessages_call::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclGetDebugMessages_call.ack)
}

// optional bool force = 2;
inline bool xclGetDebugMessages_call::_internal_has_force() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclGetDebugMessages_call::has_force() const {
  return _internal_has_force();
}
inline void xclGetDebugMessages_call::clear_force() {
  _impl_.force_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclGetDebugMessages_call::_internal_force() const {
  return _impl_.force_;
}
inline bool xclGetDebugMessages_call::force() const {
  // @@protoc_insertion_point(field_get:xclGetDebugMessages_call.force)
  return _internal_force();
}
inline void xclGetDebugMessages_call::_internal_set_force(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.force_ = value;
}
inline void xclGetDebugMessages_call::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:xclGetDebugMessages_call.force)
}

// -------------------------------------------------------------------

// xclGetDebugMessages_response

// optional bytes display_msgs = 1;
inline bool xclGetDebugMessages_response::_internal_has_display_msgs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclGetDebugMessages_response::has_display_msgs() const {
  return _internal_has_display_msgs();
}
inline void xclGetDebugMessages_response::clear_display_msgs() {
  _impl_.display_msgs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclGetDebugMessages_response::display_msgs() const {
  // @@protoc_insertion_point(field_get:xclGetDebugMessages_response.display_msgs)
  return _internal_display_msgs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclGetDebugMessages_response::set_display_msgs(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.display_msgs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclGetDebugMessages_response.display_msgs)
}
inline std::string* xclGetDebugMessages_response::mutable_display_msgs() {
  std::string* _s = _internal_mutable_display_msgs();
  // @@protoc_insertion_point(field_mutable:xclGetDebugMessages_response.display_msgs)
  return _s;
}
inline const std::string& xclGetDebugMessages_response::_internal_display_msgs() const {
  return _impl_.display_msgs_.Get();
}
inline void xclGetDebugMessages_response::_internal_set_display_msgs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.display_msgs_.Set(value, GetArenaForAllocation());
}
inline std::string* xclGetDebugMessages_response::_internal_mutable_display_msgs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.display_msgs_.Mutable(GetArenaForAllocation());
}
inline std::string* xclGetDebugMessages_response::release_display_msgs() {
  // @@protoc_insertion_point(field_release:xclGetDebugMessages_response.display_msgs)
  if (!_internal_has_display_msgs()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.display_msgs_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_msgs_.IsDefault()) {
    _impl_.display_msgs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclGetDebugMessages_response::set_allocated_display_msgs(std::string* display_msgs) {
  if (display_msgs != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.display_msgs_.SetAllocated(display_msgs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_msgs_.IsDefault()) {
    _impl_.display_msgs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclGetDebugMessages_response.display_msgs)
}

// optional bytes log_msgs = 2;
inline bool xclGetDebugMessages_response::_internal_has_log_msgs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclGetDebugMessages_response::has_log_msgs() const {
  return _internal_has_log_msgs();
}
inline void xclGetDebugMessages_response::clear_log_msgs() {
  _impl_.log_msgs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& xclGetDebugMessages_response::log_msgs() const {
  // @@protoc_insertion_point(field_get:xclGetDebugMessages_response.log_msgs)
  return _internal_log_msgs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclGetDebugMessages_response::set_log_msgs(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.log_msgs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclGetDebugMessages_response.log_msgs)
}
inline std::string* xclGetDebugMessages_response::mutable_log_msgs() {
  std::string* _s = _internal_mutable_log_msgs();
  // @@protoc_insertion_point(field_mutable:xclGetDebugMessages_response.log_msgs)
  return _s;
}
inline const std::string& xclGetDebugMessages_response::_internal_log_msgs() const {
  return _impl_.log_msgs_.Get();
}
inline void xclGetDebugMessages_response::_internal_set_log_msgs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.log_msgs_.Set(value, GetArenaForAllocation());
}
inline std::string* xclGetDebugMessages_response::_internal_mutable_log_msgs() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.log_msgs_.Mutable(GetArenaForAllocation());
}
inline std::string* xclGetDebugMessages_response::release_log_msgs() {
  // @@protoc_insertion_point(field_release:xclGetDebugMessages_response.log_msgs)
  if (!_internal_has_log_msgs()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.log_msgs_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.log_msgs_.IsDefault()) {
    _impl_.log_msgs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclGetDebugMessages_response::set_allocated_log_msgs(std::string* log_msgs) {
  if (log_msgs != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.log_msgs_.SetAllocated(log_msgs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.log_msgs_.IsDefault()) {
    _impl_.log_msgs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclGetDebugMessages_response.log_msgs)
}

// optional bytes stop_msgs = 3;
inline bool xclGetDebugMessages_response::_internal_has_stop_msgs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclGetDebugMessages_response::has_stop_msgs() const {
  return _internal_has_stop_msgs();
}
inline void xclGetDebugMessages_response::clear_stop_msgs() {
  _impl_.stop_msgs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& xclGetDebugMessages_response::stop_msgs() const {
  // @@protoc_insertion_point(field_get:xclGetDebugMessages_response.stop_msgs)
  return _internal_stop_msgs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclGetDebugMessages_response::set_stop_msgs(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.stop_msgs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclGetDebugMessages_response.stop_msgs)
}
inline std::string* xclGetDebugMessages_response::mutable_stop_msgs() {
  std::string* _s = _internal_mutable_stop_msgs();
  // @@protoc_insertion_point(field_mutable:xclGetDebugMessages_response.stop_msgs)
  return _s;
}
inline const std::string& xclGetDebugMessages_response::_internal_stop_msgs() const {
  return _impl_.stop_msgs_.Get();
}
inline void xclGetDebugMessages_response::_internal_set_stop_msgs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_msgs_.Set(value, GetArenaForAllocation());
}
inline std::string* xclGetDebugMessages_response::_internal_mutable_stop_msgs() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stop_msgs_.Mutable(GetArenaForAllocation());
}
inline std::string* xclGetDebugMessages_response::release_stop_msgs() {
  // @@protoc_insertion_point(field_release:xclGetDebugMessages_response.stop_msgs)
  if (!_internal_has_stop_msgs()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.stop_msgs_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_msgs_.IsDefault()) {
    _impl_.stop_msgs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclGetDebugMessages_response::set_allocated_stop_msgs(std::string* stop_msgs) {
  if (stop_msgs != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stop_msgs_.SetAllocated(stop_msgs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_msgs_.IsDefault()) {
    _impl_.stop_msgs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclGetDebugMessages_response.stop_msgs)
}

// -------------------------------------------------------------------

// xclImportBO_call

// optional string dst_filename = 1;
inline bool xclImportBO_call::_internal_has_dst_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclImportBO_call::has_dst_filename() const {
  return _internal_has_dst_filename();
}
inline void xclImportBO_call::clear_dst_filename() {
  _impl_.dst_filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclImportBO_call::dst_filename() const {
  // @@protoc_insertion_point(field_get:xclImportBO_call.dst_filename)
  return _internal_dst_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclImportBO_call::set_dst_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dst_filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclImportBO_call.dst_filename)
}
inline std::string* xclImportBO_call::mutable_dst_filename() {
  std::string* _s = _internal_mutable_dst_filename();
  // @@protoc_insertion_point(field_mutable:xclImportBO_call.dst_filename)
  return _s;
}
inline const std::string& xclImportBO_call::_internal_dst_filename() const {
  return _impl_.dst_filename_.Get();
}
inline void xclImportBO_call::_internal_set_dst_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dst_filename_.Set(value, GetArenaForAllocation());
}
inline std::string* xclImportBO_call::_internal_mutable_dst_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dst_filename_.Mutable(GetArenaForAllocation());
}
inline std::string* xclImportBO_call::release_dst_filename() {
  // @@protoc_insertion_point(field_release:xclImportBO_call.dst_filename)
  if (!_internal_has_dst_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dst_filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_filename_.IsDefault()) {
    _impl_.dst_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclImportBO_call::set_allocated_dst_filename(std::string* dst_filename) {
  if (dst_filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dst_filename_.SetAllocated(dst_filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_filename_.IsDefault()) {
    _impl_.dst_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclImportBO_call.dst_filename)
}

// optional uint64 offset = 2;
inline bool xclImportBO_call::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclImportBO_call::has_offset() const {
  return _internal_has_offset();
}
inline void xclImportBO_call::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclImportBO_call::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t xclImportBO_call::offset() const {
  // @@protoc_insertion_point(field_get:xclImportBO_call.offset)
  return _internal_offset();
}
inline void xclImportBO_call::_internal_set_offset(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}
inline void xclImportBO_call::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:xclImportBO_call.offset)
}

// optional uint64 size = 3;
inline bool xclImportBO_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclImportBO_call::has_size() const {
  return _internal_has_size();
}
inline void xclImportBO_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclImportBO_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclImportBO_call::size() const {
  // @@protoc_insertion_point(field_get:xclImportBO_call.size)
  return _internal_size();
}
inline void xclImportBO_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclImportBO_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclImportBO_call.size)
}

// -------------------------------------------------------------------

// xclImportBO_response

// optional bool ack = 1;
inline bool xclImportBO_response::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclImportBO_response::has_ack() const {
  return _internal_has_ack();
}
inline void xclImportBO_response::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclImportBO_response::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclImportBO_response::ack() const {
  // @@protoc_insertion_point(field_get:xclImportBO_response.ack)
  return _internal_ack();
}
inline void xclImportBO_response::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclImportBO_response::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclImportBO_response.ack)
}

// -------------------------------------------------------------------

// xclCopyBO_call

// optional uint64 src_handle = 1;
inline bool xclCopyBO_call::_internal_has_src_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclCopyBO_call::has_src_handle() const {
  return _internal_has_src_handle();
}
inline void xclCopyBO_call::clear_src_handle() {
  _impl_.src_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclCopyBO_call::_internal_src_handle() const {
  return _impl_.src_handle_;
}
inline uint64_t xclCopyBO_call::src_handle() const {
  // @@protoc_insertion_point(field_get:xclCopyBO_call.src_handle)
  return _internal_src_handle();
}
inline void xclCopyBO_call::_internal_set_src_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.src_handle_ = value;
}
inline void xclCopyBO_call::set_src_handle(uint64_t value) {
  _internal_set_src_handle(value);
  // @@protoc_insertion_point(field_set:xclCopyBO_call.src_handle)
}

// optional string dst_filename = 2;
inline bool xclCopyBO_call::_internal_has_dst_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCopyBO_call::has_dst_filename() const {
  return _internal_has_dst_filename();
}
inline void xclCopyBO_call::clear_dst_filename() {
  _impl_.dst_filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclCopyBO_call::dst_filename() const {
  // @@protoc_insertion_point(field_get:xclCopyBO_call.dst_filename)
  return _internal_dst_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclCopyBO_call::set_dst_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dst_filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclCopyBO_call.dst_filename)
}
inline std::string* xclCopyBO_call::mutable_dst_filename() {
  std::string* _s = _internal_mutable_dst_filename();
  // @@protoc_insertion_point(field_mutable:xclCopyBO_call.dst_filename)
  return _s;
}
inline const std::string& xclCopyBO_call::_internal_dst_filename() const {
  return _impl_.dst_filename_.Get();
}
inline void xclCopyBO_call::_internal_set_dst_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dst_filename_.Set(value, GetArenaForAllocation());
}
inline std::string* xclCopyBO_call::_internal_mutable_dst_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dst_filename_.Mutable(GetArenaForAllocation());
}
inline std::string* xclCopyBO_call::release_dst_filename() {
  // @@protoc_insertion_point(field_release:xclCopyBO_call.dst_filename)
  if (!_internal_has_dst_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dst_filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_filename_.IsDefault()) {
    _impl_.dst_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclCopyBO_call::set_allocated_dst_filename(std::string* dst_filename) {
  if (dst_filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dst_filename_.SetAllocated(dst_filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_filename_.IsDefault()) {
    _impl_.dst_filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclCopyBO_call.dst_filename)
}

// optional uint64 size = 3;
inline bool xclCopyBO_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclCopyBO_call::has_size() const {
  return _internal_has_size();
}
inline void xclCopyBO_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclCopyBO_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclCopyBO_call::size() const {
  // @@protoc_insertion_point(field_get:xclCopyBO_call.size)
  return _internal_size();
}
inline void xclCopyBO_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclCopyBO_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclCopyBO_call.size)
}

// optional uint64 src_offset = 4;
inline bool xclCopyBO_call::_internal_has_src_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclCopyBO_call::has_src_offset() const {
  return _internal_has_src_offset();
}
inline void xclCopyBO_call::clear_src_offset() {
  _impl_.src_offset_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclCopyBO_call::_internal_src_offset() const {
  return _impl_.src_offset_;
}
inline uint64_t xclCopyBO_call::src_offset() const {
  // @@protoc_insertion_point(field_get:xclCopyBO_call.src_offset)
  return _internal_src_offset();
}
inline void xclCopyBO_call::_internal_set_src_offset(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.src_offset_ = value;
}
inline void xclCopyBO_call::set_src_offset(uint64_t value) {
  _internal_set_src_offset(value);
  // @@protoc_insertion_point(field_set:xclCopyBO_call.src_offset)
}

// optional uint64 dst_offset = 5;
inline bool xclCopyBO_call::_internal_has_dst_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclCopyBO_call::has_dst_offset() const {
  return _internal_has_dst_offset();
}
inline void xclCopyBO_call::clear_dst_offset() {
  _impl_.dst_offset_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclCopyBO_call::_internal_dst_offset() const {
  return _impl_.dst_offset_;
}
inline uint64_t xclCopyBO_call::dst_offset() const {
  // @@protoc_insertion_point(field_get:xclCopyBO_call.dst_offset)
  return _internal_dst_offset();
}
inline void xclCopyBO_call::_internal_set_dst_offset(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dst_offset_ = value;
}
inline void xclCopyBO_call::set_dst_offset(uint64_t value) {
  _internal_set_dst_offset(value);
  // @@protoc_insertion_point(field_set:xclCopyBO_call.dst_offset)
}

// -------------------------------------------------------------------

// xclCopyBO_response

// optional bool ack = 1;
inline bool xclCopyBO_response::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCopyBO_response::has_ack() const {
  return _internal_has_ack();
}
inline void xclCopyBO_response::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclCopyBO_response::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclCopyBO_response::ack() const {
  // @@protoc_insertion_point(field_get:xclCopyBO_response.ack)
  return _internal_ack();
}
inline void xclCopyBO_response::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}
inline void xclCopyBO_response::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclCopyBO_response.ack)
}

// -------------------------------------------------------------------

// xclCreateQueue_call

// optional bool write = 1;
inline bool xclCreateQueue_call::_internal_has_write() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_write() const {
  return _internal_has_write();
}
inline void xclCreateQueue_call::clear_write() {
  _impl_.write_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclCreateQueue_call::_internal_write() const {
  return _impl_.write_;
}
inline bool xclCreateQueue_call::write() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.write)
  return _internal_write();
}
inline void xclCreateQueue_call::_internal_set_write(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.write_ = value;
}
inline void xclCreateQueue_call::set_write(bool value) {
  _internal_set_write(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.write)
}

// optional uint32 type = 2;
inline bool xclCreateQueue_call::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_type() const {
  return _internal_has_type();
}
inline void xclCreateQueue_call::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t xclCreateQueue_call::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t xclCreateQueue_call::type() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.type)
  return _internal_type();
}
inline void xclCreateQueue_call::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void xclCreateQueue_call::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.type)
}

// optional uint32 state = 3;
inline bool xclCreateQueue_call::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_state() const {
  return _internal_has_state();
}
inline void xclCreateQueue_call::clear_state() {
  _impl_.state_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclCreateQueue_call::_internal_state() const {
  return _impl_.state_;
}
inline uint32_t xclCreateQueue_call::state() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.state)
  return _internal_state();
}
inline void xclCreateQueue_call::_internal_set_state(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.state_ = value;
}
inline void xclCreateQueue_call::set_state(uint32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.state)
}

// optional uint32 route = 4;
inline bool xclCreateQueue_call::_internal_has_route() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_route() const {
  return _internal_has_route();
}
inline void xclCreateQueue_call::clear_route() {
  _impl_.route_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t xclCreateQueue_call::_internal_route() const {
  return _impl_.route_;
}
inline uint32_t xclCreateQueue_call::route() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.route)
  return _internal_route();
}
inline void xclCreateQueue_call::_internal_set_route(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.route_ = value;
}
inline void xclCreateQueue_call::set_route(uint32_t value) {
  _internal_set_route(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.route)
}

// optional uint64 flow = 5;
inline bool xclCreateQueue_call::_internal_has_flow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_flow() const {
  return _internal_has_flow();
}
inline void xclCreateQueue_call::clear_flow() {
  _impl_.flow_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclCreateQueue_call::_internal_flow() const {
  return _impl_.flow_;
}
inline uint64_t xclCreateQueue_call::flow() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.flow)
  return _internal_flow();
}
inline void xclCreateQueue_call::_internal_set_flow(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.flow_ = value;
}
inline void xclCreateQueue_call::set_flow(uint64_t value) {
  _internal_set_flow(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.flow)
}

// optional uint32 qsize = 6;
inline bool xclCreateQueue_call::_internal_has_qsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_qsize() const {
  return _internal_has_qsize();
}
inline void xclCreateQueue_call::clear_qsize() {
  _impl_.qsize_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t xclCreateQueue_call::_internal_qsize() const {
  return _impl_.qsize_;
}
inline uint32_t xclCreateQueue_call::qsize() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.qsize)
  return _internal_qsize();
}
inline void xclCreateQueue_call::_internal_set_qsize(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.qsize_ = value;
}
inline void xclCreateQueue_call::set_qsize(uint32_t value) {
  _internal_set_qsize(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.qsize)
}

// optional uint32 desc_size = 7;
inline bool xclCreateQueue_call::_internal_has_desc_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_desc_size() const {
  return _internal_has_desc_size();
}
inline void xclCreateQueue_call::clear_desc_size() {
  _impl_.desc_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t xclCreateQueue_call::_internal_desc_size() const {
  return _impl_.desc_size_;
}
inline uint32_t xclCreateQueue_call::desc_size() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.desc_size)
  return _internal_desc_size();
}
inline void xclCreateQueue_call::_internal_set_desc_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.desc_size_ = value;
}
inline void xclCreateQueue_call::set_desc_size(uint32_t value) {
  _internal_set_desc_size(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.desc_size)
}

// optional uint64 flags = 8;
inline bool xclCreateQueue_call::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool xclCreateQueue_call::has_flags() const {
  return _internal_has_flags();
}
inline void xclCreateQueue_call::clear_flags() {
  _impl_.flags_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t xclCreateQueue_call::_internal_flags() const {
  return _impl_.flags_;
}
inline uint64_t xclCreateQueue_call::flags() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_call.flags)
  return _internal_flags();
}
inline void xclCreateQueue_call::_internal_set_flags(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.flags_ = value;
}
inline void xclCreateQueue_call::set_flags(uint64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_call.flags)
}

// -------------------------------------------------------------------

// xclCreateQueue_response

// optional uint64 q_handle = 1;
inline bool xclCreateQueue_response::_internal_has_q_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclCreateQueue_response::has_q_handle() const {
  return _internal_has_q_handle();
}
inline void xclCreateQueue_response::clear_q_handle() {
  _impl_.q_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclCreateQueue_response::_internal_q_handle() const {
  return _impl_.q_handle_;
}
inline uint64_t xclCreateQueue_response::q_handle() const {
  // @@protoc_insertion_point(field_get:xclCreateQueue_response.q_handle)
  return _internal_q_handle();
}
inline void xclCreateQueue_response::_internal_set_q_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.q_handle_ = value;
}
inline void xclCreateQueue_response::set_q_handle(uint64_t value) {
  _internal_set_q_handle(value);
  // @@protoc_insertion_point(field_set:xclCreateQueue_response.q_handle)
}

// -------------------------------------------------------------------

// xclWriteQueue_call

// optional uint64 q_handle = 1;
inline bool xclWriteQueue_call::_internal_has_q_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclWriteQueue_call::has_q_handle() const {
  return _internal_has_q_handle();
}
inline void xclWriteQueue_call::clear_q_handle() {
  _impl_.q_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclWriteQueue_call::_internal_q_handle() const {
  return _impl_.q_handle_;
}
inline uint64_t xclWriteQueue_call::q_handle() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_call.q_handle)
  return _internal_q_handle();
}
inline void xclWriteQueue_call::_internal_set_q_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.q_handle_ = value;
}
inline void xclWriteQueue_call::set_q_handle(uint64_t value) {
  _internal_set_q_handle(value);
  // @@protoc_insertion_point(field_set:xclWriteQueue_call.q_handle)
}

// optional bytes src = 2;
inline bool xclWriteQueue_call::_internal_has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteQueue_call::has_src() const {
  return _internal_has_src();
}
inline void xclWriteQueue_call::clear_src() {
  _impl_.src_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclWriteQueue_call::src() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_call.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclWriteQueue_call::set_src(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.src_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclWriteQueue_call.src)
}
inline std::string* xclWriteQueue_call::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:xclWriteQueue_call.src)
  return _s;
}
inline const std::string& xclWriteQueue_call::_internal_src() const {
  return _impl_.src_.Get();
}
inline void xclWriteQueue_call::_internal_set_src(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* xclWriteQueue_call::_internal_mutable_src() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* xclWriteQueue_call::release_src() {
  // @@protoc_insertion_point(field_release:xclWriteQueue_call.src)
  if (!_internal_has_src()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.src_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclWriteQueue_call::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclWriteQueue_call.src)
}

// optional uint64 size = 3;
inline bool xclWriteQueue_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclWriteQueue_call::has_size() const {
  return _internal_has_size();
}
inline void xclWriteQueue_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclWriteQueue_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclWriteQueue_call::size() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_call.size)
  return _internal_size();
}
inline void xclWriteQueue_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclWriteQueue_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclWriteQueue_call.size)
}

// optional uint64 req = 4;
inline bool xclWriteQueue_call::_internal_has_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclWriteQueue_call::has_req() const {
  return _internal_has_req();
}
inline void xclWriteQueue_call::clear_req() {
  _impl_.req_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclWriteQueue_call::_internal_req() const {
  return _impl_.req_;
}
inline uint64_t xclWriteQueue_call::req() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_call.req)
  return _internal_req();
}
inline void xclWriteQueue_call::_internal_set_req(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.req_ = value;
}
inline void xclWriteQueue_call::set_req(uint64_t value) {
  _internal_set_req(value);
  // @@protoc_insertion_point(field_set:xclWriteQueue_call.req)
}

// optional bool nonblocking = 5;
inline bool xclWriteQueue_call::_internal_has_nonblocking() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclWriteQueue_call::has_nonblocking() const {
  return _internal_has_nonblocking();
}
inline void xclWriteQueue_call::clear_nonblocking() {
  _impl_.nonblocking_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool xclWriteQueue_call::_internal_nonblocking() const {
  return _impl_.nonblocking_;
}
inline bool xclWriteQueue_call::nonblocking() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_call.nonblocking)
  return _internal_nonblocking();
}
inline void xclWriteQueue_call::_internal_set_nonblocking(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nonblocking_ = value;
}
inline void xclWriteQueue_call::set_nonblocking(bool value) {
  _internal_set_nonblocking(value);
  // @@protoc_insertion_point(field_set:xclWriteQueue_call.nonblocking)
}

// optional bool eot = 6;
inline bool xclWriteQueue_call::_internal_has_eot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclWriteQueue_call::has_eot() const {
  return _internal_has_eot();
}
inline void xclWriteQueue_call::clear_eot() {
  _impl_.eot_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool xclWriteQueue_call::_internal_eot() const {
  return _impl_.eot_;
}
inline bool xclWriteQueue_call::eot() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_call.eot)
  return _internal_eot();
}
inline void xclWriteQueue_call::_internal_set_eot(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.eot_ = value;
}
inline void xclWriteQueue_call::set_eot(bool value) {
  _internal_set_eot(value);
  // @@protoc_insertion_point(field_set:xclWriteQueue_call.eot)
}

// -------------------------------------------------------------------

// xclWriteQueue_response

// optional uint64 written_size = 1;
inline bool xclWriteQueue_response::_internal_has_written_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclWriteQueue_response::has_written_size() const {
  return _internal_has_written_size();
}
inline void xclWriteQueue_response::clear_written_size() {
  _impl_.written_size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclWriteQueue_response::_internal_written_size() const {
  return _impl_.written_size_;
}
inline uint64_t xclWriteQueue_response::written_size() const {
  // @@protoc_insertion_point(field_get:xclWriteQueue_response.written_size)
  return _internal_written_size();
}
inline void xclWriteQueue_response::_internal_set_written_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.written_size_ = value;
}
inline void xclWriteQueue_response::set_written_size(uint64_t value) {
  _internal_set_written_size(value);
  // @@protoc_insertion_point(field_set:xclWriteQueue_response.written_size)
}

// -------------------------------------------------------------------

// xclReadQueue_call

// optional uint64 q_handle = 1;
inline bool xclReadQueue_call::_internal_has_q_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadQueue_call::has_q_handle() const {
  return _internal_has_q_handle();
}
inline void xclReadQueue_call::clear_q_handle() {
  _impl_.q_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclReadQueue_call::_internal_q_handle() const {
  return _impl_.q_handle_;
}
inline uint64_t xclReadQueue_call::q_handle() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_call.q_handle)
  return _internal_q_handle();
}
inline void xclReadQueue_call::_internal_set_q_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.q_handle_ = value;
}
inline void xclReadQueue_call::set_q_handle(uint64_t value) {
  _internal_set_q_handle(value);
  // @@protoc_insertion_point(field_set:xclReadQueue_call.q_handle)
}

// optional bytes dest = 2;
inline bool xclReadQueue_call::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadQueue_call::has_dest() const {
  return _internal_has_dest();
}
inline void xclReadQueue_call::clear_dest() {
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclReadQueue_call::dest() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_call.dest)
  return _internal_dest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclReadQueue_call::set_dest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclReadQueue_call.dest)
}
inline std::string* xclReadQueue_call::mutable_dest() {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:xclReadQueue_call.dest)
  return _s;
}
inline const std::string& xclReadQueue_call::_internal_dest() const {
  return _impl_.dest_.Get();
}
inline void xclReadQueue_call::_internal_set_dest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dest_.Set(value, GetArenaForAllocation());
}
inline std::string* xclReadQueue_call::_internal_mutable_dest() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dest_.Mutable(GetArenaForAllocation());
}
inline std::string* xclReadQueue_call::release_dest() {
  // @@protoc_insertion_point(field_release:xclReadQueue_call.dest)
  if (!_internal_has_dest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclReadQueue_call::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dest_.SetAllocated(dest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclReadQueue_call.dest)
}

// optional uint64 size = 3;
inline bool xclReadQueue_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclReadQueue_call::has_size() const {
  return _internal_has_size();
}
inline void xclReadQueue_call::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclReadQueue_call::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclReadQueue_call::size() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_call.size)
  return _internal_size();
}
inline void xclReadQueue_call::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclReadQueue_call::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclReadQueue_call.size)
}

// optional uint64 req = 4;
inline bool xclReadQueue_call::_internal_has_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclReadQueue_call::has_req() const {
  return _internal_has_req();
}
inline void xclReadQueue_call::clear_req() {
  _impl_.req_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclReadQueue_call::_internal_req() const {
  return _impl_.req_;
}
inline uint64_t xclReadQueue_call::req() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_call.req)
  return _internal_req();
}
inline void xclReadQueue_call::_internal_set_req(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.req_ = value;
}
inline void xclReadQueue_call::set_req(uint64_t value) {
  _internal_set_req(value);
  // @@protoc_insertion_point(field_set:xclReadQueue_call.req)
}

// optional bool nonblocking = 5;
inline bool xclReadQueue_call::_internal_has_nonblocking() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclReadQueue_call::has_nonblocking() const {
  return _internal_has_nonblocking();
}
inline void xclReadQueue_call::clear_nonblocking() {
  _impl_.nonblocking_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool xclReadQueue_call::_internal_nonblocking() const {
  return _impl_.nonblocking_;
}
inline bool xclReadQueue_call::nonblocking() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_call.nonblocking)
  return _internal_nonblocking();
}
inline void xclReadQueue_call::_internal_set_nonblocking(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nonblocking_ = value;
}
inline void xclReadQueue_call::set_nonblocking(bool value) {
  _internal_set_nonblocking(value);
  // @@protoc_insertion_point(field_set:xclReadQueue_call.nonblocking)
}

// optional bool eot = 6;
inline bool xclReadQueue_call::_internal_has_eot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool xclReadQueue_call::has_eot() const {
  return _internal_has_eot();
}
inline void xclReadQueue_call::clear_eot() {
  _impl_.eot_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool xclReadQueue_call::_internal_eot() const {
  return _impl_.eot_;
}
inline bool xclReadQueue_call::eot() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_call.eot)
  return _internal_eot();
}
inline void xclReadQueue_call::_internal_set_eot(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.eot_ = value;
}
inline void xclReadQueue_call::set_eot(bool value) {
  _internal_set_eot(value);
  // @@protoc_insertion_point(field_set:xclReadQueue_call.eot)
}

// -------------------------------------------------------------------

// xclReadQueue_response

// optional bytes dest = 1;
inline bool xclReadQueue_response::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclReadQueue_response::has_dest() const {
  return _internal_has_dest();
}
inline void xclReadQueue_response::clear_dest() {
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclReadQueue_response::dest() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_response.dest)
  return _internal_dest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclReadQueue_response::set_dest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclReadQueue_response.dest)
}
inline std::string* xclReadQueue_response::mutable_dest() {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:xclReadQueue_response.dest)
  return _s;
}
inline const std::string& xclReadQueue_response::_internal_dest() const {
  return _impl_.dest_.Get();
}
inline void xclReadQueue_response::_internal_set_dest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dest_.Set(value, GetArenaForAllocation());
}
inline std::string* xclReadQueue_response::_internal_mutable_dest() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dest_.Mutable(GetArenaForAllocation());
}
inline std::string* xclReadQueue_response::release_dest() {
  // @@protoc_insertion_point(field_release:xclReadQueue_response.dest)
  if (!_internal_has_dest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclReadQueue_response::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dest_.SetAllocated(dest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclReadQueue_response.dest)
}

// optional uint64 size = 2;
inline bool xclReadQueue_response::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclReadQueue_response::has_size() const {
  return _internal_has_size();
}
inline void xclReadQueue_response::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclReadQueue_response::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclReadQueue_response::size() const {
  // @@protoc_insertion_point(field_get:xclReadQueue_response.size)
  return _internal_size();
}
inline void xclReadQueue_response::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void xclReadQueue_response::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclReadQueue_response.size)
}

// -------------------------------------------------------------------

// xclPollCompletion_call

// optional uint64 req = 1;
inline bool xclPollCompletion_call::_internal_has_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPollCompletion_call::has_req() const {
  return _internal_has_req();
}
inline void xclPollCompletion_call::clear_req() {
  _impl_.req_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclPollCompletion_call::_internal_req() const {
  return _impl_.req_;
}
inline uint64_t xclPollCompletion_call::req() const {
  // @@protoc_insertion_point(field_get:xclPollCompletion_call.req)
  return _internal_req();
}
inline void xclPollCompletion_call::_internal_set_req(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.req_ = value;
}
inline void xclPollCompletion_call::set_req(uint64_t value) {
  _internal_set_req(value);
  // @@protoc_insertion_point(field_set:xclPollCompletion_call.req)
}

// -------------------------------------------------------------------

// xclPollCompletion_response_request

// optional bytes dest = 1;
inline bool xclPollCompletion_response_request::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPollCompletion_response_request::has_dest() const {
  return _internal_has_dest();
}
inline void xclPollCompletion_response_request::clear_dest() {
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclPollCompletion_response_request::dest() const {
  // @@protoc_insertion_point(field_get:xclPollCompletion_response.request.dest)
  return _internal_dest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclPollCompletion_response_request::set_dest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclPollCompletion_response.request.dest)
}
inline std::string* xclPollCompletion_response_request::mutable_dest() {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:xclPollCompletion_response.request.dest)
  return _s;
}
inline const std::string& xclPollCompletion_response_request::_internal_dest() const {
  return _impl_.dest_.Get();
}
inline void xclPollCompletion_response_request::_internal_set_dest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dest_.Set(value, GetArenaForAllocation());
}
inline std::string* xclPollCompletion_response_request::_internal_mutable_dest() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dest_.Mutable(GetArenaForAllocation());
}
inline std::string* xclPollCompletion_response_request::release_dest() {
  // @@protoc_insertion_point(field_release:xclPollCompletion_response.request.dest)
  if (!_internal_has_dest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclPollCompletion_response_request::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dest_.SetAllocated(dest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclPollCompletion_response.request.dest)
}

// optional uint64 size = 2;
inline bool xclPollCompletion_response_request::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPollCompletion_response_request::has_size() const {
  return _internal_has_size();
}
inline void xclPollCompletion_response_request::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclPollCompletion_response_request::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclPollCompletion_response_request::size() const {
  // @@protoc_insertion_point(field_get:xclPollCompletion_response.request.size)
  return _internal_size();
}
inline void xclPollCompletion_response_request::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void xclPollCompletion_response_request::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclPollCompletion_response.request.size)
}

// -------------------------------------------------------------------

// xclPollCompletion_response

// repeated .xclPollCompletion_response.request fullrequest = 3;
inline int xclPollCompletion_response::_internal_fullrequest_size() const {
  return _impl_.fullrequest_.size();
}
inline int xclPollCompletion_response::fullrequest_size() const {
  return _internal_fullrequest_size();
}
inline void xclPollCompletion_response::clear_fullrequest() {
  _impl_.fullrequest_.Clear();
}
inline ::xclPollCompletion_response_request* xclPollCompletion_response::mutable_fullrequest(int index) {
  // @@protoc_insertion_point(field_mutable:xclPollCompletion_response.fullrequest)
  return _impl_.fullrequest_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPollCompletion_response_request >*
xclPollCompletion_response::mutable_fullrequest() {
  // @@protoc_insertion_point(field_mutable_list:xclPollCompletion_response.fullrequest)
  return &_impl_.fullrequest_;
}
inline const ::xclPollCompletion_response_request& xclPollCompletion_response::_internal_fullrequest(int index) const {
  return _impl_.fullrequest_.Get(index);
}
inline const ::xclPollCompletion_response_request& xclPollCompletion_response::fullrequest(int index) const {
  // @@protoc_insertion_point(field_get:xclPollCompletion_response.fullrequest)
  return _internal_fullrequest(index);
}
inline ::xclPollCompletion_response_request* xclPollCompletion_response::_internal_add_fullrequest() {
  return _impl_.fullrequest_.Add();
}
inline ::xclPollCompletion_response_request* xclPollCompletion_response::add_fullrequest() {
  ::xclPollCompletion_response_request* _add = _internal_add_fullrequest();
  // @@protoc_insertion_point(field_add:xclPollCompletion_response.fullrequest)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPollCompletion_response_request >&
xclPollCompletion_response::fullrequest() const {
  // @@protoc_insertion_point(field_list:xclPollCompletion_response.fullrequest)
  return _impl_.fullrequest_;
}

// -------------------------------------------------------------------

// xclDestroyQueue_call

// optional uint64 q_handle = 1;
inline bool xclDestroyQueue_call::_internal_has_q_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclDestroyQueue_call::has_q_handle() const {
  return _internal_has_q_handle();
}
inline void xclDestroyQueue_call::clear_q_handle() {
  _impl_.q_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclDestroyQueue_call::_internal_q_handle() const {
  return _impl_.q_handle_;
}
inline uint64_t xclDestroyQueue_call::q_handle() const {
  // @@protoc_insertion_point(field_get:xclDestroyQueue_call.q_handle)
  return _internal_q_handle();
}
inline void xclDestroyQueue_call::_internal_set_q_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.q_handle_ = value;
}
inline void xclDestroyQueue_call::set_q_handle(uint64_t value) {
  _internal_set_q_handle(value);
  // @@protoc_insertion_point(field_set:xclDestroyQueue_call.q_handle)
}

// -------------------------------------------------------------------

// xclDestroyQueue_response

// optional bool success = 1;
inline bool xclDestroyQueue_response::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclDestroyQueue_response::has_success() const {
  return _internal_has_success();
}
inline void xclDestroyQueue_response::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclDestroyQueue_response::_internal_success() const {
  return _impl_.success_;
}
inline bool xclDestroyQueue_response::success() const {
  // @@protoc_insertion_point(field_get:xclDestroyQueue_response.success)
  return _internal_success();
}
inline void xclDestroyQueue_response::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void xclDestroyQueue_response::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:xclDestroyQueue_response.success)
}

// -------------------------------------------------------------------

// xclSetupInstance_call_argflowpair

// optional uint64 arg = 2;
inline bool xclSetupInstance_call_argflowpair::_internal_has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclSetupInstance_call_argflowpair::has_arg() const {
  return _internal_has_arg();
}
inline void xclSetupInstance_call_argflowpair::clear_arg() {
  _impl_.arg_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclSetupInstance_call_argflowpair::_internal_arg() const {
  return _impl_.arg_;
}
inline uint64_t xclSetupInstance_call_argflowpair::arg() const {
  // @@protoc_insertion_point(field_get:xclSetupInstance_call.argflowpair.arg)
  return _internal_arg();
}
inline void xclSetupInstance_call_argflowpair::_internal_set_arg(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.arg_ = value;
}
inline void xclSetupInstance_call_argflowpair::set_arg(uint64_t value) {
  _internal_set_arg(value);
  // @@protoc_insertion_point(field_set:xclSetupInstance_call.argflowpair.arg)
}

// optional uint64 flow = 3;
inline bool xclSetupInstance_call_argflowpair::_internal_has_flow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclSetupInstance_call_argflowpair::has_flow() const {
  return _internal_has_flow();
}
inline void xclSetupInstance_call_argflowpair::clear_flow() {
  _impl_.flow_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclSetupInstance_call_argflowpair::_internal_flow() const {
  return _impl_.flow_;
}
inline uint64_t xclSetupInstance_call_argflowpair::flow() const {
  // @@protoc_insertion_point(field_get:xclSetupInstance_call.argflowpair.flow)
  return _internal_flow();
}
inline void xclSetupInstance_call_argflowpair::_internal_set_flow(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flow_ = value;
}
inline void xclSetupInstance_call_argflowpair::set_flow(uint64_t value) {
  _internal_set_flow(value);
  // @@protoc_insertion_point(field_set:xclSetupInstance_call.argflowpair.flow)
}

// optional string tag = 4;
inline bool xclSetupInstance_call_argflowpair::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSetupInstance_call_argflowpair::has_tag() const {
  return _internal_has_tag();
}
inline void xclSetupInstance_call_argflowpair::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclSetupInstance_call_argflowpair::tag() const {
  // @@protoc_insertion_point(field_get:xclSetupInstance_call.argflowpair.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclSetupInstance_call_argflowpair::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclSetupInstance_call.argflowpair.tag)
}
inline std::string* xclSetupInstance_call_argflowpair::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:xclSetupInstance_call.argflowpair.tag)
  return _s;
}
inline const std::string& xclSetupInstance_call_argflowpair::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void xclSetupInstance_call_argflowpair::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* xclSetupInstance_call_argflowpair::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* xclSetupInstance_call_argflowpair::release_tag() {
  // @@protoc_insertion_point(field_release:xclSetupInstance_call.argflowpair.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclSetupInstance_call_argflowpair::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclSetupInstance_call.argflowpair.tag)
}

// -------------------------------------------------------------------

// xclSetupInstance_call

// optional uint64 route = 1;
inline bool xclSetupInstance_call::_internal_has_route() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSetupInstance_call::has_route() const {
  return _internal_has_route();
}
inline void xclSetupInstance_call::clear_route() {
  _impl_.route_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclSetupInstance_call::_internal_route() const {
  return _impl_.route_;
}
inline uint64_t xclSetupInstance_call::route() const {
  // @@protoc_insertion_point(field_get:xclSetupInstance_call.route)
  return _internal_route();
}
inline void xclSetupInstance_call::_internal_set_route(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.route_ = value;
}
inline void xclSetupInstance_call::set_route(uint64_t value) {
  _internal_set_route(value);
  // @@protoc_insertion_point(field_set:xclSetupInstance_call.route)
}

// repeated .xclSetupInstance_call.argflowpair setup = 5;
inline int xclSetupInstance_call::_internal_setup_size() const {
  return _impl_.setup_.size();
}
inline int xclSetupInstance_call::setup_size() const {
  return _internal_setup_size();
}
inline void xclSetupInstance_call::clear_setup() {
  _impl_.setup_.Clear();
}
inline ::xclSetupInstance_call_argflowpair* xclSetupInstance_call::mutable_setup(int index) {
  // @@protoc_insertion_point(field_mutable:xclSetupInstance_call.setup)
  return _impl_.setup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetupInstance_call_argflowpair >*
xclSetupInstance_call::mutable_setup() {
  // @@protoc_insertion_point(field_mutable_list:xclSetupInstance_call.setup)
  return &_impl_.setup_;
}
inline const ::xclSetupInstance_call_argflowpair& xclSetupInstance_call::_internal_setup(int index) const {
  return _impl_.setup_.Get(index);
}
inline const ::xclSetupInstance_call_argflowpair& xclSetupInstance_call::setup(int index) const {
  // @@protoc_insertion_point(field_get:xclSetupInstance_call.setup)
  return _internal_setup(index);
}
inline ::xclSetupInstance_call_argflowpair* xclSetupInstance_call::_internal_add_setup() {
  return _impl_.setup_.Add();
}
inline ::xclSetupInstance_call_argflowpair* xclSetupInstance_call::add_setup() {
  ::xclSetupInstance_call_argflowpair* _add = _internal_add_setup();
  // @@protoc_insertion_point(field_add:xclSetupInstance_call.setup)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclSetupInstance_call_argflowpair >&
xclSetupInstance_call::setup() const {
  // @@protoc_insertion_point(field_list:xclSetupInstance_call.setup)
  return _impl_.setup_;
}

// -------------------------------------------------------------------

// xclSetupInstance_response

// optional bool success = 1;
inline bool xclSetupInstance_response::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSetupInstance_response::has_success() const {
  return _internal_has_success();
}
inline void xclSetupInstance_response::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclSetupInstance_response::_internal_success() const {
  return _impl_.success_;
}
inline bool xclSetupInstance_response::success() const {
  // @@protoc_insertion_point(field_get:xclSetupInstance_response.success)
  return _internal_success();
}
inline void xclSetupInstance_response::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void xclSetupInstance_response::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:xclSetupInstance_response.success)
}

// -------------------------------------------------------------------

// xclPerfMonReadCounters_Streaming_call

// required string slotname = 1;
inline bool xclPerfMonReadCounters_Streaming_call::_internal_has_slotname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_Streaming_call::has_slotname() const {
  return _internal_has_slotname();
}
inline void xclPerfMonReadCounters_Streaming_call::clear_slotname() {
  _impl_.slotname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclPerfMonReadCounters_Streaming_call::slotname() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_Streaming_call.slotname)
  return _internal_slotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclPerfMonReadCounters_Streaming_call::set_slotname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.slotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_Streaming_call.slotname)
}
inline std::string* xclPerfMonReadCounters_Streaming_call::mutable_slotname() {
  std::string* _s = _internal_mutable_slotname();
  // @@protoc_insertion_point(field_mutable:xclPerfMonReadCounters_Streaming_call.slotname)
  return _s;
}
inline const std::string& xclPerfMonReadCounters_Streaming_call::_internal_slotname() const {
  return _impl_.slotname_.Get();
}
inline void xclPerfMonReadCounters_Streaming_call::_internal_set_slotname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slotname_.Set(value, GetArenaForAllocation());
}
inline std::string* xclPerfMonReadCounters_Streaming_call::_internal_mutable_slotname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.slotname_.Mutable(GetArenaForAllocation());
}
inline std::string* xclPerfMonReadCounters_Streaming_call::release_slotname() {
  // @@protoc_insertion_point(field_release:xclPerfMonReadCounters_Streaming_call.slotname)
  if (!_internal_has_slotname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.slotname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclPerfMonReadCounters_Streaming_call::set_allocated_slotname(std::string* slotname) {
  if (slotname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.slotname_.SetAllocated(slotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclPerfMonReadCounters_Streaming_call.slotname)
}

// -------------------------------------------------------------------

// xclPerfMonReadCounters_Streaming_response

// optional uint64 str_num_tranx = 7;
inline bool xclPerfMonReadCounters_Streaming_response::_internal_has_str_num_tranx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_Streaming_response::has_str_num_tranx() const {
  return _internal_has_str_num_tranx();
}
inline void xclPerfMonReadCounters_Streaming_response::clear_str_num_tranx() {
  _impl_.str_num_tranx_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::_internal_str_num_tranx() const {
  return _impl_.str_num_tranx_;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::str_num_tranx() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_Streaming_response.str_num_tranx)
  return _internal_str_num_tranx();
}
inline void xclPerfMonReadCounters_Streaming_response::_internal_set_str_num_tranx(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.str_num_tranx_ = value;
}
inline void xclPerfMonReadCounters_Streaming_response::set_str_num_tranx(uint64_t value) {
  _internal_set_str_num_tranx(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_Streaming_response.str_num_tranx)
}

// optional uint64 str_data_bytes = 8;
inline bool xclPerfMonReadCounters_Streaming_response::_internal_has_str_data_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_Streaming_response::has_str_data_bytes() const {
  return _internal_has_str_data_bytes();
}
inline void xclPerfMonReadCounters_Streaming_response::clear_str_data_bytes() {
  _impl_.str_data_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::_internal_str_data_bytes() const {
  return _impl_.str_data_bytes_;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::str_data_bytes() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_Streaming_response.str_data_bytes)
  return _internal_str_data_bytes();
}
inline void xclPerfMonReadCounters_Streaming_response::_internal_set_str_data_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.str_data_bytes_ = value;
}
inline void xclPerfMonReadCounters_Streaming_response::set_str_data_bytes(uint64_t value) {
  _internal_set_str_data_bytes(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_Streaming_response.str_data_bytes)
}

// optional uint64 str_busy_cycles = 9;
inline bool xclPerfMonReadCounters_Streaming_response::_internal_has_str_busy_cycles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_Streaming_response::has_str_busy_cycles() const {
  return _internal_has_str_busy_cycles();
}
inline void xclPerfMonReadCounters_Streaming_response::clear_str_busy_cycles() {
  _impl_.str_busy_cycles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::_internal_str_busy_cycles() const {
  return _impl_.str_busy_cycles_;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::str_busy_cycles() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_Streaming_response.str_busy_cycles)
  return _internal_str_busy_cycles();
}
inline void xclPerfMonReadCounters_Streaming_response::_internal_set_str_busy_cycles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.str_busy_cycles_ = value;
}
inline void xclPerfMonReadCounters_Streaming_response::set_str_busy_cycles(uint64_t value) {
  _internal_set_str_busy_cycles(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_Streaming_response.str_busy_cycles)
}

// optional uint64 str_stall_cycles = 10;
inline bool xclPerfMonReadCounters_Streaming_response::_internal_has_str_stall_cycles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_Streaming_response::has_str_stall_cycles() const {
  return _internal_has_str_stall_cycles();
}
inline void xclPerfMonReadCounters_Streaming_response::clear_str_stall_cycles() {
  _impl_.str_stall_cycles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::_internal_str_stall_cycles() const {
  return _impl_.str_stall_cycles_;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::str_stall_cycles() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_Streaming_response.str_stall_cycles)
  return _internal_str_stall_cycles();
}
inline void xclPerfMonReadCounters_Streaming_response::_internal_set_str_stall_cycles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.str_stall_cycles_ = value;
}
inline void xclPerfMonReadCounters_Streaming_response::set_str_stall_cycles(uint64_t value) {
  _internal_set_str_stall_cycles(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_Streaming_response.str_stall_cycles)
}

// optional uint64 str_starve_cycles = 11;
inline bool xclPerfMonReadCounters_Streaming_response::_internal_has_str_starve_cycles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool xclPerfMonReadCounters_Streaming_response::has_str_starve_cycles() const {
  return _internal_has_str_starve_cycles();
}
inline void xclPerfMonReadCounters_Streaming_response::clear_str_starve_cycles() {
  _impl_.str_starve_cycles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::_internal_str_starve_cycles() const {
  return _impl_.str_starve_cycles_;
}
inline uint64_t xclPerfMonReadCounters_Streaming_response::str_starve_cycles() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadCounters_Streaming_response.str_starve_cycles)
  return _internal_str_starve_cycles();
}
inline void xclPerfMonReadCounters_Streaming_response::_internal_set_str_starve_cycles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.str_starve_cycles_ = value;
}
inline void xclPerfMonReadCounters_Streaming_response::set_str_starve_cycles(uint64_t value) {
  _internal_set_str_starve_cycles(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadCounters_Streaming_response.str_starve_cycles)
}

// -------------------------------------------------------------------

// xclPerfMonReadTrace_Streaming_call

// optional bool ack = 1;
inline bool xclPerfMonReadTrace_Streaming_call::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_Streaming_call::has_ack() const {
  return _internal_has_ack();
}
inline void xclPerfMonReadTrace_Streaming_call::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclPerfMonReadTrace_Streaming_call::_internal_ack() const {
  return _impl_.ack_;
}
inline bool xclPerfMonReadTrace_Streaming_call::ack() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_Streaming_call.ack)
  return _internal_ack();
}
inline void xclPerfMonReadTrace_Streaming_call::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ack_ = value;
}
inline void xclPerfMonReadTrace_Streaming_call::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_Streaming_call.ack)
}

// optional string slotname = 2;
inline bool xclPerfMonReadTrace_Streaming_call::_internal_has_slotname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_Streaming_call::has_slotname() const {
  return _internal_has_slotname();
}
inline void xclPerfMonReadTrace_Streaming_call::clear_slotname() {
  _impl_.slotname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclPerfMonReadTrace_Streaming_call::slotname() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_Streaming_call.slotname)
  return _internal_slotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclPerfMonReadTrace_Streaming_call::set_slotname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.slotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_Streaming_call.slotname)
}
inline std::string* xclPerfMonReadTrace_Streaming_call::mutable_slotname() {
  std::string* _s = _internal_mutable_slotname();
  // @@protoc_insertion_point(field_mutable:xclPerfMonReadTrace_Streaming_call.slotname)
  return _s;
}
inline const std::string& xclPerfMonReadTrace_Streaming_call::_internal_slotname() const {
  return _impl_.slotname_.Get();
}
inline void xclPerfMonReadTrace_Streaming_call::_internal_set_slotname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.slotname_.Set(value, GetArenaForAllocation());
}
inline std::string* xclPerfMonReadTrace_Streaming_call::_internal_mutable_slotname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.slotname_.Mutable(GetArenaForAllocation());
}
inline std::string* xclPerfMonReadTrace_Streaming_call::release_slotname() {
  // @@protoc_insertion_point(field_release:xclPerfMonReadTrace_Streaming_call.slotname)
  if (!_internal_has_slotname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.slotname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclPerfMonReadTrace_Streaming_call::set_allocated_slotname(std::string* slotname) {
  if (slotname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.slotname_.SetAllocated(slotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.slotname_.IsDefault()) {
    _impl_.slotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclPerfMonReadTrace_Streaming_call.slotname)
}

// -------------------------------------------------------------------

// xclPerfMonReadTrace_Streaming_response_events

// optional uint32 eventflags = 3;
inline bool xclPerfMonReadTrace_Streaming_response_events::_internal_has_eventflags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_Streaming_response_events::has_eventflags() const {
  return _internal_has_eventflags();
}
inline void xclPerfMonReadTrace_Streaming_response_events::clear_eventflags() {
  _impl_.eventflags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t xclPerfMonReadTrace_Streaming_response_events::_internal_eventflags() const {
  return _impl_.eventflags_;
}
inline uint32_t xclPerfMonReadTrace_Streaming_response_events::eventflags() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_Streaming_response.events.eventflags)
  return _internal_eventflags();
}
inline void xclPerfMonReadTrace_Streaming_response_events::_internal_set_eventflags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.eventflags_ = value;
}
inline void xclPerfMonReadTrace_Streaming_response_events::set_eventflags(uint32_t value) {
  _internal_set_eventflags(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_Streaming_response.events.eventflags)
}

// optional uint32 timestamp = 4;
inline bool xclPerfMonReadTrace_Streaming_response_events::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_Streaming_response_events::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void xclPerfMonReadTrace_Streaming_response_events::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t xclPerfMonReadTrace_Streaming_response_events::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t xclPerfMonReadTrace_Streaming_response_events::timestamp() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_Streaming_response.events.timestamp)
  return _internal_timestamp();
}
inline void xclPerfMonReadTrace_Streaming_response_events::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void xclPerfMonReadTrace_Streaming_response_events::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_Streaming_response.events.timestamp)
}

// optional uint64 host_timestamp = 5;
inline bool xclPerfMonReadTrace_Streaming_response_events::_internal_has_host_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPerfMonReadTrace_Streaming_response_events::has_host_timestamp() const {
  return _internal_has_host_timestamp();
}
inline void xclPerfMonReadTrace_Streaming_response_events::clear_host_timestamp() {
  _impl_.host_timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclPerfMonReadTrace_Streaming_response_events::_internal_host_timestamp() const {
  return _impl_.host_timestamp_;
}
inline uint64_t xclPerfMonReadTrace_Streaming_response_events::host_timestamp() const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_Streaming_response.events.host_timestamp)
  return _internal_host_timestamp();
}
inline void xclPerfMonReadTrace_Streaming_response_events::_internal_set_host_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.host_timestamp_ = value;
}
inline void xclPerfMonReadTrace_Streaming_response_events::set_host_timestamp(uint64_t value) {
  _internal_set_host_timestamp(value);
  // @@protoc_insertion_point(field_set:xclPerfMonReadTrace_Streaming_response.events.host_timestamp)
}

// -------------------------------------------------------------------

// xclPerfMonReadTrace_Streaming_response

// repeated .xclPerfMonReadTrace_Streaming_response.events output_data = 8;
inline int xclPerfMonReadTrace_Streaming_response::_internal_output_data_size() const {
  return _impl_.output_data_.size();
}
inline int xclPerfMonReadTrace_Streaming_response::output_data_size() const {
  return _internal_output_data_size();
}
inline void xclPerfMonReadTrace_Streaming_response::clear_output_data() {
  _impl_.output_data_.Clear();
}
inline ::xclPerfMonReadTrace_Streaming_response_events* xclPerfMonReadTrace_Streaming_response::mutable_output_data(int index) {
  // @@protoc_insertion_point(field_mutable:xclPerfMonReadTrace_Streaming_response.output_data)
  return _impl_.output_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_Streaming_response_events >*
xclPerfMonReadTrace_Streaming_response::mutable_output_data() {
  // @@protoc_insertion_point(field_mutable_list:xclPerfMonReadTrace_Streaming_response.output_data)
  return &_impl_.output_data_;
}
inline const ::xclPerfMonReadTrace_Streaming_response_events& xclPerfMonReadTrace_Streaming_response::_internal_output_data(int index) const {
  return _impl_.output_data_.Get(index);
}
inline const ::xclPerfMonReadTrace_Streaming_response_events& xclPerfMonReadTrace_Streaming_response::output_data(int index) const {
  // @@protoc_insertion_point(field_get:xclPerfMonReadTrace_Streaming_response.output_data)
  return _internal_output_data(index);
}
inline ::xclPerfMonReadTrace_Streaming_response_events* xclPerfMonReadTrace_Streaming_response::_internal_add_output_data() {
  return _impl_.output_data_.Add();
}
inline ::xclPerfMonReadTrace_Streaming_response_events* xclPerfMonReadTrace_Streaming_response::add_output_data() {
  ::xclPerfMonReadTrace_Streaming_response_events* _add = _internal_add_output_data();
  // @@protoc_insertion_point(field_add:xclPerfMonReadTrace_Streaming_response.output_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPerfMonReadTrace_Streaming_response_events >&
xclPerfMonReadTrace_Streaming_response::output_data() const {
  // @@protoc_insertion_point(field_list:xclPerfMonReadTrace_Streaming_response.output_data)
  return _impl_.output_data_;
}

// -------------------------------------------------------------------

// xclSlaveReadReq_call

// required uint64 addr = 1;
inline bool xclSlaveReadReq_call::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSlaveReadReq_call::has_addr() const {
  return _internal_has_addr();
}
inline void xclSlaveReadReq_call::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclSlaveReadReq_call::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclSlaveReadReq_call::addr() const {
  // @@protoc_insertion_point(field_get:xclSlaveReadReq_call.addr)
  return _internal_addr();
}
inline void xclSlaveReadReq_call::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.addr_ = value;
}
inline void xclSlaveReadReq_call::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclSlaveReadReq_call.addr)
}

// required uint32 size = 2;
inline bool xclSlaveReadReq_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclSlaveReadReq_call::has_size() const {
  return _internal_has_size();
}
inline void xclSlaveReadReq_call::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t xclSlaveReadReq_call::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclSlaveReadReq_call::size() const {
  // @@protoc_insertion_point(field_get:xclSlaveReadReq_call.size)
  return _internal_size();
}
inline void xclSlaveReadReq_call::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void xclSlaveReadReq_call::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclSlaveReadReq_call.size)
}

// -------------------------------------------------------------------

// xclSlaveReadReq_response

// required bool valid = 1;
inline bool xclSlaveReadReq_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclSlaveReadReq_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclSlaveReadReq_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool xclSlaveReadReq_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclSlaveReadReq_response::valid() const {
  // @@protoc_insertion_point(field_get:xclSlaveReadReq_response.valid)
  return _internal_valid();
}
inline void xclSlaveReadReq_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.valid_ = value;
}
inline void xclSlaveReadReq_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclSlaveReadReq_response.valid)
}

// required bytes data = 2;
inline bool xclSlaveReadReq_response::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSlaveReadReq_response::has_data() const {
  return _internal_has_data();
}
inline void xclSlaveReadReq_response::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclSlaveReadReq_response::data() const {
  // @@protoc_insertion_point(field_get:xclSlaveReadReq_response.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclSlaveReadReq_response::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclSlaveReadReq_response.data)
}
inline std::string* xclSlaveReadReq_response::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclSlaveReadReq_response.data)
  return _s;
}
inline const std::string& xclSlaveReadReq_response::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclSlaveReadReq_response::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclSlaveReadReq_response::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclSlaveReadReq_response::release_data() {
  // @@protoc_insertion_point(field_release:xclSlaveReadReq_response.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclSlaveReadReq_response::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclSlaveReadReq_response.data)
}

// -------------------------------------------------------------------

// xclSlaveWriteReq_call

// required uint64 addr = 1;
inline bool xclSlaveWriteReq_call::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclSlaveWriteReq_call::has_addr() const {
  return _internal_has_addr();
}
inline void xclSlaveWriteReq_call::clear_addr() {
  _impl_.addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclSlaveWriteReq_call::_internal_addr() const {
  return _impl_.addr_;
}
inline uint64_t xclSlaveWriteReq_call::addr() const {
  // @@protoc_insertion_point(field_get:xclSlaveWriteReq_call.addr)
  return _internal_addr();
}
inline void xclSlaveWriteReq_call::_internal_set_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.addr_ = value;
}
inline void xclSlaveWriteReq_call::set_addr(uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:xclSlaveWriteReq_call.addr)
}

// required uint32 size = 2;
inline bool xclSlaveWriteReq_call::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclSlaveWriteReq_call::has_size() const {
  return _internal_has_size();
}
inline void xclSlaveWriteReq_call::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t xclSlaveWriteReq_call::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t xclSlaveWriteReq_call::size() const {
  // @@protoc_insertion_point(field_get:xclSlaveWriteReq_call.size)
  return _internal_size();
}
inline void xclSlaveWriteReq_call::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void xclSlaveWriteReq_call::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclSlaveWriteReq_call.size)
}

// required bytes data = 3;
inline bool xclSlaveWriteReq_call::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSlaveWriteReq_call::has_data() const {
  return _internal_has_data();
}
inline void xclSlaveWriteReq_call::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& xclSlaveWriteReq_call::data() const {
  // @@protoc_insertion_point(field_get:xclSlaveWriteReq_call.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void xclSlaveWriteReq_call::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:xclSlaveWriteReq_call.data)
}
inline std::string* xclSlaveWriteReq_call::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:xclSlaveWriteReq_call.data)
  return _s;
}
inline const std::string& xclSlaveWriteReq_call::_internal_data() const {
  return _impl_.data_.Get();
}
inline void xclSlaveWriteReq_call::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* xclSlaveWriteReq_call::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* xclSlaveWriteReq_call::release_data() {
  // @@protoc_insertion_point(field_release:xclSlaveWriteReq_call.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void xclSlaveWriteReq_call::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xclSlaveWriteReq_call.data)
}

// -------------------------------------------------------------------

// xclSlaveWriteReq_response

// required bool valid = 1;
inline bool xclSlaveWriteReq_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclSlaveWriteReq_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclSlaveWriteReq_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclSlaveWriteReq_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclSlaveWriteReq_response::valid() const {
  // @@protoc_insertion_point(field_get:xclSlaveWriteReq_response.valid)
  return _internal_valid();
}
inline void xclSlaveWriteReq_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valid_ = value;
}
inline void xclSlaveWriteReq_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclSlaveWriteReq_response.valid)
}

// -------------------------------------------------------------------

// xclInterruptOccured_call

// required uint32 interrupt_line = 1;
inline bool xclInterruptOccured_call::_internal_has_interrupt_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclInterruptOccured_call::has_interrupt_line() const {
  return _internal_has_interrupt_line();
}
inline void xclInterruptOccured_call::clear_interrupt_line() {
  _impl_.interrupt_line_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t xclInterruptOccured_call::_internal_interrupt_line() const {
  return _impl_.interrupt_line_;
}
inline uint32_t xclInterruptOccured_call::interrupt_line() const {
  // @@protoc_insertion_point(field_get:xclInterruptOccured_call.interrupt_line)
  return _internal_interrupt_line();
}
inline void xclInterruptOccured_call::_internal_set_interrupt_line(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interrupt_line_ = value;
}
inline void xclInterruptOccured_call::set_interrupt_line(uint32_t value) {
  _internal_set_interrupt_line(value);
  // @@protoc_insertion_point(field_set:xclInterruptOccured_call.interrupt_line)
}

// -------------------------------------------------------------------

// xclInterruptOccured_response

// required bool valid = 1;
inline bool xclInterruptOccured_response::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclInterruptOccured_response::has_valid() const {
  return _internal_has_valid();
}
inline void xclInterruptOccured_response::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclInterruptOccured_response::_internal_valid() const {
  return _impl_.valid_;
}
inline bool xclInterruptOccured_response::valid() const {
  // @@protoc_insertion_point(field_get:xclInterruptOccured_response.valid)
  return _internal_valid();
}
inline void xclInterruptOccured_response::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valid_ = value;
}
inline void xclInterruptOccured_response::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:xclInterruptOccured_response.valid)
}

// -------------------------------------------------------------------

// xclPfBarAddrmap_call

// optional bool req = 1;
inline bool xclPfBarAddrmap_call::_internal_has_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPfBarAddrmap_call::has_req() const {
  return _internal_has_req();
}
inline void xclPfBarAddrmap_call::clear_req() {
  _impl_.req_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool xclPfBarAddrmap_call::_internal_req() const {
  return _impl_.req_;
}
inline bool xclPfBarAddrmap_call::req() const {
  // @@protoc_insertion_point(field_get:xclPfBarAddrmap_call.req)
  return _internal_req();
}
inline void xclPfBarAddrmap_call::_internal_set_req(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.req_ = value;
}
inline void xclPfBarAddrmap_call::set_req(bool value) {
  _internal_set_req(value);
  // @@protoc_insertion_point(field_set:xclPfBarAddrmap_call.req)
}

// -------------------------------------------------------------------

// xclPfBarAddrmap_response_PfBarmaps

// required uint64 pf_id = 1;
inline bool xclPfBarAddrmap_response_PfBarmaps::_internal_has_pf_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool xclPfBarAddrmap_response_PfBarmaps::has_pf_id() const {
  return _internal_has_pf_id();
}
inline void xclPfBarAddrmap_response_PfBarmaps::clear_pf_id() {
  _impl_.pf_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::_internal_pf_id() const {
  return _impl_.pf_id_;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::pf_id() const {
  // @@protoc_insertion_point(field_get:xclPfBarAddrmap_response.PfBarmaps.pf_id)
  return _internal_pf_id();
}
inline void xclPfBarAddrmap_response_PfBarmaps::_internal_set_pf_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pf_id_ = value;
}
inline void xclPfBarAddrmap_response_PfBarmaps::set_pf_id(uint64_t value) {
  _internal_set_pf_id(value);
  // @@protoc_insertion_point(field_set:xclPfBarAddrmap_response.PfBarmaps.pf_id)
}

// required uint64 bar_id = 2;
inline bool xclPfBarAddrmap_response_PfBarmaps::_internal_has_bar_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool xclPfBarAddrmap_response_PfBarmaps::has_bar_id() const {
  return _internal_has_bar_id();
}
inline void xclPfBarAddrmap_response_PfBarmaps::clear_bar_id() {
  _impl_.bar_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::_internal_bar_id() const {
  return _impl_.bar_id_;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::bar_id() const {
  // @@protoc_insertion_point(field_get:xclPfBarAddrmap_response.PfBarmaps.bar_id)
  return _internal_bar_id();
}
inline void xclPfBarAddrmap_response_PfBarmaps::_internal_set_bar_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bar_id_ = value;
}
inline void xclPfBarAddrmap_response_PfBarmaps::set_bar_id(uint64_t value) {
  _internal_set_bar_id(value);
  // @@protoc_insertion_point(field_set:xclPfBarAddrmap_response.PfBarmaps.bar_id)
}

// required uint64 remap_addr = 3;
inline bool xclPfBarAddrmap_response_PfBarmaps::_internal_has_remap_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool xclPfBarAddrmap_response_PfBarmaps::has_remap_addr() const {
  return _internal_has_remap_addr();
}
inline void xclPfBarAddrmap_response_PfBarmaps::clear_remap_addr() {
  _impl_.remap_addr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::_internal_remap_addr() const {
  return _impl_.remap_addr_;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::remap_addr() const {
  // @@protoc_insertion_point(field_get:xclPfBarAddrmap_response.PfBarmaps.remap_addr)
  return _internal_remap_addr();
}
inline void xclPfBarAddrmap_response_PfBarmaps::_internal_set_remap_addr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.remap_addr_ = value;
}
inline void xclPfBarAddrmap_response_PfBarmaps::set_remap_addr(uint64_t value) {
  _internal_set_remap_addr(value);
  // @@protoc_insertion_point(field_set:xclPfBarAddrmap_response.PfBarmaps.remap_addr)
}

// required uint64 size = 4;
inline bool xclPfBarAddrmap_response_PfBarmaps::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool xclPfBarAddrmap_response_PfBarmaps::has_size() const {
  return _internal_has_size();
}
inline void xclPfBarAddrmap_response_PfBarmaps::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t xclPfBarAddrmap_response_PfBarmaps::size() const {
  // @@protoc_insertion_point(field_get:xclPfBarAddrmap_response.PfBarmaps.size)
  return _internal_size();
}
inline void xclPfBarAddrmap_response_PfBarmaps::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_ = value;
}
inline void xclPfBarAddrmap_response_PfBarmaps::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xclPfBarAddrmap_response.PfBarmaps.size)
}

// -------------------------------------------------------------------

// xclPfBarAddrmap_response

// repeated .xclPfBarAddrmap_response.PfBarmaps pfbar_map = 1;
inline int xclPfBarAddrmap_response::_internal_pfbar_map_size() const {
  return _impl_.pfbar_map_.size();
}
inline int xclPfBarAddrmap_response::pfbar_map_size() const {
  return _internal_pfbar_map_size();
}
inline void xclPfBarAddrmap_response::clear_pfbar_map() {
  _impl_.pfbar_map_.Clear();
}
inline ::xclPfBarAddrmap_response_PfBarmaps* xclPfBarAddrmap_response::mutable_pfbar_map(int index) {
  // @@protoc_insertion_point(field_mutable:xclPfBarAddrmap_response.pfbar_map)
  return _impl_.pfbar_map_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPfBarAddrmap_response_PfBarmaps >*
xclPfBarAddrmap_response::mutable_pfbar_map() {
  // @@protoc_insertion_point(field_mutable_list:xclPfBarAddrmap_response.pfbar_map)
  return &_impl_.pfbar_map_;
}
inline const ::xclPfBarAddrmap_response_PfBarmaps& xclPfBarAddrmap_response::_internal_pfbar_map(int index) const {
  return _impl_.pfbar_map_.Get(index);
}
inline const ::xclPfBarAddrmap_response_PfBarmaps& xclPfBarAddrmap_response::pfbar_map(int index) const {
  // @@protoc_insertion_point(field_get:xclPfBarAddrmap_response.pfbar_map)
  return _internal_pfbar_map(index);
}
inline ::xclPfBarAddrmap_response_PfBarmaps* xclPfBarAddrmap_response::_internal_add_pfbar_map() {
  return _impl_.pfbar_map_.Add();
}
inline ::xclPfBarAddrmap_response_PfBarmaps* xclPfBarAddrmap_response::add_pfbar_map() {
  ::xclPfBarAddrmap_response_PfBarmaps* _add = _internal_add_pfbar_map();
  // @@protoc_insertion_point(field_add:xclPfBarAddrmap_response.pfbar_map)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xclPfBarAddrmap_response_PfBarmaps >&
xclPfBarAddrmap_response::pfbar_map() const {
  // @@protoc_insertion_point(field_list:xclPfBarAddrmap_response.pfbar_map)
  return _impl_.pfbar_map_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rpc_5fmessages_2eproto
